[{"title":"红黑树学习记录","url":"/2022/03/27/%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E7%BA%A2%E9%BB%91%E6%A0%91/","content":" 红黑树性质\n红黑树和基本 AVLAVLAVL 不同，不需要频繁进行高度平衡判断，而是使用黑节点的个数，对树型进行维护。\n具有以下性质：\n\n每个节点只能是黑、红两种颜色的一种\n根节点一定为黑色，外节点看作黑色\n不能有两个相连的节点同为红色\n\n从根到任何一个外节点的路径上，黑色节点个数相同\n\n\n其中 444 性质最为重要，对红黑树的插入、删除更新，都是为满足其性质进行的。\n 插入\n首先需要明确，新插入一个节点时，应该是什么颜色。\n考虑如果是黑色，那新节点插入的路径上，黑色个数增加，显然需要向上进行调整，以确保 444 性质的成立，这就增加了额外的操作。\n所以新增加的节点，颜色应为红色。\n为解释方便，插入部分各节点关系如下：\n\n\n\n其中，000 表示左子树，111 表示右子树。\nNoNoNo 为插入的节点，插入时，按照普通二叉查找树的方式进行插入，待新节点插入到位后，再按照以下情况进行调整。\n处理过程中，要特别注意对根节点的处理。\n这里主要讲解插入节点为左子树的情况，右子树的处理就是其镜像变换，可以通过代码简单描述。\n 1.0 father为黑\n显然，插入后的树满足所有的性质，无需进行更新。\n 1.1 father、uncle为红\n此时，将 fa,unclefa,unclefa,uncle 变为黑色，ffaffaffa 变为红色。但这种处理可能导致 ffaffaffa 出现双红冲突，所以需要继续对 ffaffaffa 进行处理（此时 ffaffaffa 相当于 NoNoNo）。\n\n\n\n 1.2 father为红，uncle为黑\n需注意，uncleuncleuncle 为外节点的话，颜色也是黑色。\n 1.2.1 fa、No不在同一方向\n将 NoNoNo 左旋，变为 1.2.21.2.21.2.2 所属情况，同时待处理的节点变为 fafafa 。\n\n\n\n 1.2.2 fa、No在同一方向\n将 fafafa 右旋，同时 fa,ffafa,ffafa,ffa 颜色互换。\n\n\n\n 删除\n红黑树的删除较为复杂，需针对多种情况进行处理。\n此部分的节点关系如下：\n\n\n\n其中 NoNoNo 为待删除的节点。\n 2.0 No有两个子树\n处理方式同二叉查找树，先将 NoNoNo 和后继 ppp 交换，然后再进行删除。之后情况便转换为 2.1、2.2、2.32.1、2.2、2.32.1、2.2、2.3 其中之一。\n\n\n\n 2.1 No为红色叶节点\n直接将 NoNoNo 删去即可，并不会影响树的性质，此处 fafafa 为白色，表示其颜色无需考虑（之后同理）。\n\n\n\n 2.2 No为黑色，且只有一个子树\n此时 NoNoNo 唯一的一个子节点一定是红色，将 NoNoNo 删除后，用 fafafa 连接到其子节点，并将子节点颜色改为黑色。\n\n\n\n 2.3 No为黑色叶节点\n 2.3.1 br为红色\n将 brbrbr 左旋，同时 br,fabr,fabr,fa 颜色互换。之后继续在调整后的树上，对 NoNoNo 进行调整。\n\n\n\n 2.3.2 br为黑，远侄子为黑，近侄子为红\n此时远侄子一定是外节点，将 blsblsbls 右旋，同时 br,blsbr,blsbr,bls 颜色互换，情况变为 2.3.32.3.32.3.3 ，之后继续在调整后的树上，对 NoNoNo 进行调整。\n\n\n\n 2.3.3 br为黑，远侄子为红\n将 brbrbr 左旋，同时 br,fabr,fabr,fa 颜色互换，brsbrsbrs 变为黑色，删除 NoNoNo 后，fafafa 左儿子为空。\n\n\n\n 2.3.4 fa为红，br为黑叶子\nnls,nrs,bls,brsnls,nrs,bls,brsnls,nrs,bls,brs 此时全为外节点，将 NoNoNo 删除，fafafa 左儿子为空，同时 fa,brfa,brfa,br 颜色互换。\n\n\n\n 2.3.5 fa为黑，br为黑叶子\n与 2.3.42.3.42.3.4 处理方式相同，不过处理完 NoNoNo 后，要将 fafafa 当成新的待处理节点，继续向上更新。\n 部分代码\n 节点结构体\nstruct Node&#123;    /* 存放数据 */    int data;    /* 颜色，0红，1黑 */    int color;    /* 0左，1右，之后涉及到方向都这么规定 */    Node *next[2];    /* 父亲 */    Node *father;&#125;;\n这里将左右子节点的指针放到一个数组中，而不是分别开两个变量，是为了简化后续操作做好准备\n 旋转\n显然，旋转分为左旋和右旋，而不同的旋转，需要操作不同的指针。\n但观察旋转方式可以发现，旋转时各指针操作的相对位置是一样的，比如都是保留和自己同方向的子节点，而反方向的子节点接到父节点的同方向。\n\n\n注意观察，左右子节点的变化规律\n\n因此，借助结构体的定义方式，我们可以通过一个函数，解决所有旋转操作。\n/* 将No按照direction反方向旋转 *//* 如No右旋时，No为左子树，direction=0 */void rotate(Node *No, int direction)&#123;    /* 获取No的父亲和祖先 */    Node *fa = No-&gt;father, *ffa = fa-&gt;father;    /* 对父亲进行更改 */    No-&gt;father = fa-&gt;father;    fa-&gt;father = No;    /* 父亲同方向连接No反方向叶节点 */    fa-&gt;next[direction] = No-&gt;next[direction ^ 1];    /* 注意子树是否存在 */    if (No-&gt;next[direction ^ 1])        No-&gt;next[direction ^ 1]-&gt;father = fa;    /* 父亲变为反方向叶节点 */    No-&gt;next[direction ^ 1] = fa;    /* 根节点特判 */    if (!ffa)    &#123;        root = No;        return;    &#125;    /* 处理祖先 */    if (ffa-&gt;next[0] == fa)        ffa-&gt;next[0] = No;    else        ffa-&gt;next[1] = No;&#125;\n 查找\n想要完成插入或者删除，则必须先有查找。\n/* 查找值域为x的节点，找到返回节点，否则返回最后查找失败的叶节点 */Node *findNode(const int x)&#123;    /* 树为空 */    if (!root)        /* 返回无效值 */        return NULL;    /* 从根开始 */    Node *No = root;    while (1)    &#123;        /* 去右子树 */        if (x &gt; No-&gt;data)        &#123;            if (No-&gt;next[1])                No = No-&gt;next[1];            else                return No;        &#125;        /* 去左子树 */        else if (x &lt; No-&gt;data)        &#123;            if (No-&gt;next[0])                No = No-&gt;next[0];            else                return No;        &#125;        /* 找到x */        else            return No;    &#125;&#125;\n 插入\n插入时，需要先进行查找，如果值存在，则无需插入，否则，在失败叶节点下插入新节点，并对新节点更新。\n/* 对No进行更新 */void insertUpdate(Node *No)&#123;    while (1)    &#123;        /* getDirection确定No的方向 */        int direction = getDirection(No);        /* 处理到根节点 */        if (direction == -1)        &#123;            /* root_color is black */            No-&gt;color = 1;            return;        &#125;        /* 意义同之前的介绍 */        Node *fa, *ffa, *uncle;        fa = No-&gt;father;        /* fa黑色，无需处理 */        if (fa-&gt;color)            return;        ffa = fa-&gt;father;        /* uncle为fa的反向节点 */        uncle = ffa-&gt;next[getDirection(fa) ^ 1];        /* 1.1情况 */        if (uncle &amp;&amp; uncle-&gt;color == 0)        &#123;            /* changeColor改变节点颜色 */            fa-&gt;changeColor();            ffa-&gt;changeColor();            uncle-&gt;changeColor();            No = ffa;        &#125;        /* 1.2情况 */        else        &#123;            /* 1.2.1情况 */            if (ffa-&gt;next[direction] != fa)            &#123;                /* 旋转No */                rotate(No, direction);                No = fa;                continue;            &#125;            /* 1.2.2情况 */            rotate(fa, direction);            fa-&gt;changeColor();            ffa-&gt;changeColor();            return;        &#125;    &#125;&#125;/* 插入x */void insert(const int x)&#123;    /* 树为空，则直接创建根节点 */    if (!root)    &#123;        root = new Node(x, 1, 0);        return;    &#125;    /* 查找x */    Node *No = findNode(x);    /* 建立右子树 */    if (x &gt; No-&gt;data)    &#123;        No-&gt;next[1] = new Node(x, 0, No);        /* 对新节点进行更新 */        insertUpdate(No-&gt;next[1]);    &#125;    /* 建立左子树 */    else if (x &lt; No-&gt;data)    &#123;        No-&gt;next[0] = new Node(x, 0, No);        insertUpdate(No-&gt;next[0]);    &#125;&#125;\n 删除\n删除操作较为复杂，尤其是删除黑色叶节点，需要注意顺序，一种一种情况去处理。\n/* 针对2.0情况，寻找No的后继 */Node *removeChange(Node *No)&#123;    /* Ne是要寻找的后继，初始为No右子树 */    Node *Ne = No-&gt;next[1];    /* 不断向下，直到Ne没有左子树 */    while (Ne-&gt;next[0])        Ne = Ne-&gt;next[0];    /* 交换No，Ne */    No-&gt;data = Ne-&gt;data;    /* 将后继返回 */    return Ne;&#125;/* 针对2.3情况，黑叶子删除后的更新 */void removeblackNode(Node *No)&#123;    while (1)    &#123;        /* 确定No方向 */        int direction = getDirection(No);        /* 处理到根节点为止 */        if (direction == -1)        &#123;            No-&gt;color = 1;            return;        &#125;        /* fa，brother(br)意义同介绍 */        Node *fa = No-&gt;father;        /* br是No反向节点 */        Node *brother = fa-&gt;next[direction ^ 1];        /* 2.3.1情况 */        if (brother-&gt;color == 0)        &#123;            rotate(brother, direction ^ 1);            swap(fa-&gt;color, brother-&gt;color);        &#125;        /* br为黑色 */        else if (brother-&gt;color == 1)        &#123;            /* 2.3.3情况 */            if (brother-&gt;next[direction ^ 1] &amp;&amp; brother-&gt;next[direction ^ 1]-&gt;color == 0)            &#123;                rotate(brother, direction ^ 1);                swap(fa-&gt;color, brother-&gt;color);                brother-&gt;next[direction ^ 1]-&gt;color = 1;                return;            &#125;            /* 2.3.2情况 */            else if (brother-&gt;next[direction] &amp;&amp; brother-&gt;next[direction]-&gt;color == 0)            &#123;                swap(brother-&gt;color, brother-&gt;next[direction]-&gt;color);                rotate(brother-&gt;next[direction], direction);            &#125;            /* br是黑叶子 */            else            &#123;                /* 2.3.4情况 */                if (fa-&gt;color == 0)                &#123;                    fa-&gt;changeColor();                    fa-&gt;next[direction ^ 1]-&gt;changeColor();                    return;                &#125;                /* 2.3.5情况 */                else                &#123;                    fa-&gt;next[direction ^ 1]-&gt;changeColor();                    /* 继续处理fa */                    No = fa;                &#125;            &#125;        &#125;    &#125;&#125;/* No删除后的更新 */void removeUpdate(Node *No)&#123;    while (1)    &#123;        /* 确定No方向 */        int direction = getDirection(No);        Node *fa = No-&gt;father;        /* No为叶节点 */        if (!(No-&gt;next[0] || No-&gt;next[1]))        &#123;            /* 根节点特判 */            if (No == root)            &#123;                root = NULL;                /* 处理结束 */                goto removeUpdateEnd;            &#125;            /* 2.1情况 */            else if (No-&gt;color == 0)            &#123;                fa-&gt;next[direction] = NULL;                goto removeUpdateEnd;            &#125;            /* 2.3情况 */            else            &#123;                /* 针对5种情况处理 */                removeblackNode(No);                No-&gt;father-&gt;next[direction] = NULL;                goto removeUpdateEnd;            &#125;        &#125;        /* 2.0情况，No两个子树 */        else if (No-&gt;next[0] &amp;&amp; No-&gt;next[1])            No = removeChange(No);        /* 2.2情况，No只有一个子树 */        else            for (int i = 0; i &lt;= 1; ++i)                if (No-&gt;next[i])                &#123;                    /* 注意根节点的特殊处理 */                    if (fa)                        fa-&gt;next[direction] = No-&gt;next[i];                    if (No == root)                        root = No-&gt;next[i];                    No-&gt;next[i]-&gt;father = fa;                    No-&gt;next[i]-&gt;color = 1;                    goto removeUpdateEnd;                &#125;    &#125;removeUpdateEnd:    /* 更新完成后再删除No */    delete No;&#125;/* 删除值为x的节点 */void remove(const int x)&#123;    /* 查找x */    Node *No = findNode(x);    /* 树为空 || 值为x的节点不存在 , 无需处理 */    if (!No || No-&gt;data != x)        return;    /* 进行删除和更新 */    removeUpdate(No);&#125;\n 总结\n红黑树的代码算是平衡树中比较复杂的，不过虽然看起来代码冗长和复杂，其实就是对之前分析的几种情况的模拟，以上红黑树主要实现部分的代码，删去注释和多余的括号空行后，大概180多行，对于一个复杂的平衡树代码来说，已经算是很正常的了。大部分数据结构的原理都比较简单，代码实现才是难点。\n","categories":["知识","数据结构"],"tags":["数据结构","平衡树","红黑树","C++"]},{"title":"学校数据结构2022-03-11上机题","url":"/2022/03/11/%E9%A2%98%E8%A7%A3/%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE/%E6%9D%82%E9%A2%98%E6%95%B4%E7%90%86-%E5%AD%A6%E6%A0%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8420220311%E4%B8%8A%E6%9C%BA%E9%A2%98/","content":" T1 手撕STL sort\n 问题描述\n模拟实现C++中STL sort的功能。\n设数组 aaa 中有 nnn 个元素，有三个要求。\n\n当递归区间小于设定值时，直接返回。\n当递归深度超过 ⌊2⋅log⁡2n⌋\\lfloor 2 \\cdot \\log_{2}{n} \\rfloor⌊2⋅log2​n⌋ 时，转为堆排序。\n最后对整个数组进行直接插入排序。\n\n 题解\n这题解法都已经给好了，就对着书上把相应的代码抄下来，然后按照题意组合就行了。注意若区间足够小，一定是先返回，只有当要求 111 不满足时，才考虑堆排序。\n T2 冬奥会接驳车\n 问题描述\n一个 n×mn \\times mn×m 的矩阵，其中每个元素为，000 空地，111 障碍，333 起点，444 终点。\n一个人从起点出发，只能上下左右移动，不能碰到障碍，求最少几步能够到终点。\n1≤n,m≤1001 \\le n,m \\le 1001≤n,m≤100\n 题解\n显而易见的 BFSBFSBFS 问题，从起点开始，每次向四个方向扩展，走到的地方如果不是障碍且步数更少就入队，直到走到终点即可。如果所有元素出队后，终点仍未入队（没走到），则无解。\n(X,Y) &#x3D;&gt; 队列Q;   dis(X,Y) &#x3D; 0;   &#x2F;&#x2F;起点入队，dis记录步数while (head &lt; tail)     &#x2F;&#x2F;队列不空&#123;    Q &#x3D;&gt; (X,Y);    for (int i &#x3D; 0; i &lt; 4; ++i)    &#123;        (X,Y) + next[i] -&gt; (x,y);   &#x2F;&#x2F;向四个方向扩展        if (x,y)未过边界 &amp;&amp; (x,y)不是障碍 &amp;&amp; (dis(X,Y) + 1 &lt; dis(x,y))        &#123;            dis(x,y) &#x3D; dis(X,Y) + 1;            (x,y) &#x3D;&gt; Q;     &#x2F;&#x2F;新点入队        &#125;    &#125;&#125;\n时间复杂度 O(n⋅m)O(n \\cdot m)O(n⋅m) 。\n T3 自动纠错\n 问题描述\n两个字符串 s1,s2s1,s2s1,s2 之间的距离 disdisdis 定义为，有三种操作：\n\n删去任意位置一个字符\n增加任意位置一个字符\n改变任意位置一个字符\n\ns1s1s1 改变为 s2s2s2 所需要的最小的操作次数，为两者间的距离。如图所示的距离（上 s1s1s1 ，下 s2s2s2 ）为 444 。\n\n\n\n现有一个字典，其中有 nnn 个元素，每个元素为字符串 sss 和其对应的频率 ppp 。\n给出 mmm 个询问，每个询问为一个字符串 qqq ，问字典中哪些字符串和 qqq 的距离在 ddd 之内，并输出其中频率最高的（频率相同时字典序更小）。\nn≤104,m≤103,d≤2n \\le 10^4,m \\le 10^3,d \\le 2n≤104,m≤103,d≤2\n 题解\n 数据结构\n具体的数据结构题目已经很明显的给出了：\n一种高效的处理方法是：结合各单词间的距离，将字典组织成一棵多叉树。在该树中，每个结点表示一个单词，对于每个结点 ppp ，其第 iii 棵子树包含与 ppp 的距离为 iii 的所有单词对应的结点。\n树的创建过程如下：取字典中任意单词作为根结点，比如第一个单词。然后将剩余单词逐个插入到树中，插入一个新单词 www 时，首先计算该单词与根结点的距离 ddd 。若根结点的第 ddd 个子树为空，则将单词 www 对应的结点作为根结点的第 ddd 个子结点。若根结点的第 ddd 个子树非空，即根结点已有第 ddd 个子结点 pdp_dpd​ 。则按上述规则将单词 www 递归插入以 pdp_dpd​ 为根的子树，即计算 www 与 pdp_dpd​ 的距离…。\n例如字典为 help,hell,hello,shell,helper,sloop,helps,troophelp, hell, hello, shell, helper, sloop, helps, troophelp,hell,hello,shell,helper,sloop,helps,troop ，将 helphelphelp 作为根结点，然后将 hellhellhell 插入，hellhellhell 与 helphelphelp 的距离为 111 ，故 hellhellhell 作为 helphelphelp 的第一个子结点。hellohellohello 与 helphelphelp 的距离为 222 ，故 hellohellohello 作为 helphelphelp 的第 222 个子结点。如下图 (a)(a)(a) 所示。\n\n\n\n然后插入 shell,shellshell,shellshell,shell 与 helphelphelp 的距离为 222 ，故应在 helphelphelp 的第 222 个子树里，但 helphelphelp 已经有第 222 个子结点 hellohellohello 了，此时将 shellshellshell 递归插入以 hellohellohello 为根结点的子树：计算 shellshellshell 与 hellohellohello 的距离为 222 ，将 shellshellshell 作为 hellohellohello 的第 222 个子结点，如上图 (b)(b)(b) 所示。插入 helperhelperhelper 时，helperhelperhelper 与 helphelphelp 的距离为 222 ，将 helperhelperhelper 递归插入以 hellohellohello 为根结点的子树：计算 helperhelperhelper 与 hellohellohello 的距离为 333 ，将 helperhelperhelper 作为 hellohellohello 的第 333 个子结点。以此类推，最终上述字典对应的树结构如上图 (c)(c)(c) 所示。该树结构保证与任意结点距离为 ddd 的单词都在该结点的第 ddd 棵子树里。\n假定我们需要向用户返回与错误单词距离不超过 nnn 的单词，当用户输入一个单词 www 时，在树中查询 www ，计算 www 与根结点 TTT 的距离 ddd ，接下来我们不必考察 TTT 的所有子树中是否包含与 www 距离不超过 nnn 的结点/单词，而只需要递归考察根结点 TTT 的第 d−nd-nd−n 到第 d+nd+nd+n 棵子树即可。例如 n=1,d=5n=1,d=5n=1,d=5 ，我们只需要递归考察根 TTT 的第 444 、第555、第666棵子树是否包含与www距离不超过111的结点/单词。其他子树无需考察，为什么呢？举个例子，我们考虑根TTT的第333棵子树的任意结点PPP。www与TTT的距离为d=5d=5d=5，即www最少经过555步操作才能转换为TTT，TTT与PPP的距离为333，TTT经过最少333步操作才能变为PPP，这意味着www至少需要222步操作才能变为PPP。不可能通过111步操作变为PPP。故第333棵子树的所有结点都不满足条件。\n\n\n\n由于nnn通常很小，因此该方法在查询时往往可以排除很多子树，进而节省时间。当考察一个结点时，计算www与该结点的距离ddd；若d=0d=0d=0，意味着用户输入的单词www在字典中，是正确的单词；若d&gt;nd &gt; nd&gt;n则该结点不是候选单词，继续递归考察该结点第d−nd-nd−n到d+nd+nd+n的子树。若d≤nd ≤ nd≤n则该结点就是候选单词之一，此时可有两种策略，一是将该单词直接返回给用户，二是继续向下考察子树，找出所有候选单词并选择用户历史使用频率最高的单词返回给用户。\n以上为题目给出的算法，注意这个算法时间复杂度并不严格，只是能在某种程度上减少比较次数，但可以确保通过此题（需注意实现算法的常数）。\n 计算字符串距离\n除此以外，还有一个重要的问题就是，如何计算两个字符串的距离。\n可见每个位置都有三种操作，如果直接暴力比较，虽然字符串的长度只有 151515 ，也仍然需要 3153^{15}315 次比较，显然是无法接受的。\n这里提出一种有效的解决方案，这个问题可以使用动态规划解决。\n设 dp[i][j]dp[i][j]dp[i][j] 为 s1s1s1 考虑到 iii 位置，s2s2s2 考虑到 jjj 位置，$s1_{1 \\cdots i},s2_{1 \\cdots j} $ （前缀）的距离。显然对于 i,ji,ji,j 有两种情况：\n\ns1[i]=s2[j]s1[i]=s2[j]s1[i]=s2[j] ，此时 dp[i][j]=dp[i−1][j−1]dp[i][j]=dp[i-1][j-1]dp[i][j]=dp[i−1][j−1]\ns1[i]≠s2[j]s1[i] \\not = s2[j]s1[i]=s2[j] ，此时 dp[i][j]=min{dp[i−1][j−1],dp[i−1][j],dp[i][j−1]}+1dp[i][j]=min\\{dp[i-1][j-1],dp[i-1][j],dp[i][j-1]\\}+1dp[i][j]=min{dp[i−1][j−1],dp[i−1][j],dp[i][j−1]}+1\n\n对于 111 很好理解，两个位置相同，就没必要操作，直接从之前的状态扩展即可。\n对于 222 ，三个式子正好对应三种操作（改变，增加，减少），因为要次数最少，所以取三者最小值，再加上一次操作次数，拓展到新状态。\n边界条件可根据状态得出：\n\ndp[i][0]=idp[i][0]=idp[i][0]=i 显然 s2s2s2 是空，则 s1s1s1 最少通过减 iii 个字符与其相同。\ndp[0][j]=jdp[0][j]=jdp[0][j]=j 同上。\n\nint Dis(char *s1, char *s2)&#123;    int len1 &#x3D; strlen(s1);    int len2 &#x3D; strlen(s2);    int dp[Max_len][Max_len] &#x3D; &#123;0&#125;;    int len &#x3D; max(len1, len2);    for (register int i &#x3D; 0; i &lt;&#x3D; len; ++i)        dp[i][0] &#x3D; dp[0][i] &#x3D; i;       &#x2F;&#x2F;边界条件    for (register int i &#x3D; 1; i &lt;&#x3D; len1; ++i)        for (register int j &#x3D; 1; j &lt;&#x3D; len2; ++j)            if (s1[i - 1] &#x3D;&#x3D; s2[j - 1])                dp[i][j] &#x3D; dp[i - 1][j - 1];    &#x2F;&#x2F;情况1            else                dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;      &#x2F;&#x2F;情况2    return dp[len1][len2];&#125;\n时间复杂度 O(len2)O(len^2)O(len2) ，lenlenlen 为字符串长度。\n","categories":["题解","吉林大学","数据结构课设"],"tags":["C++","快速排序","BFS","字符串","动态规划"]},{"title":"学校数据结构2022-03-04上机题","url":"/2022/03/04/%E9%A2%98%E8%A7%A3/%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE/%E6%9D%82%E9%A2%98%E6%95%B4%E7%90%86-%E5%AD%A6%E6%A0%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8420220304%E4%B8%8A%E6%9C%BA%E9%A2%98/","content":" T1 冬奥村网络布线方案\n 问题描述\n冬奥会的奥运村是各国运动员在冬奥会期间的住宿公寓，冬奥会期间需要保证奥运村网络畅通，以使运动员都能正常上网。\n假定奥运村有 nnn 个房间，编号为 0⋯n−10 \\cdots n−10⋯n−1 ，每个房间都需要网络连接。房间 iii 有网络，当且仅当满足如下 222 个条件之一：\n\n房间 iii 安装了路由器（成本为 ri&gt;0r_i&gt;0ri​&gt;0 ）\n房间 iii 和房间 jjj 有网线连接且房间 jjj 有网络（在房间 iii 和房间 jjj 之间布置网线的成本为 fi,j&gt;0f_{i,j}&gt;0fi,j​&gt;0 ）\n\n假定你是奥组委的网络工程师，请编写程序为奥组委设计一个网络布线方案（哪些房间安装路由器，哪些房间之间布置网线），使得所有房间都有网络，且总成本最小。\n点数 n≤600n \\le 600n≤600 ，边数不超过 2×1052 \\times 10^52×105 。\n 题解\n可以发现每个点有三种状态，分别是：\n\n第一层：无网络\n第二层：有网络（装有路由器）\n第三层：有网络（其他房间扩散）\n\n据此，可将每个点分成三层，第一层与原点 SSS 连权值为零的边（不要网自然不要费用），第一层向第二层对应的点连边，权值为原点权（装路由器通网的费用），第二层向第三层对应点连权值为零的边（本身装路由器了，自然不需要网线），同时，第三层之间的房间可以相互影响，所以依据原图关系，在相应的点之间连边，费用为原边权（装网线费用）。如下图所示。\n\ngraph BT\n\nA1((0))\nA2((0'))\nA3((0''))\nB1((1))\nB2((1'))\nB3((1''))\nC1((2))\nC2((2'))\nC3((2''))\nD1((3))\nD2((3'))\nD3((3''))\nE1((4))\nE2((4'))\nE3((4''))\nF1((5))\nF2((5'))\nF3((5''))\nG1((6))\nG2((6'))\nG3((6''))\nS((S))\n\nS---|0|A1\nS---|0|B1\nS---|0|C1\nS---|0|D1\nS---|0|E1\nS---|0|F1\nS---|0|G1\nA1---|60|A2\nB1---|10|B2\nC1---|35|C2\nD1---|55|D2\nE1---|40|E2\nF1---|70|F2\nG1---|70|G2\nA2---|0|A3\nB2---|0|B3\nC2---|0|C3\nD2---|0|D3\nE2---|0|E3\nF2---|0|F3\nG2---|0|G3\nA3---|20|B3\nA3---|75|E3\nA3---|45|D3\nB3---|50|D3\nB3---|15|C3\nC3---|5|G3\nF3---|45|G3\nE3---|5|F3\nD3---|25|F3\nD3---|65|G3\n\n可见，最终的目标就是通过连边覆盖图上的全部节点，只需要进行一遍最小生成树的计算即可。从原点 SSS 使用 PrimPrimPrim 计算，时间复杂度 O(n2)O(n^2)O(n2) 。\n T2&amp;T3 冬奥会网站功能提升\n 问题描述\n一个字典里有 nnn 个字符串及其优先级，之后有 mmm 个询问，对于每一个询问，给出一个模式串 ppp ，要求找出优先级前 KKK 个字符串 s1⋯sKs_1 \\cdots s_Ks1​⋯sK​ ，要求 ppp 是 si,i=1⋯Ks_i,i=1 \\cdots Ksi​,i=1⋯K 的前缀，且 p≠sip \\not= s_ip=si​ 。\n 题解\n对于这个问题，我们并不需要相现实中一样，对于每个询问，立即查找答案，而是先将所有的询问保存下来，再用给出的字符串去往询问中放，看他能成为哪个询问的答案。\n这个解法使用了字典树 TrieTrieTrie ，用于处理字符串匹配。\n首先将所有询问的字符串放入一个字典树中，同时在节点做上标记，111 代表这是一个字符串的结尾，如样例中形成的字典树如下：\n\ngraph TB\n\nA((Root))\nB((0))\nC((1))\nD((1))\nE((0))\nF((0))\nG((1))\n\nA--t-->B\nB--h-->C\nC--e-->D\nA-->|x|E\nE-->|x|F\nF-->|x|G\n\n之后将所有字典里的字符串按照题目要求，按优先级从高到低排序，将排序后的字符串放到字典树里比较，如果遇到节点为 111 ，且节点中存储的答案不超过 KKK 时，则将字符串作为答案存入该节点。如 theytheythey ，比较后则会存入左下方的两个节点。\n待所有字典中的字符串都处理完后，再依次用询问的字符串放入字典树比较，匹配成功后，取出末尾节点中的答案输出即可。如 thethethe 则会匹配到最左下方的节点，并输出其中所保存的答案。\n设字符串平均长度为 lenlenlen ，对字典字符串进行排序复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) ，字典树操作复杂度 O(m⋅len)O(m \\cdot len)O(m⋅len) 。\n需要注意的是，在大量的输出数据的情况下，题目 60ms60ms60ms 的时限非常紧促，建议程序中不要使用 stringstringstring 和其他库函数，最好加上 inline,registerinline,registerinline,register 等，整形较小时使用 shortshortshort 而非 long longlong\\ longlong long ，输入输出使用 gets,fputsgets,fputsgets,fputs 等较快的方式。（ scanf,printfscanf,printfscanf,printf 我都过不去）\n优化和卡常前后的速度对比：\n\n\n\n\n","categories":["题解","吉林大学","数据结构课设"],"tags":["C++","最小生成树","字典树Trie"]},{"title":"学校数据结构2021-12-13上机题","url":"/2021/12/13/%E9%A2%98%E8%A7%A3/%E5%90%89%E6%9E%97%E5%A4%A7%E5%AD%A6/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE/%E6%9D%82%E9%A2%98%E6%95%B4%E7%90%86-%E5%AD%A6%E6%A0%A1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8420211213%E4%B8%8A%E6%9C%BA%E9%A2%98/","content":" T1 小龙猜数字\n 问题描述\n定义字符串的秩为：该字符串长度减去该字符串的最短相等前后缀的长度。若该字符串不存在相等的前后缀，则其秩为 000 。\n给出一个字符串 SSS ，需计算 SSS 及 SSS 中所有前缀子串的秩之和。\n字符串长度不超过 10610^6106 。\n 题解\n此题目为 KMPKMPKMP 数组的应用，但 KMPKMPKMP 失败数组求的是最长的相等前后缀，所以要对其进行修改。&lt;center&gt;&lt;/center&gt;\n如图，对于 ababababababababab 其失败数组标明了前后缀相等的子串为 abababababab ，而子串 abababababab 的失败数组标明了最长前后缀相等的是 ababab ，而因为在原串中前后缀相等的性质，可知原串中必有相等的前后缀 ababab 。\n因此，可通过不断访问子串的失败数组，来得到最小前缀。\n但需要注意，当 SSS 中所有字符都相等时，该算法时间复杂度为 O(n2)O(n^2)O(n2) 。因此需要将子串失败数组，按照类似并查集的方式进行路径压缩。&lt;center&gt; &lt;/center&gt;比如在 ababaababaababa 中，根据失败数组访问子串 abaabaaba 时，发现 abaabaaba 的失败数组为 000 ，则可将 ababaababaababa 失败数组也改成 000 ，同理可将 ababababababababab 失败数组改成 111 。\n T2 二叉树路径和\n 问题描述\n给定一颗二叉树，树有点权，求问是否有一条路径，其点权和为 KKK 。\n“路径”定义为二叉树中的结点序列 vi,vi+1,...,vjv_i ,v_{i+1},..., v_jvi​,vi+1​,...,vj​ ，序列中前一个结点是后一个结点的父结点。\n如有多条路径，输出最短的一条，且最靠右，最靠叶节点。\n有多组数据，总结点数不超过 1.5×1051.5 \\times 10^51.5×105 。\n 题解\n不知此题有没有什么暴力出奇迹的解法，但如果数据强度足够，这题应该是几次上机以来最难的一题。\n首先各种暴力，如两次 DFSDFSDFS ，从叶节点反着找等等，都是时间复杂度 O(n2)O(n^2)O(n2) 的，很容易超时。\n这里提供一种方式，理论上可以通过。\n首先，这题输入就比较麻烦，因为并不知道树有多少个节点，而且还是多组数据，没法用 EOFEOFEOF 等方式判断一组数据是否输入结束。同时为了优化时间，选择读入同时建树，依据二叉树带空指针的先根序列表示法，当对应的树建成，就代表一组数据已经读完了。\n代码结构大概如此：\nbuild:    读入左子树信息;    if (左子树不是空指针)        build(左子树);    读入右子树信息;    if (右子树不是空指针)        build(右子树);\n然后开始对建好的树进行 DFSDFSDFS ，直到叶节点，可见这个操作遍历了树的一条链，遍历过程中，记录每个节点到根节点的点权的前缀和 sumsumsum ，及节点的深度 deepdeepdeep 。\n可知，所求的路径一定在某一条从根到叶节点的链上，而对于一条链上，我们只要找到两个节点 x,yx,yx,y ，使其满足：\ndeepx&lt;=deepydeep_x&lt;=deep_y\ndeepx​&lt;=deepy​\nsumy−sumxfather=K，xfather为x父节点sum_y-sum_{x_{father}}=K，x_{father}为 x 父节点\nsumy​−sumxfather​​=K，xfather​为x父节点\n则 x,yx,yx,y 之间的路径就是一条合法的路径，而求解时可先枚举确定 yyy ，然后求对应的 xxx ，这个过程可暴力枚举，时间复杂度 O(n2)O(n^2)O(n2) 。但该式子为一次函数，所以可以先将 sum,deepsum,deepsum,deep 排序（需要快排、归并等效率较高的排序），然后通过二分查找确定 xxx 以进行优化，优化后的时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn) ，再通过对程序细节处理上尽量提高效率，理论上可以稳定通过此题数据。\n对于题目中要求 &lt;font color=red&gt;“若存在多条满足条件的路径，则输出最短（包含结点个数最少）者，若存在多条最短的路径，则输出最靠右下者。”&lt;/font&gt;可在 DFSDFSDFS 顺序上进行修改，优先搜索右子树，同时在枚举 yyy 时，顺序从叶节点到根节点即可。\nDO:    Sort(sum,deep);   &#x2F;&#x2F;对sum和deep双关键字排序     For y&#x3D;n to 1 do     &#x2F;&#x2F;n为链上的节点个数，n是叶，1是根    &#123;        Find(x);        &#x2F;&#x2F;确定对应的x        Update(Ans);    &#x2F;&#x2F;更新答案    &#125;DFS:    if (该节点不是叶节点)    &#123;        DFS(右子树);        DFS(左子树);    &#125;    else        DO();\n T3 最小支撑树\n 问题描述\n给一个无向图，求最小生成树，注意图可能不连通。\n多组数据，每组数据的点数和边数都不超过 1.5×1031.5 \\times 10^31.5×103 。\n 题解\n最小生成树模板题，推荐 KruskalKruskalKruskal ，利用并查集判断图是否连通即可。\n","categories":["题解","吉林大学","数据结构课设"],"tags":["C++","KMP","二叉树"]},{"title":"Hexo_Kaze主题使用文档","url":"/2020/08/03/%E7%9F%A5%E8%AF%86/BLOG/Kaze/Hexo_Kaze%E4%B8%BB%E9%A2%98%E6%96%87%E6%A1%A3/","content":" 主题简介\nKaze是基于Hexo博客引擎的响应式主题，由 theme-kaze 开发维护\n 使用须知\n文档并不包含所有配置项，其他选项请参考主题配置和 Hexo文档，如有配置上的其他疑问可以在issue中提出\n 安装主题\n 直接通过npm/yarn安装\n在 Hexo 5.0 及以上版本中您可以直接通过输入\nnpm install hexo-theme-kaze\n直接安装主题\n 其他方式\n如果您有其他需要可以在 your site/themes 下输入\ngit clone https://github.com/theme-kaze/hexo-theme-Kaze.git\n或者下载主题压缩包在 your site/themes 下解压，并且将 hexo-theme-kaze 重命名为  kaze\n重命名为 kaze 是为了与通过 npm/yarn 下载保持一致性\n 持续升级\n在Hexo5.0及以上版本中您可以在站点根目录中新建 _config.kaze.yml 进行自定义配置，具体优先级参见相关文档\n在Hexo其他版本中您可以在站点目录 source 文件夹中新建 _data 文件夹并在期中新建 kaze_config.yml 复制主题配置文件的基本配置，然后就可以进行自定义配置，kaze-config.yml 设置优先于主题配置设置\n之后直接采取 git pull 或覆盖主题目录等方式便可直接升级无需替换配置\n请关注Release中的Breaking Changes会提示对配置造成不下兼容的改动 请自行更改\n 总体\n 多语言\n主题支持i18n国际化，目前支持英文与简体中文，有其他语言支持可提交PR。在站点配置文件中找到language即可修改语言 language: en 设置英文，language: zh-CN 设置简体中文\n 懒加载\n在主题配置选项 lazyload 中设置 enable: true 开启懒加载（默认开启）\nloadingImg 中可以设置加载图，可以在post中设置 banner_img_set 进行覆盖实现缩略图效果\n 文件压缩\n主题自带文件压缩，可以配合GZIP或其他优化手段提高网页访问速度，默认关闭，可以在\nminify:  enable: false  css: true  js: true  html: true\n中进行配置\n需要注意开启压缩后会影响 hexo g 的性能\n 主题颜色\n本主题中大部分颜色都可以在主题配置选项 color 中进行配置\n 字号与字体\n在主题配置选项 font 中可以设置 font-size 和 font-family\n og meta 元素\nOpen graph 是由facebook推出的技术，可以帮助您在各类支持该技术的社交媒体上显示网页卡片\nog:  enable: true  title: true  url: true  image: true  description: true  article: true\n\nenable 开启功能（默认开启）\ntitle… 请参见 &lt;a href=&quot;https://ogp.me&quot;&gt;官网文档 &lt;/a&gt;\n\n 静态资源\n主题大部分第三方资源索引都可以在主题配置选项 cdn 中进行配置，可以自定义其他资源路径\n 动画\n在主题配置文件中 animation config 调整主题动画效果，目前仅支持控制回到顶部动画的开关\n 图标\n主题图标依赖于 iconfont，内置了一部分社交图标，您可以自定义其他icon文件或者解决方案来添加自定义图标\n\n 站点访问量统计\n访问量统计目前仅支持不蒜子\nfooter:  statistics:    enable: false    type: busuanzi # now version only supports busuanzi    pv:      enable: true      style: 本站总访问量&#123;&#125;次 # the style will be shown as $1&#123;pv&#125;$2    uv:      enable: true      style: 本站总访客数&#123;&#125;次\nenable 开启访问量统计（默认关闭）\ntype  目前仅支持 busuanzi\npv 访问总量统计\nuv 用户总量统计\n 数据分析\nanalytics:  enable: false  type: google # google  google:    id: \nenable 开启分析支持（默认关闭）\ntype 目前仅支持 google\ngoogle.id 有关谷歌分析的具体使用说明和 id 使用可以参考谷歌文档\n 首页\n 文章头图\n在文章 Front-matter 中 banner_img 可以设置首页头图\n 小组件\nwidgets:  showWidgetsMobiles: &quot;none&quot;\nshowWidgetsMobiles : 在窄屏幕上是否显示小组件，none 关闭（默认），flex 开启\n 关于\n关于页面需要自行创建，在站点 source 中新建 about 文件夹并在文件夹内创建 index.md，该文件至少需要包含\n# at $&#123;yoursite&#125;/about/index.md---title: 关于layout: about---\n 社交链接\n在主题配置中\n# about page configabout:  description: description  social_links:    - &#123; icon: icon, link: your_links &#125;    - ...more\n在主题配置文件中按如上格式填写 social_links 即可创建社交链接，icon 相关可以参见图标\n 友链\n友链格式按如下填写即可生成友链页面\nlinks:  example-name-1:     url: https://example.com    avatar: https://example.com/avatar.jpg  example-name-2:     url: https://example.com    avatar: https://example.com/avatar.jpg\n 文章页\n 搜索功能\nsearch:  enable: true  path: search.json  field: posts  searchContent: true\n\nenable 开启搜索功能（默认开启）\npath 文件名称（暂无用处）\nfield 需要搜索的范围，支持 posts | pages | all\nsearchContent 搜索文件是否包含正文内容（不建议开启，包含所有文章内容这样会使得搜索文件异常巨大）替代方案是搜索分类标签或使用algolia等第三方搜索服务（Todo）\n\n 目录\n主题目录通过Hexo原生函数生成，具体可参见 文档\ntoc:  showListNumber: false  maxDepth: 6  minDepth: 1\nshowListNumber 是否生成编号\nmaxDepth TOC最大深度\nminDepth TOC最小深度\n 代码高亮\n参见代码 高亮文档\n 数学公式\n主题支持 mathjax 和 katex 两种渲染引擎，具体参见 相关文档\n copyright\ncopyright:  enable: true  writer: # if writer is empty we will use config.author as writer  declare: 本博客所有文章除特别声明外，均采用&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh&quot;&gt;CC BY-NC-SA 4.0 协议&lt;/a&gt;。转载请注明出处！  style: warning\nenable 开起版权说明（默认开启）\nwriter 作者id，如果不填则会使用主题配置 author或站点配置 author\ndeclare 版权声明具体内容，支持 html 语句\nstyle 声明内容样式，与 note 样式相同\n版权内容有三部分：作者、文章链接、版权声明\n作者使用 writer 参数，文章链接基于站点配置文件中 url参数生成，版权声明使用 declare 参数\n Front-matter\n banner_img\n设置文章与首页头图\n banner_img_set\n在图片加载时预先加载的图片，可以设置为 loading 图或缩略图等\n excerpt\n为文章设置在首页显示的简介，还可以通过 &lt;!--more--&gt; 来控制显示\n 评论\n支持 valine，gitalk 和 livere\n具体设置可参考主题配置文档说明和相关评论插件文档\n 字数统计\n主题集成 hexo-wordcount 插件，在主题配置文件中设置\nwordcount:  enable: true\n开启（默认开启）\n 图片画廊\n图片画廊功能基于 fslightbox，在主题配置文件中设置\nfslightbox:  enable: true\n开启（默认开启）\n 标签插件\n主题集成了一些标签方便书写\n note\n在 markdown 文件中如下书写即可\n&#123;% note style %&#125;...markdown content&#123;% endnote %&#125;\n有五种样式可以选择，primary，success，info，warning，danger\nprimary\nsuccess\ninfo\nwarning\ndanger\n 备案信息\n您可以在主题配置文件内增加您的备案信息。\nfooter:  #------------------------  # 备案配置  # 请将公安备案的缩略图置于 $&#123;yoursite&#125;/img/beian.png  RecordInfo: &quot;&quot; # &#x27;某ICP备xxx号&#x27;  govRecordInfo: &quot;&quot; # &#x27;某公网安备xxx号&#x27;  govRecordUrl: &quot;&quot; # 公网安备案信息地址  #------------------------","categories":["知识","BLOG","Kaze"],"tags":["Hexo","Kaze","BLOG"]},{"title":"代码高亮","url":"/2020/08/03/%E7%9F%A5%E8%AF%86/BLOG/Kaze/Kaze_highlight/","content":" 简介\n\n\n\n\n\n\n\n\n 高亮方案\n本主题没有使用自定义高亮方式，高亮方案在Hexo本身支持的 highlightjs 和 prismjs 基础上修改得到\n 使用highlightjs\nhighlight:  enable: true  line_number: false  auto_detect: false  tab_replace: &#x27;&#x27;  wrap: true  hljs: trueprismjs:  enable: false  ...\nhighlight 和 prismjs 的 enable: true 只能保留一个\n在站点配置文件将 highlight 设置 enable: true 即可开启，line_number 选项本主题暂不支持显示\n若需要支持代码高亮可设置 hljs: true，该配色方案参考了 tomorrow night 等配色主题\n其他具体参数设置可参考 Hexo相关文档 \n 使用prismjs\n在 prismjs 中设置 enable: true 和 preprocess: true 即可开启 默认支持 Line Numbers 和 Show Languages 两个插件 如果需要其他插件支持可以设置 preprocess: false\n当前主题版本不支持 preprocess: false 自动引入相关文件 如有相关需求请自行引入相关 css 与 js 文件\n设置 line_number: true 即可显示行号\n 演示\n以下演示采用 prism，highlight 在主题效果可参见（TODO）\n有八种高亮主题可选择\ndefault coy dark funky okaidia solarizedlight tomorrow twilight\n Javascript\nconst smoothScrollToTop = () =&gt; &#123;  let yTopValve = (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);  if (yTopValve &gt; 1) &#123;    window.requestAnimationFrame(smoothScrollToTop);    scrollTo(0, Math.floor(yTopValve * 0.85));  &#125; else &#123;    scrollTo(0, 0);  &#125;&#125;;setTimeout(() =&gt; &#123;  document.getElementById(&#x27;scrollbutton&#x27;).onclick = smoothScrollToTop;&#125;, 0);\n C++\n#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int maxn=1050;const int maxm=20000010;int h,n,v[maxn],w[maxn],f[maxm],maxx;int main()&#123;\tcin&gt;&gt;h&gt;&gt;n;\tmemset(f,0x3f,sizeof(f));\tf[0]=0;\tfor(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i],maxx=max(v[i],maxx);\tfor(int i=1;i&lt;=n;i++)\t&#123;\t\tfor(int j=v[i];j&lt;=h+maxx;j++)\t\t\tf[j]=min(f[j],f[j-v[i]]+w[i]);\t&#125;\tint ans=inf;\tfor(int i=h;i&lt;=h+maxx;i++) ans=min(ans,f[i]);\tcout&lt;&lt;ans&lt;&lt;endl;\treturn 0;&#125;\n PHP\n&lt;?phperror_reporting(0);if(!isset($_GET[&#x27;num&#x27;]))&#123;    show_source(__FILE__);&#125;else&#123;        $str = $_GET[&#x27;num&#x27;];        $blacklist = [&#x27; &#x27;, &#x27;\\t&#x27;, &#x27;\\r&#x27;, &#x27;\\n&#x27;,&#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;`&#x27;, &#x27;\\[&#x27;, &#x27;\\]&#x27;,&#x27;\\$&#x27;,&#x27;\\\\&#x27;,&#x27;\\^&#x27;];        foreach ($blacklist as $blackitem) &#123;                if (preg_match(&#x27;/&#x27; . $blackitem . &#x27;/m&#x27;, $str)) &#123;                        die(&quot;what are you want to do?&quot;);                &#125;        &#125;        eval(&#x27;echo &#x27;.$str.&#x27;;&#x27;);&#125;?&gt;\n JSON\n&#123;  &quot;name&quot;: &quot;hexo-theme-kaze&quot;,  &quot;description&quot;: &quot;hexo-theme-kaze&quot;,  &quot;author&quot;: &quot;theme-kaze&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/theme-kaze/hexo-theme-Kaze/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/theme-kaze/hexo-theme-Kaze#readme&quot;&#125;\n Python\nimport requestsimport reimport sysimport osurl = &#x27;https://twoshot.hgame.n3ko.co/&#x27;headers = &#123;    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;,    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;,&#125;p = requests.get(url+&#x27;random.php?times=228&#x27;, headers=headers)randnum = re.findall(r&#x27;\\d*&#x27;, p.text)[1:-2:2]firstnum = randnum[0]lastnum = randnum[227]content = os.popen(&quot;python3 ./reverse_mt_rand.py &quot; +                   firstnum+&#x27; &#x27;+lastnum+&#x27; 0 0&#x27;).read()q = requests.post(url+&#x27;/verify.php&#x27;, headers=headers, data=&#123;&#x27;ans&#x27;: content&#125;)print(q.text)\n Go\n// backup my secret key into DB_, err = db.Exec(fmt.Sprintf(`INSERT INTO secret(secret) VALUES(&#x27;%s&#x27;);`, secretKey))if err != nil &#123;    return err&#125;if u.TotalBalance &gt; 999999 || win &#123;    flag = os.Getenv(&quot;flag&quot;)&#125; else &#123;    flag = &quot;nothing to show, to be a winner&quot;&#125;\n\n  function changePrismTheme(e) {\n    let text = e.target.innerHTML;\n    let linkList = document.head.getElementsByTagName('link');\n    for(let item of linkList) {\n      if(item.dataset.prism) {\n        document.head.removeChild(item);\n      }\n    }\n    let link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.dataset.prism = text;\n    if(text === 'default') {\n      text = 'prism';\n    } else {\n      text = 'prism-' + text;\n    }\n    link.href='/js/lib/prism/' + text +'.min.css';\n    document.head.appendChild(link);\n  }\n  setTimeout(() => {\n    let buttonList = document.getElementsByClassName('postbutton');\n    Array.prototype.forEach.call(buttonList, item => {\n      item.onclick = changePrismTheme;\n    });\n  }, 0);\n\n","categories":["知识","BLOG","Kaze"],"tags":["Kaze","BLOG"]},{"title":"公式渲染","url":"/2020/07/27/%E7%9F%A5%E8%AF%86/BLOG/Kaze/Kaze_latex/","content":" 简介\n 启用公式\n本主题支持 mathjax 和 katex 两大渲染引擎，您可以在博客主题设置 latex 中  enable: true 启用。\n 更换渲染器\n由于Hexo本身渲染器的冲突，有一部分公式无法渲染，建议采用其他渲染器，首先\nnpm uninstall hexo-renderer-marked -S\n之后 mathjax推荐 hexo-renderer-kramed，katex推荐 hexo-renderer-markdown-it-plus\nnpm install hexo-renderer-kramed -Snpm install hexo-renderer-markdown-it-plus -S\n注意，您只可以保留一个渲染器\n 演示\n以下所有公式均通过 katex 渲染\n 整行公式\nf(a)=12πi∮f(z)z−adzf(a) = \\frac{1}{2\\pi i} \\oint\\frac{f(z)}{z-a}dz\nf(a)=2πi1​∮z−af(z)​dz\ncos⁡(θ+ϕ)=cos⁡(θ)cos⁡(ϕ)−sin⁡(θ)sin⁡(ϕ)\\cos(\\theta+\\phi)=\\cos(\\theta)\\cos(\\phi)−\\sin(\\theta)\\sin(\\phi)\ncos(θ+ϕ)=cos(θ)cos(ϕ)−sin(θ)sin(ϕ)\n∫D(∇⋅F)dV=∫∂DF⋅ndS\\int_D ({\\nabla\\cdot} F)dV=\\int_{\\partial D} F\\cdot ndS\n∫D​(∇⋅F)dV=∫∂D​F⋅ndS\n∇⃗×F⃗=(∂Fz∂y−∂Fy∂z)i+(∂Fx∂z−∂Fz∂x)j+(∂Fy∂x−∂Fx∂y)k\\vec{\\nabla} \\times \\vec{F} =\\left( \\frac{\\partial F_z}{\\partial y} - \\frac{\\partial F_y}{\\partial z} \\right) \\mathbf{i}+ \\left( \\frac{\\partial F_x}{\\partial z} - \\frac{\\partial F_z}{\\partial x} \\right) \\mathbf{j}+ \\left( \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y} \\right) \\mathbf{k}\n∇×F=(∂y∂Fz​​−∂z∂Fy​​)i+(∂z∂Fx​​−∂x∂Fz​​)j+(∂x∂Fy​​−∂y∂Fx​​)k\nσ=1N∑i=1N(xi−μ)2\\sigma = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N (x_i -\\mu)^2}\nσ=N1​i=1∑N​(xi​−μ)2​\n(∇XY)k=Xi(∇iY)k=Xi(∂Yk∂xi+ΓimkYm)(\\nabla_X Y)^k = X^i (\\nabla_i Y)^k =X^i \\left( \\frac{\\partial Y^k}{\\partial x^i} + \\Gamma_{im}^k Y^m \\right)\n(∇X​Y)k=Xi(∇i​Y)k=Xi(∂xi∂Yk​+Γimk​Ym)\ndet(JG)=∂xd+1∂zd+1∂xd+2∂zd+2...∂xD∂zD=βd+1βd+2...βDdet(J_G) =\\frac{\\partial{x_{d+1}}}{\\partial{z_{d+1}}}\\frac{\\partial{x_{d+2}}}{\\partial{z_{d+2}}}...\\frac{\\partial{x_D}}{\\partial{z_D}} \\\\\n=β_{d+1}β_{d+2}...β_{D}\ndet(JG​)=∂zd+1​∂xd+1​​∂zd+2​∂xd+2​​...∂zD​∂xD​​=βd+1​βd+2​...βD​\n 行内公式\n求根公式是x=−b±b2−4ac2ax = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}x=2a−b±b2−4ac​​\nE=mc2E=mc^2E=mc2是质能方程式\n对于一个序列a1,a2,⋯ ,ama_1,a_2,\\cdots,a_ma1​,a2​,⋯,am​，有a1+a2+⋯+am=2⋅(a1⊕a2⊕⋯⊕am)a_1+a_2+\\cdots+a_m=2\\cdot(a_1\\oplus a_2\\oplus\\cdots\\oplus a_m)a1​+a2​+⋯+am​=2⋅(a1​⊕a2​⊕⋯⊕am​)\n","categories":["知识","BLOG","Kaze"],"tags":["Kaze","BLOG"]},{"title":"STL-快速排序","url":"/2020/05/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/STL-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","content":" 一、快速排序\n Ⅰ. 格式\nsort(arr+m,arr+n,cmp);\n将数组 $ arr $ 中下标为 $ m $ 的元素到下标为 $ n-1 $ 的元素，按照定义的函数 $ cmp $ 中的规则排序。\n Ⅱ. 排序规则\nint cmp(const int &amp;a,const int &amp;b)&#123;    return a&gt;b;&#125;\n如上的排序规则为从大到小排序，当 $ a=b $ 时应返回 $ 0 $ 。可以对结构体排序。\n必须包含头文件 algorithm\\color{red} {algorithm}algorithm 。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"文件操作","url":"/2020/03/27/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/","content":" 一、重定向型\n格式：\nFILE *freopen(const char *filename, const char *mode, FILE *stream );freopen(&quot;pro.in&quot;,&quot;r&quot;,stdin);freopen(&quot;pro.out&quot;,&quot;w&quot;,stdout);fclose(stdin);fclose(stdout);\n$ filename $ 要打开的文件名\n$ mode $ 文件打开的模式，和 $ fopen $ 中的模式（ $ r/w $ ）相同\n$ stream $ 文件指针，通常使用标准流文件（ $ stdin/stdout/stderr $ ）\n其中 $ stdin $ 是标准输入流，默认为键盘；$ stdout $ 是标准输出流，默认为屏幕；$ stderr $ 是标准错误流，一般把屏幕设为默认。通过调用 $ freopen $ ，就可以修改标准流文件的默认值，实现重定向。\n使用 $ freopen() $ 函数的优点：\n我们不再需要修改 $ scanf $ ，$ printf $ ，$ cin $ 和 $ cout $ 。而是维持代码的原样就可以了。因为 $ freopen() $ 函数重定向了标准流，使其指向前面指定的文件，省时省力。最后只要使用 $ fclose $ 关闭输入文件和输出文件即可。\n需调用头文件 $ \\color{red} {cstdio} $ 。\n 二、$ fopen $ 型\n格式：\n#include &lt;cstdio&gt;#include &lt;iostream&gt;using namespace std;int a, b, c;char s[20];FILE *fin, *fout;int main()&#123;    fin &#x3D; fopen(&quot;pro.in&quot;, &quot;rb&quot;);    fout &#x3D; fopen(&quot;pro.out&quot;, &quot;wb&quot;);    fscanf(fin, &quot;%d %d&quot;, &amp;a, &amp;b);    scanf(&quot;%d&quot;, &amp;c);    fprintf(fout, &quot;%d&quot;, a + b + c);    printf(&quot;%d&quot;, a * b * c);    return 0;&#125;pro.in输入：  1 2终端输入：    4pro.out输出： 7终端输出：    8\n$ fopen $ 对 $ scanf,printf $ 适用。\n先声明变量 $ fin $ 和 $ fout $ ，把 $ scanf $ 改成 $ fscanf $ ，第一个参数为 $ fin $ ；把 $ printf $ 改成 $ fprintf $ ，第一个参数为 $ fout $ ，最后执行 $ fclose $ ，关闭两个文件。\n 三、文件输入输出流\n格式：\n#include &lt;fstream&gt;using namespace std;int a, b, c;char s[20];int main()&#123;    ifstream fin(&quot;pro.in&quot;);    ofstream fout(&quot;pro.out&quot;);    fin &gt;&gt; a &gt;&gt; b;    fout &lt;&lt; a + b;    return 0;&#125;\n若想用fin作为输入对象，fout作为输出对象，则可以使用如下定义：\nifstream  fin(&quot;输入文件名.扩展名&quot;);ofstream  fout(&quot;输出文件名.扩展名&quot;);\n如果想再次使用cin和cout，只需要把fin和fout的声明语句去掉，并加上这样两行即可：\n#define fin cin#define fout cout","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-函数","url":"/2020/02/23/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%87%BD%E6%95%B0/","content":" 一、函数\n Ⅰ. 定义\n定义方式：\n数据类型 函数名(形参)&#123;    函数体；&#125;int add(int a,int b)&#123;    return a+b;&#125;\n\n函数的数据类型是函数的返回值类型，若类型为 voidvoidvoid 则无返回值。\n形参可以是空的，但圆括号必须存在。\n\n Ⅱ. 函数的声明\n方式：\n数据类型 函数名(形参);int add(int a,int b);   &#x2F;&#x2F;或者int add(int,int);\n若函数在调用之前定义，则无需声明。\n Ⅲ. 函数的调用\n ① 传值调用\n方式：\nint x, y;void swap(int a, int b)&#123;    int t;    t &#x3D; a, a &#x3D; b, b &#x3D; t;    return;&#125;int main()&#123;    x &#x3D; 1, y &#x3D; 2;    swap(x, y);    printf(&quot;%d %d&quot;, x, y);    return 0;&#125;输出：1 2\n传值调用时，将全局变量 x,yx,yx,y 的值赋予局部变量 a,ba,ba,b ，虽函数内交换了 a,ba,ba,b 的值但 x,yx,yx,y 的值并未被影响。\n ② 传址调用\n方式：\nint x, y;void swap(int &amp;a, int &amp;b)&#123;    int t;    t &#x3D; a, a &#x3D; b, b &#x3D; t;    return;&#125;int main()&#123;    x &#x3D; 1, y &#x3D; 2;    swap(x, y);    printf(&quot;%d %d&quot;, x, y);    return 0;&#125;输出：2 1\n与①中相比，函数的形参变成了指针，此时传入局部变量 a,ba,ba,b 的是全局变量 x,yx,yx,y 的内存地址，进行交换时直接对内存地址里的内容造成影响，相当于交换 x,yx,yx,y 的值。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-字符串","url":"/2020/02/20/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%AD%97%E7%AC%A6%E4%B8%B2/","content":" 一、字符数组\n字符数组定义格式同一般数组，但数组类型使字符型。\n字符数组的初始化：\nchar s1[5]&#x3D;&#123;&#39;a&#39;,&#39;b,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;&#125;;    &#x2F;&#x2F;存单个字符char s2[6]&#x3D;&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;\\0&#39;&#125;;  &#x2F;&#x2F;存字符串，注意虽然只有五个字符，但数组要开到6，因为第六位要存结束符\\0char s[3][4]&#x3D;&#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;&#125;;   &#x2F;&#x2F;用字符串给二维字符数组初始化，相当于存了三个字符串分别于s[0],s[1],s[2]中\n当初始化的元素个数少于数组总个数时，其余位数为空字符。\n字符数组中也可以存放若干个字符，也可以来存放字符串。两者的区别是字符串有一结束符( \\0 )。反过来说，在一维字符数组中存放着带有结束符的若干个字符称为字符串。字符串是一维数组，但是一维字符数组不等于字符串。\n 二、字符与字符串的区别\n\n两者的定界符不同，字符常量由单引号括起来，字符串常量由双引号括起来。\n字符常量只能是单个字符，字符串常量则可以是多个字符。\n可以把一个字符常量赋给一个字符变量，但不能把一个字符串常量赋给一个字符变量。\n字符常量占一个字节，而字符串常量占用字节数等于字符串的字节数加 $ 1 $ 。增加的一个字节中存放字符串结束标志 ‘\\0’ 。例如：字符常量 ‘a’ 占一个字节，字符串常量 “a” 占二个字节。\n\n 三、字符串输入与输出\n Ⅰ. 输入\n ① 使用 $ scanf $ 读入：\nscanf(&quot;%s&quot;,s1);scanf(&quot;%s%s%s&quot;,s1,s2,s3);输入：a b c结果：s1&#x3D;&#39;a&#39;    s2&#x3D;&#39;b&#39;     s3&#x3D;&#39;c&#39;scanf(&quot;%s&quot;,s1);输入：a b c结果：s1&#x3D;&#39;a&#39;    s2&#x3D;&#39;&#39;      s3&#x3D;&#39;&#39;\n\n这里的字符串名称之前不加 ‘&amp;’ 这个取地址符。\n系统会自动在输入的字符串常量后添加 ‘\\0’ 标志，因此输入时，仅输入字符串的内容即可。\n输入多个字符串时，以空格分隔。如果仅有一个输入字符串名称的情况下，字符串变量仅获取空格前的内容。\n\n ② 使用 $ gets $ 读入：\ngets(s1);   &#x2F;&#x2F;不能gets(s1,s2);\n\n使用 $ gets $ 只能输入一个字符串。\n使用 $ gets $ ，是从光标开始的地方读到换行符也就是说读入的是一整行，而使用 $ scanf $ 是从光标开始的地方到空格，如果这一行没有空格，才读到行尾。\n\n Ⅱ. 输出\n ① 使用 $ printf $ 输出：\nprintf(&quot;$s&quot;,s1);\n\n用 ‘%s’ 格式输出时，$ printf $ 的输出项只能是字符串(字符数组)名称，而不能是数组元素。\n输出字符串不包括字符串结束标志符 ‘\\0’ 。\n\n ② 使用 $ puts $ 输出：\nputs(s1);   &#x2F;&#x2F;和scanf(&quot;%s\\n&quot;,s1);等价\n 四、字符串处理函数\n\n\n\n函数类型\n作用\n\n\n\n\n$ strcat(str1,str2) $\n将$ str2 $ 接到 $ str1 $ 之后，结果返回 $ str1 $\n\n\n$ strncat(str1,str2,n) $\n将$ str2 $ 的前 $ n $ 个字符接到 $ str1 $ 之后，结果返回 $ str1 $\n\n\n$ strcpy(str1,str2) $\n将$ str2 $ 赋值给 $ str1 $ ，结果返回 $ str1 $\n\n\n$ strncpy(str1,str2,n) $\n将$ str2 $ 的前 $ n $ 个字符赋值给 $ str1 $ ，结果返回 $ str1 $\n\n\n$ strcmp(str1,str2) $\n比较$ str1 $ 和 $ str2 $ 的大小，结果（ $ -1,0,1 $ ）返回函数本身\n\n\n$ strncmp(str1,str2,n) $\n比较$ str1 $ 和 $ str2 $ 前 $ n $ 个字符的大小，结果（ $ -1,0,1 $ ）返回函数本身\n\n\n$ strlen(str) $\n计算$ str $ 的长度，终止符 $ \\text{\\0} $ 不算在长度之内，结果返回函数本身\n\n\n$ strlwr(str) $\n将$ str $ 中的字母全部换为小写\n\n\n$ strupr(str) $\n将$ str $ 中的字母全部换为大写\n\n\n\n使用以上函数，必须包含头文件 $ \\color{red} {cstring} $ 。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-数组","url":"/2020/02/16/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E6%95%B0%E7%BB%84/","content":" 一、一维数组\n Ⅰ. 一维数组的定义和使用\n定义：\n数据类型 数组名[常量表达式];int a[100];int b[10*5];\na[10]a[10]a[10] 表示数组 aaa 中有 101010 个元素，分别是 a0,⋯ ,a9a_0 , \\cdots , a_9a0​,⋯,a9​ ，注意没有 a10a_{10}a10​ 。\n数组引用：\n数组名[常量表达式]a[1]b[i++]c[i+j]\nC++C++C++ 中直能引用数组元素，不能引用整个数组。\n Ⅱ. 一维数组的操作\n初始化：\n变量类型 数组名[常量表达式]&#x3D;&#123;值1,值2,...&#125;;int a[5]&#x3D;&#123;1,2,3,4,5&#125;;int b[10]&#x3D;&#123;1,2,3&#125;;   &#x2F;&#x2F;此时对前三个元素初始化成括号内的值，其余元素初始化为0int c[5]&#x3D;&#123;&#125;;    &#x2F;&#x2F;将所有元素初始化为0\n赋值:\nmemcpy(b,a,(变量类型)*k);   &#x2F;&#x2F;从数组a中复制k个元素到数组bmemcpy(b,a,sizeof(a));  &#x2F;&#x2F;将数组a整个复制到数组bmemset(a,0,sizeof(a));  &#x2F;&#x2F;将数组a中每个元素都赋值为0\n和 PascalPascalPascal 不同，在 C++C++C++ 中数组不能进行赋值操作。使用以上操作时需包含头文件 cstring\\color{red} {cstring}cstring 。\n 二、多维数组\n定义：\n变量类型 数组名[常量表达式1][常量表达式2]...[常量表达式n];int a[5][5];int b[10][5][5];\n二维数组初始化：\n变量类型 数组名[常量表达式1][常量表达式2]&#x3D;&#123;值,...&#125;;int a[2][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-循环结构","url":"/2020/01/15/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/","content":" 一、$ for $ 语句\n使用方式：\nfor (循环变量初值;条件表达式;增值表达式)&#123;    语句1；    语句2；    ...&#125;for (i&#x3D;0;i&lt;&#x3D;5;i++)\nfor语句的执行过程可由以下 $ 4 $ 步来描述。\n①执行“控制变量初始化语句”，使控制变量获得一个初值。\n②判断控制变量是否满足“条件表达式”，若满足条件则执行一遍循环体，否则结束整个for语句，继续执行 $ for $ 循环下面的句子。\n③根据增量表达式，计算出控制变量所得到的新值\n④自动转到第②步。\n可以在 $ for $ 循环“循环变量初值”中声明变量，这些变量只在 $ for $ 循环结构中有效，离开了该 $ for $ 结构，变量就无效了。如：\nfor (int i&#x3D;0;i&lt;&#x3D;5;i++)\n 二、$ while $ 语句\n使用方式：\nwhile (条件表达式)&#123;    语句1；    语句2；    ......&#125;\n先判断条件表达式，若条件表达式为真，则执行循环体，否则跳出循环体。\n 三、$ do-while $ 语句\n使用方式：\ndo&#123;    语句1；    语句2；    ......&#125;while (条件表达式)\n先执行循环体，再判断条件表达式，若条件表达式为真，则再次执行循环体，否则跳出循环体。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-选择结构","url":"/2019/12/21/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84/","content":" 一、$ if $ 选择结构\n Ⅰ. $ if $ 语句\n使用方式：\nif (条件表达式) &#123;执行内容&#125;if (a&lt;&#x3D;10) &#123;a++;&#125;\n当 $ \\color{red}{条件表达式} $ 成立时，$ \\color{red}{执行内容} $ 才会被执行，否则会被跳过。\n Ⅱ. $ else $ 语句\n使用方式：\nif (条件表达式) &#123;执行内容1&#125;else &#123;执行内容2&#125;if (a&lt;&#x3D;10) &#123;a++;&#125;else &#123;a--;&#125;\n当 $ \\color{red}{条件表达式} $ 成立时，$ \\color{red}{执行内容1} $ 会被执行，否则 $ \\color{red}{执行内容2} $ 会被执行。\n和 $ Pascal $ 相同，$ C++ $ 中 $ if $ 也可以嵌套。\n Ⅲ. 三目运算符 $ ?: $\n使用方式：\n变量&#x3D;条件表达式?值1:值2;a&#x3D;3&#x3D;&#x3D;9?1:2;结果：a&#x3D;2\n当 $ \\color{red}{条件表达式} $ 成立时，变量为 $ \\color{red}{值1} $ ，否则变量为 $ \\color{red}{值2} $ 。\n 二、$ switch $ 选择结构\n使用方式：\nswitch (表达式)&#123;case 常量表达式1:     执行内容1;     break;case 常量表达式2:     执行内容2;     break;case 常量表达式3:     执行内容3;     break;......default:     执行内容n;&#125;a&#x3D;1;switch (a)    &#123;    case 2:        printf(&quot;b&quot;);    case 1:        printf(&quot;a&quot;);    &#125;输出：aa&#x3D;1;switch (a)    &#123;    case 1:        printf(&quot;a&quot;);    case 2:        printf(&quot;b&quot;);    &#125;输出：ab\n$ switch $ 语句执行过程分为以下 $ 3 $ 步：\n①计算出 $ switch $ 后面圆括号内表达式的值，假定为 $ M $ ，若它不是整型，系统将自动舍去其小数部分，只取其整数部分作为结果值。\n②依次计算出每个 $ case $ 后常量表达式的值，假定它们为 $ M_1,M_2,\\cdots $ ，同样若它们的值不是整型，则自动转换为整型。\n③让 $ M $ 依次同 $ M_1,M_2,\\cdots $ 进行比较，一旦遇到 $ M $ 与某个值相等，则就从对应标号的语句开始执行；在碰不到相等的情况下，若存在 $ default $ 语句，则就执行其冒号后面的语句序列，否则不执行任何操作；当执行到复合语句最后的右花括号时就结束整个 $ switch $ 语句的执行。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-顺序结构","url":"/2019/12/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84/","content":" 一、常量和变量\n Ⅰ. 常量\n 定义：\nconst 常量类型 常量符号&#x3D;常量；const int a&#x3D;100;\n 类型：\n① 整形常量：\n十进制：$ 100_{(10)},-1_{(10)} $\n八进制：以 $ 0 $ 开头，后由 $ 0 \\backsim 7 $ 的字符构成。如 $ 012 $ 表示 $ 12_{(8)} $\n十六进制：以 $ 0x $ 开头，后由 $ 0 \\backsim F $ 的字符构成。如 $ 0xF1A $ 表示 $ F1A_{(16)} $ 。\n② 实型常量：\n实型有两种写法，其一是直接写出数值，如 $ 1.3,-0.18 $ ，第二种使用科学计数法表示，如：\nM E XM \\ E \\ X\nM E X\n其中 $ M $ 为一个实数， $ X $ 为一个整数。\n其意味着：\nM×10XM \\times 10^X\nM×10X\n1.52 E 2=1.52×102=1521.52 \\ E \\ 2=1.52 \\times 10^2 =152\n1.52 E 2=1.52×102=152\n152 E −2=152×10−2=1.52152 \\ E \\ -2=152 \\times 10^{-2}=1.52\n152 E −2=152×10−2=1.52\n③ 字符型常量：\n如‘a’、‘1’、‘?’，注意 &lt;font color='red'&gt;‘’&lt;/font&gt;不能省去，且‘a’表示一个 &lt;font color='red'&gt;字符 &lt;/font&gt;，“a”表示一个 &lt;font color='red'&gt;字符串 &lt;/font&gt;。\n Ⅱ. 变量\n 定义：\n变量类型 变量名，变量名，......；int a,b;char s,k;float n,m;\n和 $ Pascal $ 中不同， $ C++ $ 可以在定义时给变量赋值，如：\nint a&#x3D;100;char s&#x3D;&#39;x&#39;;float n&#x3D;5E2;\n 变量类型：\n变量的类型可以是标准数据类型（$ int,long \\ long,char,float,double,\\cdots $），也可以是用户自定义的类型（结构体）。\n 二、标准数据类型\n这些数据类型都是由系统定义的简单数据类型。\n Ⅰ. 整形\n\n\n\n数据类型\n$ C++ $ 定义标识符\n$ Pascal $ 定义标识符\n占字节数\n取值范围\n\n\n\n\n短整型\n$ short $\n$ integer $\n$ 2 $\n$ [-2{15},2{15}-1] $\n\n\n无符号短整型\n$ unsigned \\ short $\n$ word $\n$ 2 $\n$ [0,2^{16}-1] $\n\n\n长整型\n$ long $\n$ longint $\n$ 4 $\n$ [-2{31},2{31}-1] $\n\n\n无符号长整形\n$ unsigned \\ long $\n$ dword $\n$ 4 $\n$ [0,2^{32}-1] $\n\n\n超长整形\n$ long \\ long $\n$ int64 $\n$ 8 $\n$ [-2{63},2{63}-1] $\n\n\n无符号超长整形\n$ unsigned \\ long \\ long $\n$ qword $\n$ 8 $\n$ [0,2^{64}-1] $\n\n\n\n Ⅱ. 实型\n\n\n\n数据类型\n$ C++ $ 定义标识符\n$ Pascal $ 定义标识符\n占字节数\n取值范围\n有效位数\n\n\n\n\n单精度实型\n$ float $\n$ real $\n$ 4 $\n$ [-3.4E+38,3.4E+38] $\n$ 6 $\n\n\n双精度实型\n$ double $\n$ double $\n$ 8 $\n$ [-1.7E+308,1.7E+308] $\n$ 15 $\n\n\n长双精度实型\n$ long \\ double $\n$ extended $\n$ 16 $\n$ [-3.4E+4932,1.1E+4932] $\n$ 18 $\n\n\n布尔型\n$ bool $\n$ boolean $\n$ 1 $\n$ true,false $\n$ \\diagdown $\n\n\n\n Ⅲ. 字符型\n见 $ ASCLL $ 码表。\n\n Ⅳ. 强制类型转换\n(类型名)(表达式)(int)(4.7)&#x3D;4;\n 三、输入与输出\n Ⅰ. 字符输入输出\n函数：$ getchar(),putchar() $\n使用此函数必须包含头文件 &lt;font color='red'&gt;cstdio &lt;/font&gt;。\n使用方式：\n字符型变量&#x3D;getchar();putchar(字符型变量&#x2F;ASCLL码);char s;s&#x3D;getchar();putchar(s);putchar(66);输入：Z输出：ZB\n$ getchar() $ 输入的所有元素都按字符处理，且可以 &lt;font color='red'&gt;读入回车 &lt;/font&gt;。\n Ⅱ. 流输入输出\n函数：$ cin,cout,endl $\n使用此函数必须包含头文件 &lt;font color='red'&gt;iostream &lt;/font&gt;，且需使用 &lt;font color='red'&gt;using namespace std;&lt;/font&gt;。\n使用方式：\ncin&gt;&gt;变量；cout&lt;&lt;变量&#x2F;字符串；cin&gt;&gt;a&gt;&gt;b;cout&lt;&lt;&quot;a&#x3D;&quot;&lt;&lt;a&lt;&lt;&quot;\\nb&#x3D;&quot;&lt;&lt;b&lt;&lt;endl;cout&lt;&lt;&quot;A&quot;;输入：1 A输出：a&#x3D;1b&#x3D;AA\n Ⅲ. 格式化输入输出\n函数：$ scanf,printf $\n使用此函数必须包含头文件 &lt;font color=&quot;red&quot;&gt;cstdio &lt;/font&gt;。\n使用方法：\nscanf(&quot;格式符 格式符&quot;,&amp;变量,&amp;变量);printf(&quot;格式符 格式符&quot;,变量,变量);scanf(&quot;%d%c&quot;,&amp;a,&amp;b);printf(&quot;a&#x3D;%d\\nb&#x3D;%c\\nA&quot;,a,b);输入：1A输出：a&#x3D;1b&#x3D;AA\n$ scanf $ 中的 &lt;font color=&quot;green&quot;&gt;&amp;变量 &lt;/font&gt;是变量的内存地址，可以是变量地址，也可以是字符串首地址。\n 输入格式符：\n\n\n\n符号\n说明\n\n\n\n\n$ d $\n输入十进制整数\n\n\n$ u $\n以无符号形式输入十进制整数\n\n\n$ o $\n输入八进制整数\n\n\n$ x $\n输入十六进制整数\n\n\n$ c $\n输入单个字符\n\n\n$ s $\n输入字符串\n\n\n$ f $\n输入实数\n\n\n\n\n\n\n附加格式\n说明\n\n\n\n\n$ l $\n输入长整型数（$ ld,lo,lx $）和 $ double $ 型实数（$ lf $）\n\n\n$ h $\n输入短整型数（$ hd,ho,hx $）\n\n\n域宽（一个整数）\n指定输入所占列宽\n\n\n$ * $\n表示对应输入值不赋给变量\n\n\n\n 输出格式符\n\n\n\n符号\n说明\n\n\n\n\n$ d $\n输出十进制整数\n\n\n$ u $\n以无符号形式输出十进制整数\n\n\n$ o $\n输出八进制整数\n\n\n$ x $\n输出十六进制整数\n\n\n$ c $\n输出单个字符\n\n\n$ s $\n输出字符串\n\n\n$ f $\n以小数形式输出实数\n\n\n$ e $\n以科学记数法形式输出实数\n\n\n\n\n\n\n参数\n说明\n\n\n\n\n$ m $\n指定宽度，实际宽度不足$ m $ 时补空格，大于 $ m $ 时按实际宽度输出\n\n\n$ .n $\n不对整形使用，对于实型表示保留$ n $ 位小数，对于字符串表示最多含有 $ n $ 个字符\n\n\n$ - $\n表示左对齐\n\n\n$ l $\n输出长整型\n\n\n$ 0 $\n跟$ m $ 一起使用，表示宽度不足 $ m $ 时补 $ 0 $\n\n\n\n使用格式：$ %,-,0,m,.n,l $\nscanf(&quot;%2d%3d%4d&quot;,&amp;a,&amp;b,&amp;c);scanf(&quot;%f&quot;,&amp;d);scanf(&quot;%5s&quot;,&amp;s);printf(&quot;a&#x3D;%d\\nb&#x3D;%d\\nc&#x3D;%d\\nd&#x3D;%.5f\\ns&#x3D;%7.3s\\n&quot;,a,b,c,d,s);输入：123456789512E-2abcdefg输出：a&#x3D;12b&#x3D;345c&#x3D;6789d&#x3D;5.12000s&#x3D;    abc\n 四、运算符与表达式\n Ⅰ. 赋值语句\n变量&#x3D;表达式;a&#x3D;10*19;a&#x3D;b&#x3D;c&#x3D;d&#x3D;100;\n Ⅱ. 算术运算符\n\n\n\n类型\n运算符\n\n\n\n\n加\n$ + $\n\n\n减\n$ - $\n\n\n乘\n$ * $\n\n\n除\n$ / $\n\n\n取模\n$ % $\n\n\n\n表达式+表达式表达式-表达式表达式*表达式表达式&#x2F;表达式表达式%表达式1+1&#x3D;2;1-1&#x3D;0;1*2&#x3D;2;5&#x2F;2&#x3D;2;5.0&#x2F;2&#x3D;2.5;5&#x2F;2.0&#x3D;2.5;5%2&#x3D;1;\n$ a++ $ 表示调用 $ a $ 后将 $ a+1 $ 。\n$ ++a $ 表示将 $ a+1 $ 后再调用 $ a $ 。（减法相同）\n Ⅲ. 关系运算符\n\n\n\n类型\n运算符\n\n\n\n\n大于\n$ &gt; $\n\n\n小于\n$ &lt; $\n\n\n等于\n$ == $\n\n\n大于等于\n$ &gt;= $\n\n\n小于等于\n$ &lt;= $\n\n\n不等于\n$ != $\n\n\n\n关系运算符的结果只能是 $ 0(false) $ 或 $ 1(true) $ 。\n Ⅳ. 逻辑运算符\n\n\n\n类型\n运算符\n\n\n\n\n与\n$ &amp;&amp; $\n\n\n或\n$\n\n\n非\n$ ! $\n\n\n\n与运算符(&amp;&amp;)和或运算符(||)均为双目运算符，具有左结合性。 非运算符(!)为单目运算符，具有右结合性。\n逻辑运算符的结果只能是 $ 0(false) $ 或 $ 1(true) $ 。\n Ⅴ. 位运算符\n\n\n\n类型\n运算符\n\n\n\n\n按位与\n$ &amp; $\n\n\n按位或\n$\n\n\n按位异或\n$ \\land $\n\n\n取反\n$ \\sim $\n\n\n左移\n$ &lt;&lt; $\n\n\n右移\n$ &gt;&gt; $\n\n\n\n Ⅵ. 运算表达式简写\n变量&#x3D;变量 运算符 表达式变量 运算符&#x3D;表达式a&#x3D;a+2;a+&#x3D;2;\n Ⅶ. 常用运算函数\n\n\n\n类型\n函数\n\n\n\n\n绝对值\n$ abs(x) $\n\n\n自然数指数$ e^x $\n$ exp(x) $\n\n\n下取整\n$ floor(x) $\n\n\n上取整\n$ ceil(x) $\n\n\n自然数对数$ \\ln{x} $\n$ log(x) $\n\n\n指数函数$ x^t $\n$ pow(x,t) $\n\n\n随机函数（在$ [0,x-1] $ 生成随机数）\n$ rand(x) $\n\n\n平方根\n$ sqrt(x) $\n\n\n\n使用这类函数时，必须包含头文件 &lt;font color=&quot;red&quot;&gt;cmath &lt;/font&gt;。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"写出第一个C++程序","url":"/2019/11/18/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95-%E5%86%99%E5%87%BA%E7%AC%AC%E4%B8%80%E4%B8%AAC++%E7%A8%8B%E5%BA%8F/","content":"$ Pascal $ 作为我参加信息学竞赛使用的语言，伴随我走过了多年的时光，但随着计算机语言的发展，它已经逐渐被淘汰。我也必须跟上步伐，学习现在普遍使用的高级语言 $ C++ $ 。\n\n 第一个程序 $ Hello \\ World $\n#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;    return 0;&#125;\n这可以算作是一个模板的 $ C++ $ 程序，首先要写出使用的头文件，之后是主函数（main），主函数在程序中一定最先开始执行。主函数如果正常结束就会返回 $ 0 $ ，否则会返回其他的值。\n 头文件\n使用 $ C++ $ 编写程序和 $ Pascal $ 还是有很大的不同的，最为主要的就是 $ C++ $ 中的 &lt;font color='red'&gt;头文件 &lt;/font&gt;，这些是调用 $ C++ $ 函数库的必须手段。\n其使用方式为：\n#include &lt;头文件名称&gt;\n 这里先总结一些常用的头文件：\n Ⅰ. $ iostream $ :\n包括函数：$ cin,cout,endl $\n注意：该头文件没有定义全局命名空间，必须使用 $ using \\ namespace \\ std; $\n Ⅱ. $cstdio $ :\n包括函数：$ getchar,putchar,scanf,printf,freopen $\n Ⅲ. $ cstring $ :\n包括函数：$ memset $\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"长沙集训-2019-08-21","url":"/2019/08/21/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD-2019-08-21/","content":" &lt;center&gt;长沙集训 $ Day 3 $ 2019-08-21 &lt;/center&gt;\n 得分：$ 193/300 $\n\n T1 $ Matrix $\n\n 基本思路\n此题可以用枚举解决，分别枚举每一列作为矩形中间点统计答案，最后取最大值。每次统计答案时，分别算出每一列相邻的 $ 1 $ 的个数 $ sum $：\n\n之后从该列向两边查找（其实只向一边也可以），如果当前枚举的列为 $ k $ ，查找到的列为 $ i $ ，则答案为 $ |i-j| \\cdot sum[i] $ 。\n直接暴力查找的时间复杂度时 $ O(n \\cdot m^2) $ ，为了加快速度，可以预处理出以 $ i $ 为中心的每行连续 $ 1 $ 的左右端点，之后计算 $ sum $ 时用前缀和处理。使时间复杂度降低为 $ O(n \\cdot m) $ 。\n 程序\nprogram matrix;type tp&#x3D;record  l,r:longint;end;var   f:array[0..1005,0..1005]of tp;   a:array[0..1005,0..1005]of integer;   sum:array[0..1005]of longint;   n,m:longint;function max(a,b:longint):longint;begin  if a&gt;b then exit(a)    else exit(b);end;procedure re;var i,j:longint;    s:ansistring;begin  for i:&#x3D;1 to n do begin    readln(s);    for j:&#x3D;1 to m do      if s[j]&#x3D;&#39;0&#39; then a[i,j]:&#x3D;0        else a[i,j]:&#x3D;1;  end;end;procedure first;var i,j,loc:longint;    t:boolean;begin  for i:&#x3D;1 to n do begin    loc:&#x3D;1;    t:&#x3D;false;    for j:&#x3D;1 to m do      if a[i,j]&lt;&gt;0 then begin        if t&#x3D;true then begin          f[i,j].l:&#x3D;f[i,j-1].l;          f[i,j].r:&#x3D;f[i,j-1].r;        end          else begin            while a[i,loc]&lt;&gt;0 do inc(loc);            t:&#x3D;true;            f[i,j].l:&#x3D;j;            f[i,j].r:&#x3D;loc;          end;      end        else begin          t:&#x3D;false;          inc(loc);        end;  end;end;function ans(x:longint):longint;var i,t:longint;begin  fillchar(sum,sizeof(sum),0);  for i:&#x3D;1 to n do    if a[i,x]&#x3D;1 then begin      inc(sum[f[i,x].l]);      dec(sum[f[i,x].r]);    end;  for i:&#x3D;1 to n do    sum[i]:&#x3D;sum[i]+sum[i-1];  ans:&#x3D;0;  t:&#x3D;0;  for i:&#x3D;x+1 to n do    if sum[i]&#x3D;sum[i-1] then inc(t)      else break;  for i:&#x3D;x downto 1 do begin    inc(t);    ans:&#x3D;max(ans,sum[i]*t);  end;  t:&#x3D;0;  for i:&#x3D;x-1 downto 1 do    if sum[i]&#x3D;sum[i+1] then inc(t)      else break;  for i:&#x3D;x to n do begin    inc(t);    ans:&#x3D;max(ans,sum[i]*t);  end;end;procedure main;var i,j,anss:longint;begin  anss:&#x3D;0;  for i:&#x3D;1 to m do     anss:&#x3D;max(anss,ans(i));  writeln(anss);end;begin  readln(n,m);  re;  first;  main;end.\n T2 $ Present $\n\n 基本思路\n刚看到题面，第一反应：“这不是背包板子吗！”。看到数据范围：“。。。”。\n这三天的 $ T2 $ 都异常巧妙，昨天考了最小生成树，今天的 $ T2 $ 则是一个最短路径。从原题上完全看不出和图论的联系，但是却能根据题目的特点进行转化：\n假设所有的物品中，价值最小为 $ p_{min} $ 。如果一个值 $ W = \\sum_{i=1}^n p_i \\cdot k_i $ 可以被组成，那么 $ W = \\sum_{i=1}^n p_i \\cdot (k_i + p_{min} \\cdot s_i) $ 也一定能被组成。\n可以借此降低背包的上界，将最大容量从 $ 4 \\times 10^7 $ 降为 $ p_{min} \\cdot \\sum_{i=1}^n p_i $ ，时间复杂度为 $ O(n \\cdot p_{min} \\cdot \\sum_{i=1}^n p_i ) $ 。可以通过 $ 60 $% 的数据。\n接下来，解决方法就非常巧妙了。由上可知，对于每一个询问 $ Q = C + p_{min} \\cdot k $ ，只要判断 $ Q \\mod p_{min} $ 能否被组成即可。所以我们只要知道能够被组成的数 $ K(K \\mod p_{min} = C) $ ，的最小值是否小于 $ Q $ 即可。而解决这个问题，可以将 $ [0,p_{min}-1] $ 的每个数当成一个点，对于点 $ f $ ，将其向 $ (f + p_i) \\mod p_{min} $ 的点连一条权值为 $ p_i $ 的无向边，最后算出从 $ 0 $ 到 $ i $ 的最短路便是 $ K(K \\mod p_{min} = i) $ 的最小值。\n 程序\nprogram present;var   dis:array[0..10005]of longint;   a:array[0..505]of longint;   n,m,w:longint;function min(a,b:longint):longint;begin  if a&lt;b then exit(a)    else exit(b);end;procedure re;var i:longint;begin  w:&#x3D;maxint;  for i:&#x3D;1 to n do begin    read(a[i]);    w:&#x3D;min(w,a[i]);  end;end;procedure spfa;var i,head,tail,f,v:longint;    p:array[0..10005]of longint;    tf:array[0..10005]of boolean;begin  fillchar(dis,sizeof(dis),$3f);  fillchar(tf,sizeof(tf),0);  dis[0]:&#x3D;0;  head:&#x3D;0;  tail:&#x3D;1;  p[tail]:&#x3D;0;  tf[0]:&#x3D;true;  while head&lt;tail do begin    inc(head);    head:&#x3D;head mod 10000;    f:&#x3D;p[head];    for i:&#x3D;1 to n do begin      v:&#x3D;(f+a[i]) mod w;      if (a[i]&lt;&gt;w) and (dis[f]+a[i]&lt;dis[v]) then begin        dis[v]:&#x3D;dis[f]+a[i];        if tf[v]&#x3D;false then begin          inc(tail);          tail:&#x3D;tail mod 10000;          p[tail]:&#x3D;v;          tf[v]:&#x3D;true;        end;      end;    end;    tf[f]:&#x3D;false;  end;end;procedure main;var i,ans,x:longint;begin  spfa;  ans:&#x3D;0;  for i:&#x3D;1 to m do begin    read(x);    if dis[x mod w]&lt;&#x3D;x then inc(ans);  end;  writeln(ans);end;begin  read(n,m);  re;  main;end.\n T3 $ Mahjong $\n\n\n 基本思路\n这是三天中最水的 $ T3 $ ，没有任何算法，就是按照题意模拟和枚举。主意好细节就可以，注意要先确定雀头，再查找顺子和刻子。对特殊牌型先行处理。\n这题说明了看题是多重要，我没看到“字牌不能成顺子”，结果 $ 100 \\to 63 $ 。\n 程序\nprogram mahjong;type arr&#x3D;array[1..15]of longint;type tp&#x3D;record  a:longint;  b:char;end;var   m,s,p,c:arr;   ans:array[0..105]of tp;   t:longint;procedure re;var ss:string;    i,t:longint;begin  readln(ss);  i:&#x3D;1;  while i&lt;&#x3D;length(ss) do begin    val(ss[i],t);    case ss[i+1] of      &#39;m&#39;:inc(m[t]);      &#39;s&#39;:inc(s[t]);      &#39;p&#39;:inc(p[t]);      &#39;c&#39;:inc(c[t]);    end;    inc(i,3);  end;end;function sc(m,s,p,c:arr):boolean;var i,sum:longint;begin  &#x2F;&#x2F;找刻子和顺子  sum:&#x3D;0;  for i:&#x3D;1 to 9 do    if m[i]&gt;0 then begin      if m[i]&lt;3 then while (m[i]&gt;0) and (m[i+1]&gt;0) and (m[i+2]&gt;0) do begin        inc(sum);        dec(m[i]);        dec(m[i+1]);        dec(m[i+2]);      end;      if m[i]&gt;&#x3D;3 then begin        inc(sum);        dec(m[i],3);      end;      while (m[i]&gt;0) and (m[i+1]&gt;0) and (m[i+2]&gt;0) do begin        inc(sum);        dec(m[i]);        dec(m[i+1]);        dec(m[i+2]);      end;    end;  for i:&#x3D;1 to 9 do    if s[i]&gt;0 then begin      if s[i]&lt;3 then while (s[i]&gt;0) and (s[i+1]&gt;0) and (s[i+2]&gt;0) do begin        inc(sum);        dec(s[i]);        dec(s[i+1]);        dec(s[i+2]);      end;      if s[i]&gt;&#x3D;3 then begin        inc(sum);        dec(s[i],3);      end;      while (s[i]&gt;0) and (s[i+1]&gt;0) and (s[i+2]&gt;0) do begin        inc(sum);        dec(s[i]);        dec(s[i+1]);        dec(s[i+2]);      end;    end;  for i:&#x3D;1 to 9 do    if p[i]&gt;0 then begin      if p[i]&lt;3 then while (p[i]&gt;0) and (p[i+1]&gt;0) and (p[i+2]&gt;0) do begin        inc(sum);        dec(p[i]);        dec(p[i+1]);        dec(p[i+2]);      end;      if p[i]&gt;&#x3D;3 then begin        inc(sum);        dec(p[i],3);      end;      while (p[i]&gt;0) and (p[i+1]&gt;0) and (p[i+2]&gt;0) do begin        inc(sum);        dec(p[i]);        dec(p[i+1]);        dec(p[i+2]);      end;    end;  for i:&#x3D;1 to 9 do    if c[i]&gt;&#x3D;3 then begin      inc(sum);      dec(c[i],3);    end;  if sum&lt;4 then exit(false)    else exit(true);  &#x2F;&#x2F;end;function check(m,s,p,c:arr):boolean;var i,sum:longint;    tf:boolean;begin  &#x2F;&#x2F;七对子  sum:&#x3D;0;  for i:&#x3D;1 to 9 do    if m[i]&gt;&#x3D;2 then inc(sum);  for i:&#x3D;1 to 9 do    if s[i]&gt;&#x3D;2 then inc(sum);  for i:&#x3D;1 to 9 do    if p[i]&gt;&#x3D;2 then inc(sum);  for i:&#x3D;1 to 9 do    if c[i]&gt;&#x3D;2 then inc(sum);  if sum&#x3D;7 then exit(true);  if sum&#x3D;0 then exit(false);  &#x2F;&#x2F;  &#x2F;&#x2F;国士无双  tf:&#x3D;true;  for i:&#x3D;2 to 8 do    if m[i]&lt;&gt;0 then tf:&#x3D;false;  for i:&#x3D;2 to 8 do    if s[i]&lt;&gt;0 then tf:&#x3D;false;  for i:&#x3D;2 to 8 do    if p[i]&lt;&gt;0 then tf:&#x3D;false;  for i:&#x3D;1 to 7 do    if c[i]&#x3D;0 then tf:&#x3D;false;  if (tf&#x3D;true) and (m[1]&gt;0) and (m[9]&gt;0) and (s[1]&gt;0) and (s[9]&gt;0) and (p[1]&gt;0) and (p[9]&gt;0) then exit(true);  &#x2F;&#x2F;  &#x2F;&#x2F;找对子  for i:&#x3D;1 to 9 do    if m[i]&gt;&#x3D;2 then begin      dec(m[i],2);      if sc(m,s,p,c)&#x3D;true then exit(true);      inc(m[i],2);    end;  for i:&#x3D;1 to 9 do    if s[i]&gt;&#x3D;2 then begin      dec(s[i],2);      if sc(m,s,p,c)&#x3D;true then exit(true);      inc(s[i],2);    end;  for i:&#x3D;1 to 9 do    if p[i]&gt;&#x3D;2 then begin      dec(p[i],2);      if sc(m,s,p,c)&#x3D;true then exit(true);      inc(p[i],2);    end;  for i:&#x3D;1 to 7 do    if c[i]&gt;&#x3D;2 then begin      dec(c[i],2);      if sc(m,s,p,c)&#x3D;true then exit(true);      inc(c[i],2);    end;  &#x2F;&#x2F;  exit(false);end;procedure main;var i,t:longint;begin  t:&#x3D;0;  for i:&#x3D;1 to 9 do    if m[i]+1&lt;5 then begin      inc(m[i]);      if check(m,s,p,c)&#x3D;true then begin        inc(t);        ans[t].a:&#x3D;i;        ans[t].b:&#x3D;&#39;m&#39;;      end;      dec(m[i]);    end;  for i:&#x3D;1 to 9 do    if s[i]+1&lt;5 then begin      inc(s[i]);      if check(m,s,p,c)&#x3D;true then begin        inc(t);        ans[t].a:&#x3D;i;        ans[t].b:&#x3D;&#39;s&#39;;      end;      dec(s[i]);    end;  for i:&#x3D;1 to 9 do    if p[i]+1&lt;5 then begin      inc(p[i]);      if check(m,s,p,c)&#x3D;true then begin        inc(t);        ans[t].a:&#x3D;i;        ans[t].b:&#x3D;&#39;p&#39;;      end;      dec(p[i]);    end;  for i:&#x3D;1 to 7 do    if c[i]+1&lt;5 then begin      inc(c[i]);      if check(m,s,p,c)&#x3D;true then begin        inc(t);        ans[t].a:&#x3D;i;        ans[t].b:&#x3D;&#39;c&#39;;      end;      dec(c[i]);    end;  if t&#x3D;0 then writeln(&#39;Nooten&#39;)    else begin      write(t,&#39; &#39;);      for i:&#x3D;1 to t do        write(ans[i].a,ans[i].b,&#39; &#39;);      writeln;    end;end;begin  readln(t);  while t&gt;0 do begin    fillchar(m,sizeof(m),0);    fillchar(s,sizeof(s),0);    fillchar(p,sizeof(p),0);    fillchar(c,sizeof(c),0);    dec(t);    re;    main;  end;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训-2019-08-20","url":"/2019/08/20/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD-2019-08-20/","content":" 长沙集训 $ Day 2 $ 2019-08-20\n 得分： $ 105/300 $\n\n T1 $ mine $\n\n 基本思路\n此题可以使用 $ Dp $ 解决，设 $ Dp[i,j,k] $ 表示当前处理到第 $ i $ 位，第 $ i $ 位字符为 $ j $ 类型，第 $ i-1 $ 为符号为 $ k $ 类型时的方案数。\n$ s_i=* \\   \\to \\   j,k=1 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ 0 \\ \\to \\ j,k=2 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ 1 \\ \\to \\ j,k=3 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ 2 \\ \\to \\ j,k=4 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ ? \\ \\to \\ j,k=0 $\n状态可从 $ Dp[i-1,k,l] $ 转移得到，其中要注意各种细节问题。\n 程序\nprogram mine;const p&#x3D;1000000007;var   s:array[0..1000005]of longint;   f:array[0..1000005,1..4,1..4]of longint;   n:longint;function min(a,b:longint):longint;begin  if a&lt;b then exit(a)    else exit(b);end;procedure re;var s1:ansistring;    i:longint;begin  readln(s1);  s1:&#x3D;s1;  n:&#x3D;length(s1);  for i:&#x3D;1 to n do    case s1[i] of      &#39;*&#39;:s[i]:&#x3D;1;      &#39;0&#39;:s[i]:&#x3D;2;      &#39;1&#39;:s[i]:&#x3D;3;      &#39;2&#39;:s[i]:&#x3D;4;      &#39;?&#39;:s[i]:&#x3D;0;    end;end;procedure main;var i,j,k:longint;    ans:int64;begin  ans:&#x3D;0;  if s[1]&#x3D;0 then begin    f[1,1,1]:&#x3D;1;    f[1,2,2]:&#x3D;1;    f[1,3,2]:&#x3D;1;  end    else if s[1]&#x3D;1 then f[1,1,1]:&#x3D;1      else if s[1]&#x3D;2 then f[1,2,2]:&#x3D;1        else if s[1]&#x3D;3 then f[1,3,2]:&#x3D;1;  for i:&#x3D;2 to n do    for j:&#x3D;1 to 4 do      for k:&#x3D;1 to 4 do        if ((s[i]&#x3D;j) or (s[i]&#x3D;0)) and ((s[i-1]&#x3D;k) or (s[i-1]&#x3D;0)) then begin          if (j&#x3D;1) and (k&#x3D;1) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]+f[i-1,k,3]+f[i-1,k,4]) mod p;          if (j&#x3D;1) and (k&#x3D;3) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,2]+f[i-1,k,3]+f[i-1,k,4]) mod p;          if (j&#x3D;1) and (k&#x3D;4) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]) mod p;          if (j&#x3D;2) and (k&#x3D;2) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,2]+f[i-1,k,3]+f[i-1,k,4]) mod p;          if (j&#x3D;2) and (k&#x3D;3) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]) mod p;          if (j&#x3D;3) and (k&#x3D;1) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]+f[i-1,k,3]+f[i-1,k,4]) mod p;          if (j&#x3D;3) and (k&#x3D;2) and (i&lt;&gt;n) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,2]+f[i-1,k,3]+f[i-1,k,4]) mod p;          if (j&#x3D;3) and (k&#x3D;3) and (i&lt;&gt;n) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]) mod p;          if (j&#x3D;4) and (k&#x3D;1) and (i&lt;&gt;n) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]+f[i-1,k,3]+f[i-1,k,4]) mod p;        end;  for i:&#x3D;1 to 4 do    for j:&#x3D;1 to 4 do      ans:&#x3D;(ans+f[n,i,j]) mod p;  writeln(ans);end;begin  re;  main;end.\n T2 $ water $\n\n\n 基本思路\n这题是一道十分奇妙的图论题。首先考虑一个点的积水深度如何计算，假设这个点开始时有无限的水深，这些多出来的水肯定会沿着一某些路径流走，随着水深不断下降，显然当水深到达所有路径中最大点高度的最小值时，余下的水就无法流走了，这时的水深就是答案。\n现在的问题就是如何找出这个最小值。要求出最小值，首先要找到这条路径，所有点的路径是一棵瓶颈生成树。\n 瓶颈生成树：无向图 $ G $ 的一颗瓶颈生成树是这样的一颗生成树，它最大的边权值在G的所有生成树中是最小的。\n无向图 $ G $ 的最小生成树一定是瓶颈生成树（逆命题不成立），因为如果最小生成树不是瓶颈生成树，则最小生成树中一定有一条边可以被更换为更小的权值，不满足最小生成树的性质。\n对于此题，将一个点与其上下左右四个点之间连边，边权为两个顶点高度的较大值。对于四周的点，还要将它们向一个 $ 0 $ 号节点连边，边权为 $ 0 $ 和点的高度中的较大值。之后在建成的图上求出最小生成树，就可以求出水流的所有路径。\n之后以 $ 0 $ 节点为生成树的根，通过 $ DFS $ 处理答案，其中 $ i $ 节点的水深为从 $ i $ 到根的路径上，边权的最大值减去节点 $ i $ 的高度。\n 程序\nprogram water;const x:array[1..4]of longint&#x3D;(1,0,-1,0);      y:array[1..4]of longint&#x3D;(0,1,0,-1);type tp&#x3D;record  x,y,w:longint;end;type tp2&#x3D;record  l,v,w:longint;end;var   map,ans:array[0..305,0..305]of longint;   fa,r,maxx:array[0..1000005]of longint;   e:array[0..200005]of tp2;   a:array[0..500005]of tp;   n,m,tot,i:longint;function max(a,b:longint):longint;begin  if a&gt;b then exit(a)    else exit(b);end;procedure build(x,y,z:longint);begin  inc(i);  e[i].l:&#x3D;r[x];  r[x]:&#x3D;i;  e[i].v:&#x3D;y;  e[i].w:&#x3D;z;  inc(i);  e[i].l:&#x3D;r[y];  r[y]:&#x3D;i;  e[i].v:&#x3D;x;  e[i].w:&#x3D;z;end;procedure qsort(l,r:longint);var i,j,mid:longint;    t:tp;begin  i:&#x3D;l;  j:&#x3D;r;  mid:&#x3D;a[(i+j) shr 1].w;  repeat    while a[i].w&lt;mid do inc(i);    while a[j].w&gt;mid do dec(j);    if i&lt;&#x3D;j then begin      t:&#x3D;a[i];      a[i]:&#x3D;a[j];      a[j]:&#x3D;t;      inc(i);      dec(j);    end;  until i&gt;j;  if i&lt;r then qsort(i,r);  if l&lt;j then qsort(l,j);end;function find(q:longint):longint;begin  if fa[q]&#x3D;q then exit(q);  fa[q]:&#x3D;find(fa[q]);  exit(fa[q]);end;procedure re;var i,j:longint;begin  for i:&#x3D;1 to n do    for j:&#x3D;1 to m do      read(map[i,j]);end;procedure dfs(f,fa:longint);var i,x,y:longint;begin  x:&#x3D;(f-1) div m;  y:&#x3D;f-x*m;  ans[x,y]:&#x3D;maxx[f]-map[x,y];  i:&#x3D;r[f];  while i&lt;&gt;0 do begin    if e[i].v&lt;&gt;fa then begin      maxx[e[i].v]:&#x3D;max(maxx[f],max(maxx[e[i].v],e[i].w));      dfs(e[i].v,f);    end;    i:&#x3D;e[i].l;  end;end;procedure main;var i,j,k:longint;begin  for i:&#x3D;1 to n do    for j:&#x3D;1 to m do      for k:&#x3D;1 to 4 do begin        inc(tot);        a[tot].x:&#x3D;(i)*m+j;        a[tot].y:&#x3D;(i+x[k])*m+j+y[k];        if (i+x[k]&lt;1) or (j+y[k]&lt;1) or (i+x[k]&gt;n) or (j+y[k]&gt;m) then a[tot].y:&#x3D;1;        a[tot].w:&#x3D;max(map[i,j],map[i+x[k],j+y[k]]);      end;  qsort(1,tot);  for i:&#x3D;1 to 2*n*m do begin    maxx[i]:&#x3D;-maxint;    fa[i]:&#x3D;i;  end;  for i:&#x3D;1 to tot do  begin      if find(a[i].x)&lt;&gt;find(a[i].y) then begin      fa[find(a[i].x)]:&#x3D;find(a[i].y);      build(a[i].x,a[i].y,a[i].w);    end;  end;  dfs(1,1);  for i:&#x3D;1 to n do begin    for j:&#x3D;1 to m do      write(ans[i,j],&#39; &#39;);    writeln;  end;end;begin  read(n,m);  re;  main;end.\n T3 $ gcd $\n\n\n 基本思路\n咕\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训-2019-08-19","url":"/2019/08/19/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD-2019-08-19/","content":" 长沙集训 $ Day 1 $ 2019-08-19\n 得分： $ 70 / 300 $\n\n T1梦境\n\n\n 基本思路\n此题是一个基本的贪心，将区间升序排序后，对于每个转折点，将包括该点的所有区间右端点放入小根堆中，取堆顶元素进行匹配后删除即可。\n 程序\nprogram dream;type tp&#x3D;record  l,r:longint;end;var   a:array[0..200005]of tp;   b,heap:array[0..200005]of longint;   n,m,tot:longint;procedure qsort1(l,r:longint);var i,j,mid:longint;    t:tp;begin  i:&#x3D;l;  j:&#x3D;r;  mid:&#x3D;a[(i+j) shr 1].l;  repeat    while a[i].l&lt;mid do inc(i);    while a[j].l&gt;mid do dec(j);    if i&lt;&#x3D;j then begin      t:&#x3D;a[i];      a[i]:&#x3D;a[j];      a[j]:&#x3D;t;      inc(i);      dec(j);    end;  until i&gt;j;  if l&lt;j then qsort1(l,j);  if i&lt;r then qsort1(i,r);end;procedure qsort2(l,r:longint);var i,j,mid,t:longint;begin  i:&#x3D;l;  j:&#x3D;r;  mid:&#x3D;b[(i+j) shr 1];  repeat    while b[i]&lt;mid do inc(i);    while b[j]&gt;mid do dec(j);    if i&lt;&#x3D;j then begin      t:&#x3D;b[i];      b[i]:&#x3D;b[j];      b[j]:&#x3D;t;      inc(i);      dec(j);    end;  until i&gt;j;  if l&lt;j then qsort2(l,j);  if i&lt;r then qsort2(i,r);end;procedure insert(q:longint);var i,j,t:longint;begin  inc(tot);  i:&#x3D;tot;  heap[tot]:&#x3D;q;  while (i shr 1)&lt;&gt;0 do begin    j:&#x3D;i shr 1;    if heap[j]&gt;heap[i] then begin      t:&#x3D;heap[j];      heap[j]:&#x3D;heap[i];      heap[i]:&#x3D;t;    end      else exit;    i:&#x3D;j;  end;end;procedure del;var i,j,t:longint;begin  heap[1]:&#x3D;heap[tot];  heap[tot]:&#x3D;2000000000;  dec(tot);  i:&#x3D;1;  while (i shl 1)&lt;&#x3D;tot do begin    j:&#x3D;i shl 1;    if (j+1&lt;&#x3D;tot) and (heap[j+1]&lt;heap[j]) then inc(j);    if heap[i]&gt;heap[j] then begin      t:&#x3D;heap[i];      heap[i]:&#x3D;heap[j];      heap[j]:&#x3D;t;    end      else exit;    i:&#x3D;j;  end;end;procedure re;var i:longint;begin  for i:&#x3D;1 to n do    read(a[i].l,a[i].r);  for i:&#x3D;1 to m do    read(b[i]);  qsort1(1,n);  qsort2(1,m);end;procedure main;var i,j:longint;    ans:int64;begin  for i:&#x3D;1 to 200005 do heap[i]:&#x3D;2000000000;  tot:&#x3D;0;  j:&#x3D;1;  ans:&#x3D;0;  for i:&#x3D;1 to m do begin    while (a[j].l&lt;&#x3D;b[i]) and (j&lt;&#x3D;n) do begin      insert(a[j].r);      inc(j);    end;    while heap[1]&lt;b[i] do del;    if heap[1]&lt;&gt;2000000000 then begin      inc(ans);      del;    end;  end;  writeln(ans);end;begin  read(n,m);  re;  main;end.\n T2玩具\n\n\n 基本思路\n本题可以转化为，有一棵树，开始时只有一个根节点，之后有 $ n-1 $ 次操作，每次会将一个新的节点等概率的连接到一个已有的节点上，问操作完成后树的期望深度。\n显然的概率 $ Dp $ ，假设已放入 $ i $ 个节点后，形成的森林中深度最大的子树中有 $ j $ 个节点。用 $ Dp[i,j] $ 记录其概率，则该状态只可能由两种情况扩展得到，分别是 $ Dp[i-1,j] $ 和 $ Dp[i-1,j-1] $ ，可得转移方程：\nDp[i,j]=Dp[i−1,j−1]⋅j−1i+Dp[i−1,j]⋅i−jiDp[i,j]=Dp[i-1,j-1] \\cdot \\frac{j-1}{i} + Dp[i-1,j] \\cdot \\frac{i-j}{i}\nDp[i,j]=Dp[i−1,j−1]⋅ij−1​+Dp[i−1,j]⋅ii−j​\nDp[1,1]=1Dp[1,1]=1\nDp[1,1]=1\n用 $ f[i,j] $ 记录树中节点个数为 $ i $ 时，树的深度不超过 $ j $ 的概率， $ g[i,j] $ 记录节点个数为 $ i $ 的森林中，深度最深的子树深度不超过 $ j $ 的概率。可得状态转移方程：\ng[i,j]=∑k=1if[k,j]⋅g[i−k,j]⋅Dp[i,k]g[i,j]=\\sum_{k=1}^{i} f[k,j] \\cdot g[i-k,j] \\cdot Dp[i,k]\ng[i,j]=k=1∑i​f[k,j]⋅g[i−k,j]⋅Dp[i,k]\nf[i,j]=g[i−1,j−1],j&gt;0f[i,j]=g[i-1,j-1] , j&gt;0\nf[i,j]=g[i−1,j−1],j&gt;0\ng[0,i]=1,i∈[0,n]g[0,i]=1 , i \\in [0,n]\ng[0,i]=1,i∈[0,n]\nf[1,0]=1f[1,0]=1\nf[1,0]=1\nf[i,0]=0,i∈[2,n]f[i,0]=0 , i \\in [2,n]\nf[i,0]=0,i∈[2,n]\n则树的深度为 $ i $ 的概率可用 $ f[n,i]-f[n,i-1] $ 得到。\n 程序\nprogram toy;var   dp:array[0..205,0..205]of longint;   n,p:longint;procedure first;var i,j:longint;    f:array[0..1005]of int64;begin  f[0]:&#x3D;0;  f[1]:&#x3D;1;  for i:&#x3D;2 to 1000 do    f[i]:&#x3D;p-(p div i)*f[p mod i] mod p;  dp[1,1]:&#x3D;1;  for i:&#x3D;2 to n do    for j:&#x3D;1 to i do      dp[i,j]:&#x3D;(dp[i-1,j-1]mod p*(j-1)mod p*f[i]mod p+dp[i-1,j]mod p*(i-j)mod p*f[i]mod p) mod p;end;procedure main;var i,j,k,ans:longint;    f,g:array[0..205,0..205]of longint;begin  fillchar(f,sizeof(f),0);  fillchar(g,sizeof(g),0);  for i:&#x3D;0 to n do    g[0,i]:&#x3D;1;  for i:&#x3D;1 to n do    for j:&#x3D;0 to n do begin      if j&#x3D;0 then begin        if i&#x3D;1 then f[i,j]:&#x3D;1          else f[i,j]:&#x3D;0;      end        else f[i,j]:&#x3D;g[i-1,j-1];      for k:&#x3D;1 to i do        g[i,j]:&#x3D;(g[i,j]+f[k,j] mod p*g[i-k,j] mod p*dp[i,k] mod p) mod p;    end;  ans:&#x3D;0;  for i:&#x3D;1 to n do    ans:&#x3D;(ans+(f[n,i]-f[n,i-1])*i) mod p;  if ans&lt;0 then inc(ans,p);  writeln(ans);end;begin  read(n,p);  first;  main;end.\n T3飘雪圣域\n\n\n 基本思路\n这题看上去像是在树上找连通块，其实和树根本没啥关系。容易想到，在 $ k $ 个节点中，只要两个节点之间连边，则连通块就会减少 $ 1 $ 个，所以我们只要知道区间内节点之间连边的数量，就可以算出连通块个数。\n为了维护边的条数，可以将询问离线，将所有询问区间左端点升序排序，并将所有边按小顶点升序排序。之后用树状数组维护区间内边的条数，首先将所有边的大顶点放入树状数组，之后按照区间进行枚举，对于每一个区间，将小顶点小于区间左端点的边的大顶点从树状数组中删去，之后计算答案（$ l-r+1-边数 $)。\n 程序\nprogram icekingdom;type tp&#x3D;record  l,r:longint;end;type tp2&#x3D;record  l,r,num:longint;end;var   e:array[0..200005]of tp;   f:array[0..200005]of tp2;   tree,ans:array[0..200005]of longint;   n,q:longint;procedure qsort1(l,r:longint);var i,j,mid:longint;    t:tp;begin  i:&#x3D;l;  j:&#x3D;r;  mid:&#x3D;e[(i+j) shr 1].l;  repeat    while e[i].l&lt;mid do inc(i);    while e[j].l&gt;mid do dec(j);    if i&lt;&#x3D;j then begin      t:&#x3D;e[i];      e[i]:&#x3D;e[j];      e[j]:&#x3D;t;      inc(i);      dec(j);    end;  until i&gt;j;  if i&lt;r then qsort1(i,r);  if l&lt;j then qsort1(l,j);end;procedure qsort2(l,r:longint);var i,j,mid:longint;    t:tp2;begin  i:&#x3D;l;  j:&#x3D;r;  mid:&#x3D;f[(i+j) shr 1].l;  repeat    while f[i].l&lt;mid do inc(i);    while f[j].l&gt;mid do dec(j);    if i&lt;&#x3D;j then begin      t:&#x3D;f[i];      f[i]:&#x3D;f[j];      f[j]:&#x3D;t;      inc(i);      dec(j);    end;  until i&gt;j;  if i&lt;r then qsort2(i,r);  if l&lt;j then qsort2(l,j);end;procedure re;var i,x,y:longint;begin  for i:&#x3D;1 to n-1 do begin    read(x,y);    if x&gt;y then begin      e[i].l:&#x3D;y;      e[i].r:&#x3D;x;    end      else begin        e[i].l:&#x3D;x;        e[i].r:&#x3D;y;      end;  end;  for i:&#x3D;1 to q do begin    read(f[i].l,f[i].r);    f[i].num:&#x3D;i;  end;  qsort1(1,n-1);  qsort2(1,q);end;function low(q:longint):longint;begin  exit(q and -q);end;procedure add(x,q:longint);begin  while x&lt;&#x3D;n do begin    inc(tree[x],q);    inc(x,low(x));  end;end;function sum(x:longint):longint;begin  sum:&#x3D;0;  while x&gt;&#x3D;1 do begin    inc(sum,tree[x]);    dec(x,low(x));  end;end;procedure main;var i,j:longint;begin  for i:&#x3D;1 to n-1 do    add(e[i].r,1);  j:&#x3D;1;  for i:&#x3D;1 to q do begin    while (j&lt;n) and (e[j].l&lt;f[i].l) do begin      add(e[j].r,-1);      inc(j);    end;    ans[f[i].num]:&#x3D;f[i].r-f[i].l+1-sum(f[i].r)-sum(f[i].l);  end;  for i:&#x3D;1 to q do    writeln(ans[i]);end;begin  read(n,q);  re;  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day10","url":"/2019/02/24/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay10/","content":" 2019.2.20\n 长沙集训 $ Day 10 $\n昨天已经对网络流最大流有所了解，并且已经能够使用几种基本算法解题。虽然 $ Dinic $ 算法可以解决大部分问题，但如果遇到 $ n,m $ 较大的情况，还是需要更为优秀的算法。\n\n 网络最大流（加强版）：\n相较于普通版的最大流，本题的 $ n $ 有所减小，但 $ m $ 却增加了 $ 20000 $ ，并且出题人显然制作了针对普通 $ Dinic $ 的数据，所以我们需要更为快速的算法。\n $ ISAP $ 算法\n$ ISAP $ 算法是对普通 $ Dinic $ 的进一步优化，该算法先进行一次 $ BFS $ ，找出各节点到 $ T $ 的深度，之后在进行 $ DFS $ 搜索增广路径更新流量，同时更新深度，如果出现断层就结束算法。\n更新节点深度：如果后续节点传回该节点的消耗总流量比当前节点可用流量上限小，即 $ flow_n&lt;dis $ ,则该节点在此高度已无法做出贡献，就将该节点的高度提高 $ 1 $ 。\n断层：如果某一深度（该深度小于 $ n $ ）没有节点，则视为出现断层，此时残量网络中已不存在增广路，结束算法。\n$ ISAP $ 算法的优点是只需运行一边 $ BFS $ ,无需为网络图重新分层，所以能极大加快处理速度。\n $ HLPP $ 算法\n实际上 $ ISAP $ 仍无法通过这道毒瘤题，我们看到了题目中所写的“预流推进”。我们之前所说的算法都是基于增广路进行扩展，而预流推进则类似手动模拟网络流的方式，先将所有的流量尽可能推给后续节点，如果流量超额，再通过反向网络推回。但直接这样进行推进可能会出现两个节点将流量互相-i推给对方，直到 $ TLE $ 为止。所以我们需要给每个节点标号，标号为 $ h_i $ 的节点只能将流量推给标号 $ h_i-1 $ 的节点，当一个节点存在超额流无法推出，就将其标号设为与其相连结点的最小标号+ $ 1 $ ,并将其压入队列，队列为空时结束算法。\n为了加快速度，我们一般先从 $ T $ 开始进行一遍 $ BFS $ ,对节点进行预标号。同时如果处理过程中发现 $ h_i $ 的标号没有节点，那么此时标号比 $ h_i $ 高的节点就全部无法做出贡献，将它们的标号设为 $ n+1 $ 。\n以上是普通预流推进算法，而 $ HLPP $ 中最高标号的意思就是：每次从队列中取出标号最高的节点进行处理，这样做的时间复杂度接近 $ O(n^{2} \\cdot \\sqrt m) $ ，在 $ n $ 较小而 $ m $ 很大时有很高的效率。\n 各种算法的时间复杂度\n虽然 $ HLPP $ 的理论时间复杂度比 $ Dinic $ 低，但因为 $ Dinic $ 处理随机图时的复杂度远低于上限，而 $ HLPP $ 的复杂度基本都在最高复杂度附近，所以在数据较小时 $ HLPP $ 与 $ Dinic $ 的速度并无太大差别。\n\n $ HLPP $ 程序\nprogram project1;type tp=record  h,pos:longint;end;const max_n=1205;      max_m=120005;      max_int=1061109567;var   flow:array[0..2*max_n]of int64;   r,h,num:array[0..2*max_n]of longint;   tf:array[0..max_n]of boolean;   l,v,w:array[0..2*max_m]of longint;   heap:array[0..2*max_n]of longint;   n,m,s,t,tot:longint;function min(a,b:longint):longint;begin  if a&lt;b then exit(a) else exit(b);end;function search(q:longint):longint;begin  if q mod 2=0 then exit(q-1)    else exit(q+1);end;procedure re;var i:longint;    t,x,y,z:int64;begin  t:=0;  for i:=1 to m do begin    read(x,y,z);    inc(t);    l[t]:=r[x];    r[x]:=t;    v[t]:=y;    w[t]:=z;    inc(t);    l[t]:=r[y];    r[y]:=t;    v[t]:=x;    w[t]:=0;  end;end;procedure insert(pos:longint);var i,j:longint;    t:longint;begin  inc(tot);  heap[tot]:=pos;  i:=tot;  while (i shr 1)&lt;&gt;0 do begin    j:=i shr 1;    if h[heap[i]]&gt;h[heap[j]] then begin      t:=heap[i];      heap[i]:=heap[j];      heap[j]:=t;    end      else break;    i:=j;  end;end;procedure del;var i,j:longint;    t:longint;begin  heap[1]:=heap[tot];  dec(tot);  i:=1;  while (i shl 1)&lt;=tot do begin    j:=i shl 1;    if (j+1&lt;=tot) and (h[heap[j+1]]&gt;h[heap[j]]) then inc(j);    if h[heap[i]]&lt;h[heap[j]] then begin      t:=heap[i];      heap[i]:=heap[j];      heap[j]:=t;    end      else break;    i:=j;  end;end;procedure bfs;var i,f,head,tail:longint;    p:array[0..2*max_n]of longint;begin  fillchar(h,sizeof(h),$3f);   head:=0;  tail:=1;  p[tail]:=t;  h[t]:=0;  while head&lt;tail do begin    inc(head);    f:=p[head];    i:=r[f];    while i&lt;&gt;0 do begin      if (w[search(i)]&lt;&gt;0) and (h[v[i]]&gt;h[f]+1) then begin        h[v[i]]:=h[f]+1;        inc(tail);        p[tail]:=v[i];      end;      i:=l[i];    end;  end;  end;procedure reup(f:longint);var i:longint;begin  h[f]:=max_int;    i:=r[f];  while i&lt;&gt;0 do begin    if (w[i]&lt;&gt;0) and (h[v[i]]+1&lt;h[f]) then h[f]:=h[v[i]]+1;      i:=l[i];  end;end;procedure push(f:longint);var i:longint;    tt:longint;begin  i:=r[f];     while i&lt;&gt;0 do begin    if (w[i]&lt;&gt;0) and (h[f]=h[v[i]]+1) then begin      tt:=min(flow[f],w[i]);      dec(w[i],tt);      inc(w[search(i)],tt);      dec(flow[f],tt);      inc(flow[v[i]],tt);         if (tf[v[i]]=false) and (v[i]&lt;&gt;s) and (v[i]&lt;&gt;t) then begin        tf[v[i]]:=true;        insert(v[i]);      end;    end;    i:=l[i];    if flow[f]=0 then break;  end;end;procedure hlpp;var i,f,j:longint;    tt:longint;begin  h[s]:=n;  flow[s]:=max_int;  fillchar(num,sizeof(num),0);  for i:=1 to n do    if h[i]&lt;&gt;max_int then inc(num[h[i]]);  i:=r[s];  while i&lt;&gt;0 do begin    if w[i]&lt;&gt;0 then begin      tt:=w[i];       dec(w[i],tt);      inc(w[search(i)],tt);      dec(flow[s],tt);      inc(flow[v[i]],tt);      if (v[i]&lt;&gt;s) and (v[i]&lt;&gt;t) and (tf[v[i]]=false) then begin        tf[v[i]]:=true;          insert(v[i]);      end;    end;    i:=l[i];  end;  while tot&lt;&gt;0 do begin    f:=heap[1];    del;    tf[f]:=false;    push(f);       if flow[f]&lt;&gt;0 then begin      dec(num[h[f]]);      if num[h[f]]=0 then        for j:=1 to n do          if (j&lt;&gt;s) and (j&lt;&gt;t) and (h[j]&gt;h[f]) and (h[j]&lt;=n) then h[j]:=n+1;      reup(f);      inc(num[h[f]]);      insert(f);      tf[f]:=true;    end;  end;  writeln(flow[t]);end;begin  read(n,m,s,t);  re;  bfs;  hlpp;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day9","url":"/2019/02/23/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay9/","content":" 2019.2.19\n 长沙集训 $ Day 9 $\n今天并没有什么新内容，所以我自学了图论中的重要算法——网络最大流\n\n 网络最大流：\n给定一个网络图，求网络中的最大流量。\n 反向网络\n求解网络流最为暴力的算法就是通过一遍遍 $ BFS $ 来寻找是否有一条流量不为零的链连接源点（$ S ）和汇点（）和汇点（）和汇点（ T $），如果有就进行更新并计算答案。这条链就是所谓的增广路。\n但这种方式有可能会走入错误的道路，如下图（网络图是有向图， $ 1 $ 为源点， $ 4 $ 为汇点）。\n\n如果程序选择这条链为增广路，那计算出的最大流只有 $ 1 $ ，但实际最大流显然是 $ 2 $ 。该如何解决这个问题呢？其实很简单，那就是建立反向网络。（建立反向网络实际上是在原图中连反向边，这里为了表述清楚所以分开画图）\n\n初始时反向网络的所有边流量上限都为 $ 0 $ ，当找到一条增广路进行更新时，将原网络中的边减少流量上限，给反向网络中的边增加流量上限。\n\n这样，即使第一遍走了 $ 1 \\to 2 \\to 3 \\to 4 $ 这条路径，第二遍 $ BFS $ 时依然可以找到 $ 1 \\to 3 \\to 2 \\to 4 $ 这条增广路，完美解决了之前的问题。事实上，建立反向网络是网络流算法普遍使用的处理方式。\n为什么这样做是对的呢？思考一下，走过刚刚的两条路径，实际上 $ 2 \\to 3 $ 的路径上，流量上限仍未 $ 1 $ ,而 $ 3 \\to 2 $ 路径的流量上限仍为 $ 0 $ 。相当于走了 $ 1 \\to 2 \\to 4 $ 和 $ 1 \\to 3 \\to 4 $ 这两条链。\n\n $ E-K $ 算法\n$ E-K $ 算法实际上就是上文说到的暴力 $ BFS $ ，每找到一条增广路就进行更新，复杂度极高，且容易被卡。\n $ Dinic $ 算法\n$ Dinic $ 算法应该是使用最多的网络流增广路算法，实际上是对 $ E-K $ 算法的优化，具体做法是增加了分层图的处理。先用一次 $ BFS $ 给网络图分层，之后用 $ DFS $ 搜索增广路，相比之前的 $ BFS $ 暴力，效率已有很大的提高。\n$ Dinic $ 算法的最差时间复杂度为 $ O(n^{2} \\cdot m) $ ，但其实算法大部分情况下的复杂度都远低于上限，且大部分网络流题目的图都比较小， $ n $ 基本上是 $ [10^{2} , 10^{3}] $ 之间，熟练使用 $ Dinic $ 算法便可应对大部分题目。\n $ Dinic $ 算法程序\nprogram project1;const max_n=10005;      max_m=100005;var   r,deep:array[0..max_n]of int64;   l,v,w:array[0..4*max_m]of int64;   n,m,s,t:longint;function min(a,b:int64):int64;begin  if a&lt;b then exit(a) else exit(b);end;function search(q:longint):longint;begin  if q mod 2=0 then exit(q-1)    else exit(q+1);end;procedure re;var i,t,x,y,z:longint;begin  t:=0;  for i:=1 to m do begin    read(x,y,z);    inc(t);    l[t]:=r[x];    r[x]:=t;    v[t]:=y;    w[t]:=z;    inc(t);    l[t]:=r[y];    r[y]:=t;    v[t]:=x;    w[t]:=0;  end;end;function bfs:boolean;var i,f,head,tail:longint;    p:array[0..6*max_m]of longint;begin  fillchar(deep,sizeof(deep),0);  head:=0;  tail:=1;  deep[s]:=1;  p[tail]:=s;  while head&lt;tail do begin    inc(head);    f:=p[head];    i:=r[f];    while i&lt;&gt;0 do begin      if (w[i]&gt;0) and (deep[v[i]]=0) then begin        deep[v[i]]:=deep[f]+1;        inc(tail);        p[tail]:=v[i];      end;      i:=l[i];    end;  end;  if deep[t]=0 then exit(false)    else exit(true);end;function dfs(f,dis:int64):int64;var i:longint;begin  dfs:=0;  if f=t then exit(dis);  i:=r[f];  while i&lt;&gt;0 do begin    if (w[i]&gt;0) and (deep[v[i]]=deep[f]+1) then dfs:=dfs(v[i],min(dis,w[i]));    if dfs&gt;0 then begin      dec(w[i],dfs);      inc(w[search(i)],dfs);      exit(dfs);    end;    i:=l[i];  end;  exit(0);end;procedure main;var ans,df:int64;begin  ans:=0;  while bfs=true do begin    df:=dfs(s,maxint);    while df&lt;&gt;0 do begin      inc(ans,df);      df:=dfs(s,maxint);    end;  end;  writeln(ans);end;begin  read(n,m,s,t);  re;  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day8","url":"/2019/02/22/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay8/","content":" 2019.2.18\n 长沙集训 $ Day 8 $\n$ Day 6 $ 讲解了 $ CDQ $ 分治，今天有学到了一种树上分治方法——点分治。\n\n 点分治:\n给出一棵树，询问树上有无距离为 $ k $ 的点对存在。\n对于此类问题，最基础的方法是 $ DFS $ 树上的每一条链，寻找有无链长为 $ k $ ,但是这样的做法时间复杂度为 $ O(n^{2}) $ ,肯定会 $ TLE $ 。这时，我们便可使用点分治来解决问题。\n实际上，如果选一个节点为根，树上的链可以分成两种，即经过树根和在子树中。\n\n而这便是点分治的基础，我们选择一个根，进行一次 $ DFS $ ，处理完所有经过根的路径，之后我们将根删除。原有的树被分为多棵子树，在所有子树中进行同样的操作，直到所有节点都被删除。\n但根节点的选择也是有技巧的，如上图中选择 $ R $ 为根和选择 $ K $ 为根，分治的次数是不同的，如何选取一个节点，使分治次数最少？事实上，这个点就是树的重心。\n 树的重心\n性质：以删去重心后，形成所有子树中，最大的子树最小。\n如上图中，树的重心为 $ R $ 。因为以 $ R $ 为根时，最大子树为 $ 4 $ ，其余各点为根时，没有任何一个点能使最大子树小于 $ 4 $ 。\n我们可以利用性质来寻找树的重心，只需通过一次树形 $ DP $ ，找出每个点的最大子树即可。\nprocedure find(f,fa,sum_root:longint);  //sum_root为整棵树的大小，f为当前节点，fa为f的父节点var i:longint;begin  i:=r[f];  sum[f]:=0;          //sum[f]记录以f为根的子树的大小，max_next[f]记录删去f后形成的最大子树大小  max_next[f]:=0;  while i&lt;&gt;0 do begin    if (v[i]&lt;&gt;fa) and (tf[v[i]]=false) then begin      find(v[i],f,sum_root);      inc(sum[f],sum[v[i]]);      max_next[f]:=max(max_next[f],sum[v[i]]);    end;    i:=l[i];  end;  inc(sum[f]);  max_next[f]:=max(max_next[f],sum_root-sum[f]);  if (max_next[f]&lt;max_next[find_root]) or (find_root=0) then find_root:=f;    //  find_root记录重心end;\n 分治处理\n找到重心后，我们便可以通过DFS查找答案，但此时要注意这种特殊情况。\n\n像这样的两条链是不能将他们的长度加在一起的，但显然这种情况在记录答案时是不好处理的，所以我们可以跑两遍 $ DFS $ ，第一遍记录答案（不论正误），第二遍将错误的答案减掉。\nprocedure dfs(f,fa,len:longint);var i:longint;begin  i:=r[f];  inc(tot);  dis[tot]:=len;  while i&lt;&gt;0 do begin    if (v[i]&lt;&gt;fa) and (tf[v[i]]=false) then dfs(v[i],f,len+w[i]);    i:=l[i];  end;end;function solve(q,k:longint;len:int64):int64;var i,j:longint;begin  tot:=0;    dfs(q,0,len);  if k=1 then begin    for i:=1 to tot do      for j:=i+1 to tot do        inc(ans[dis[i]+dis[j]]);  end    else begin      for i:=1 to tot do        for j:=i+1 to tot do          dec(ans[dis[i]+dis[j]]);    end;end;procedure next(q:longint);var i:longint;begin  tf[q]:=true;  solve(q,1,0);             //注意这两次solve时参数的不同  i:=r[q];    while i&lt;&gt;0 do begin    if tf[v[i]]=false then begin      solve(v[i],0,w[i]);        find_root:=0;      find(v[i],q,sum[v[i]]);       next(find_root);    end;    i:=l[i];  end;end;\n 复杂度\n根据树的重心的性质，我们可以确定分治次数不超过 $ \\log n $ 次，由此可得出算法的时间复杂度：\n\n分治 $ O(\\log n) $\n查找答案 $ O(n) $\n\n总时间复杂度接近 $ O(n \\log n) $\n其实点分治的难点并不在分治，而是在计算答案的过程，某些题目中不能单纯使用暴力计算答案，还要和其他算法、数据结构相结合（如二分、树状数组），又或者计算答案的过程十分繁琐（如树上游戏），所以还是需要熟练运用多种算法才能顺利解决点分治问题。\n 程序\nprogram project1;var   r,sum,max_next,dis:array[0..10005]of longint;   tf:array[0..10005]of boolean;   ans:array[0..10000005]of longint;   l,v,w:array[0..20005]of longint;   n,m,find_root,tot:longint;function max(a,b:int64):int64;begin  if a&gt;b then exit(a) else exit(b);end;procedure re;var i,t,x,y,z:longint;begin  t:=0;  for i:=1 to n-1 do begin    read(x,y,z);    inc(t);    l[t]:=r[x];    r[x]:=t;    v[t]:=y;    w[t]:=z;    inc(t);    l[t]:=r[y];    r[y]:=t;    v[t]:=x;    w[t]:=z;  end;end;procedure find(f,fa,sum_root:longint);var i:longint;begin  i:=r[f];  sum[f]:=0;  max_next[f]:=0;  while i&lt;&gt;0 do begin    if (v[i]&lt;&gt;fa) and (tf[v[i]]=false) then begin      find(v[i],f,sum_root);      inc(sum[f],sum[v[i]]);      max_next[f]:=max(max_next[f],sum[v[i]]);    end;    i:=l[i];  end;  inc(sum[f]);  max_next[f]:=max(max_next[f],sum_root-sum[f]);  if (max_next[f]&lt;max_next[find_root]) or (find_root=0) then find_root:=f;end;procedure dfs(f,fa,len:longint);var i:longint;begin  i:=r[f];  inc(tot);  dis[tot]:=len;  while i&lt;&gt;0 do begin    if (v[i]&lt;&gt;fa) and (tf[v[i]]=false) then dfs(v[i],f,len+w[i]);    i:=l[i];  end;end;function solve(q,k:longint;len:int64):int64;var i,j:longint;begin  tot:=0;     dfs(q,0,len);  if k=1 then begin    for i:=1 to tot do      for j:=i+1 to tot do        inc(ans[dis[i]+dis[j]]);  end    else begin      for i:=1 to tot do        for j:=i+1 to tot do          dec(ans[dis[i]+dis[j]]);    end;end;procedure next(q:longint);var i:longint;begin  tf[q]:=true;  solve(q,1,0);  i:=r[q];    while i&lt;&gt;0 do begin    if tf[v[i]]=false then begin      solve(v[i],0,w[i]);      find_root:=0;      find(v[i],q,sum[v[i]]);       next(find_root);    end;    i:=l[i];  end;end;procedure main;var i,x:longint;begin  for i:=1 to m do begin    read(x);    if ans[x]&lt;&gt;0 then writeln(&#x27;AYE&#x27;)      else writeln(&#x27;NAY&#x27;);  end;end;begin  read(n,m);  re;  find_root:=0;  find(1,0,n);   next(find_root);  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day7","url":"/2019/02/21/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay7/","content":" 2019.2.17\n 长沙集训 $ Day 7 $\n\n T1 X国的军队\n此题和国王游戏类似，看似毒瘤 $ DP $ ，其实是贪心+排序。\n先看简单的情况：\n\n\n\n据点\n火力$ a $\n人数$ b $\n\n\n\n\n$ A $\n$ a_1 $\n$ b_1 $\n\n\n$ B $\n$ a_2 $\n$ b_2 $\n\n\n\n先打 $ A $ 再打 $ B $ ，需要总人数 $ sum_A=b_2-(b_1-a_1)+b_1 $\n先打 $ B $ 再打 $ A $ ，需要总人数 $ sum_B=b_1-(b_2-a_2)+b_2 $\n用两数相减比较大小：\n$ sum_A-sum_B=(b_2-a_2)-(b_1-a_1) $\n\n$ sum_A $ 小，先打 $ A $ 更优，此时 $ (b_2-a_2) &lt; (b_1-a_1) $\n$ sum_B $ 小，先打 $ B $ 更优，此时 $ (b_2-a_2) &gt; (b_1-a_1) $\n\n由此可知，不论何时， $ b-a $ 最大的据点一定是优先攻击的目标，只有这样我们才能以最小的人数攻击所有据点。\n只需将数据以 $ b-a $ 从大到小排序后计算答案即可。\n 程序\nprogram army;type tp=record  a,b,c:longint;end;var   f:array[0..100005]of tp;   t,n:int64;procedure re;var i:longint;begin  for i:=1 to n do begin    read(f[i].a,f[i].b);    f[i].c:=f[i].b-f[i].a;  end;end;procedure qsort(l,r:longint);var i,j:longint;    t,mid:tp;begin  i:=l;  j:=r;  mid.a:=f[(l+r) shr 1].a;  mid.c:=f[(l+r) shr 1].c;  repeat    while (f[i].c&gt;mid.c) or ((f[i].c=mid.c) and (f[i].a&lt;mid.a)) do inc(i);    while (f[j].c&lt;mid.c) or ((f[j].c=mid.c) and (f[j].a&gt;mid.a)) do dec(j);    if i&lt;=j then begin      t:=f[i];      f[i]:=f[j];      f[j]:=t;      inc(i);      dec(j);    end;  until i&gt;j;  if i&lt;r then qsort(i,r);  if l&lt;j then qsort(l,j);end;procedure main;var i:longint;    ans,num:int64;begin  while t&gt;0 do begin    read(n);    re;    qsort(1,n);    num:=0;    ans:=0;    for i:=1 to n do begin      if f[i].b-num&gt;0 then begin        inc(ans,f[i].b-num);        num:=f[i].b;      end;      num:=num-f[i].a;    end;    writeln(ans);    dec(t);  end;end;begin  read(t);  main;end.\n T2 排列组合\n题目要我们对于每个给定 $ n $ 求这个式子的值：\n$ C_{n}^{1} \\cdot C_{n}^{1} + C_{n}^{2} \\cdot C_{n}^{2} + C_{n}^{3} \\cdot C_{n}^{3} + \\ … \\  + C_{n}^{n} \\cdot C_{n}^{n} $\n组合数公式：\n$ C_{n}^{m}=\\frac{n!}{m! \\cdot (n-m)!}$\n最简单的做法就是利用公式，对于每一个 $ n $ 求值，这样一次求值的时间复杂度是 $ O(n) $ ,有 $ T $ 次询问，总时间复杂度是 $ O(n \\cdot T) $ ，保证 $ TLE $\n所以我们要 $ O(n) $ 求出所有式子的值，然后 $ O(1) $ 处理询问。\n这里要用到组合数平方和公式：\n$ C_{n}^{1} \\cdot C_{n}^{1} + C_{n}^{2} \\cdot C_{n}^{2} + C_{n}^{3} \\cdot C_{n}^{3} + \\ … \\  + C_{n}^{n} \\cdot C_{n}{n}=C_{2n}{n} $\n对于此题，我们只要求出 $ C_{2n}^{n} \\ \\ \\ , n \\in [1,1000000] $  的值即可。\n 程序\nprogram pc;const p=1000000007;var   f,ans:array[0..1000005]of int64;   t,i:longint;procedure up;var i:longint;    l,r,ans_c:int64;begin  l:=2;  r:=2;  ans_c:=2;  ans[1]:=2;  for i:=2 to 1000005 do begin    inc(r);      ans_c:=(((ans_c*r) mod p)*f[i]) mod p;    inc(r);    ans_c:=(((ans_c*r) mod p)*f[l]) mod p;    inc(l);    ans[i]:=ans_c;  end;end;procedure main;var i,x:longint;begin  for i:=1 to t do begin    read(x);    writeln(ans[x]);  end;end;begin  read(t);  f[0]:=0;  f[1]:=1;  for i:=2 to 1000005 do    f[i]:=p-(p div i)*f[p mod i]mod p;  up;  main;end.\n T3 回文\n看到求回文串，本来以为是要对 $ manacher $ 进行优化，最后发现正解和 $ manacher $ 一点关系都没有，而是毒瘤 $ DP $ ！\n设 $ tf[i,j] $ 记录区间 $ [i,j] $ 是否为回文串：\n$ tf[i,j]=tf[i+1,j-1] \\ \\ and \\ \\ (s[i]=s[j]) $\n$ tf[i,j]=0 $ 表示区间未处理\n$ tf[i,j]=1 $ 表示区间是回文串\n$ tf[i,j]=2 $ 表示区间不是回文串\n设 $ dp[i,j] $ 表示区间 $ [i,j] $ 的回文串个数：\n当 $ tf[i,j]=2 $ 时：$ dp[i,j]=dp[i+1,j]+dp[i,j-1]-dp[i+1,j-1] $\n当 $ tf[i,j]=1 $ 时：$ dp[i,j]=dp[i+1,j]+dp[i,j-1]-dp[i+1,j-1]+1 $\n 程序\nprogram pal;var   tf:array[0..5005,0..5005]of integer;   dp:array[0..5005,0..5005]of int64;   s:array[0..5005]of char;   len:longint;procedure re;var p:ansistring;    i:longint;begin  readln(p);  len:=length(p);  for i:=1 to len do s[i]:=p[i];end;procedure dp_up;var i:longint;begin  for i:=1 to len do begin    tf[i,i]:=1;       dp[i,i]:=1;    dp[i,i+1]:=2;    if s[i]=s[i+1] then begin      tf[i,i+1]:=1;      inc(dp[i,i+1]);    end;  end;end;function dfs(l,r:longint):boolean;begin  if l&gt;r then exit(false);  dfs:=false;    if tf[l,r]=2 then exit(false);  if tf[l,r]=1 then exit(true)    else begin      if (dfs(l+1,r-1)=true) and (s[l]=s[r]) then tf[l,r]:=1        else tf[l,r]:=2;      if tf[l,r]=1 then exit(true)        else exit(false);    end;end;procedure dp_;var i,j,l:longint;begin          for i:=1 to len do begin    l:=0;    for j:=i to len do begin      inc(l);      dp[l,j]:=dp[l+1,j]+dp[l,j-1]-dp[l+1,j-1];      if dfs(l,j)=true then inc(dp[l,j]);      end;  end;end;procedure main;var i,t,x,y:longint;begin  read(t);  for i:=1 to t do begin    read(x,y);    writeln(dp[x,y]);  end;end;begin  re;    dp_up;  dp_;  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day6","url":"/2019/02/20/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay6/","content":" 2019.2.16\n 长沙集训 $ Day 6 $\n今天没有模拟赛，而是介绍了一种神奇的算法，现在让我们一起了解一下 $ CDQ $ 分治的魅力。\n\n 三维偏序问题：\n共有 $ n $ 个元素，对于第 $ i $ 个元素，给出三个量：$ a_i \\ \\ , \\ \\ b_i \\ \\ ,\\ \\ c_i $ ,询问$       a_j&lt;a_i , b_j&lt;b_i , c_j&lt;c_i $ 的元素有多少个。\n如果 $ n $ 很小，我们可以用三维前缀和解决这个问题，但当 $ n=10000 $ 或者更大时，显然需要二维树形结构来维护，但树形结构消耗空间大，编程难度高，且处理时常数复杂度高。这时，我们便可以用 $ CDQ $ 分治来解决问题。\n先从二位偏序看起:\n要解决二维偏序，我们可以先使用快排将第一维处理为有序排列。之后再利用树状数组或分治在第二维上统计答案。（例如逆序对）\n现在问题变成了三维，我们依然可以沿用解决二维偏序问题的思路。依然用快排处理第一维（例如将其从小到大排列），但这时不能直接将第二维再次排序，否则会打乱第一维的顺序。为解决这个问题，我们可以用分治将数列分成左右两份。注意到左边的 $ a_i $ 一定小于右边的 $ a_j $ ,此时我们将左右两边的 $ b $ 分别排成有序数列，虽然 $ a $ 的顺序会被打乱，但左边 $ a $ 一定是比右边 $ a $ 小。此时，我们便可以统计左边元素对右边元素的贡献。通过层层分治，可以求出所有贡献。\n\n 如何排序\n对第二维元素可以用快排排序，这样的时间复杂度：\n\n快排 $ O(n \\log n) $\n分治 $ O(\\log n) $\n处理答案 $ O(n) $\n\n总时间复杂度接近 $ O(n \\log^{2} n) $\n这个速度已经可以解决大部分问题，但其实还有更快的处理方式。因为分治的过程类似归并排序，所以我们可以在处理答案时对b进行归并排序，这样的时间复杂度：\n\n分治 $O(\\log n) $\n处理答案+排序 $ O(n) $\n\n总时间复杂度接近 $ O(n \\log n) $\n 处理答案\n对答案的处理一般是使用树状数组进行统计，但其实我们可以再次利用 $ CDQ $ 分治的方法，继续对第三维进行分治，即在 $ b $ 排序后，再将区间分为两份，对 $ c $ 进行排序并统计答案。这种 $ CDQ $ 嵌套还可以继续进行，以解决四维、五维偏序问题。\n 程序（ $ CDQ $ 套 $ CDQ $ ）\nprogram project1;type tp=record  a,b,c,tot,tf,ans:longint;  tfp:boolean;end;var   f,a,b:array[0..100005]of tp;   ans:array[0..100005]of longint;   n,k:longint;function max(a,b:longint):longint;begin  if a&gt;b then exit(a) else exit(b);end;procedure re;var i:longint;begin  for i:=1 to n do    read(f[i].a,f[i].b,f[i].c);end;procedure qsort(l,r:longint);var i,j:longint;    t,mid:tp;begin  i:=l;  j:=r;  mid:=f[(i+j) div 2];  repeat    while (f[i].a&lt;mid.a) or ((f[i].a=mid.a) and (f[i].b&lt;mid.b)) or ((f[i].a=mid.a) and (f[i].b=mid.b) and (f[i].c&lt;mid.c)) do inc(i);    while (f[j].a&gt;mid.a) or ((f[j].a=mid.a) and (f[j].b&gt;mid.b)) or ((f[j].a=mid.a) and (f[j].b=mid.b) and (f[j].c&gt;mid.c)) do dec(j);    if i&lt;=j then begin      t:=f[i];      f[i]:=f[j];      f[j]:=t;      inc(i);      dec(j);    end;  until i&gt;j;  if i&lt;r then qsort(i,r);  if l&lt;j then qsort(l,j);end;procedure cdq_c(l,r:longint);var i,j,mid,t,sum,ii:longint;begin  if l=r then begin    if f[l].tfp=false then begin      inc(ans[f[l].ans],f[l].tot-1);      f[l].tfp:=true;    end;      exit;  end;  mid:=(l+r) shr 1;  cdq_c(l,mid);  cdq_c(mid+1,r);  i:=l;  j:=mid+1;  t:=l-1;  sum:=0;  while t&lt;=r-1 do begin    inc(t);              if ((a[i].c&lt;=a[j].c) or (j&gt;r)) and (i&lt;=mid) then begin      b[t]:=a[i];      inc(sum,b[t].tf*b[t].tot);      inc(i);    end      else begin        b[t]:=a[j];                inc(j);      end;  end;  for i:=l to r do a[i]:=b[i];end;procedure cdq_b(l,r:longint);var i,mid,j,t:longint;begin  if l=r then begin    cdq_c(l,r);    exit;  end;  mid:=(l+r) shr 1;  cdq_b(l,mid);  cdq_b(mid+1,r);  i:=l;  j:=mid+1;  t:=l-1;     while t&lt;=r-1 do begin    inc(t);    if ((f[i].b&lt;=f[j].b) or (j&gt;r)) and (i&lt;=mid) then begin      a[t]:=f[i];      a[t].tf:=1;      inc(i);    end      else begin        a[t]:=f[j];        a[t].tf:=0;        inc(j);      end;  end;  for i:=l to r do f[i]:=a[i];  cdq_c(l,r);end;procedure main;var i,j:longint;    sum:array[0..100005]of longint;begin  j:=1;  f[1].tot:=1;  for i:=2 to n do    if ((f[i].a=f[j].a) and (f[i].b=f[j].b) and (f[i].c=f[j].c)) then inc(f[j].tot)      else begin        inc(j);        f[j]:=f[i];        f[j].tot:=1;      end;  for i:=1 to j do f[i].ans:=i;  fillchar(sum,sizeof(sum),0);  fillchar(ans,sizeof(ans),0);  cdq_b(1,j);  for i:=1 to j do inc(sum[ans[f[i].ans]],f[i].tot);  for i:=0 to n-1 do writeln(sum[i]);end;begin  read(n,k);  re;  qsort(1,n);  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day5","url":"/2019/02/19/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay5/","content":" 2019.2.15\n 长沙集训 $ Day 5 $\n今天的题目还是比较简单的，但是我的程序却出现了许多严重的 $ bug $ ,最终让我获得了 $ 20 $ 分的“好成绩”…\n\n T1 modeq\n这题可以说是扩展欧几里得算法的板子题了，分别套用一次 $ exgcd $ 求出最小 $ x,y $ ，然而我调试时把绝对值删了，后来又忘了改回去，最后 $ 100 \\to 0 $\n求解方法：\n对于方程 $ a \\cdot x + b \\cdot y = c $\n\n只有在 $ c \\ \\ mod \\ \\ gcd(a,b) = 0 $ 时，方程才有解\n若 $ exgcd $ 解出的 $ x $ 为负值，可用 $ x=(x+abs(b*n)) \\ \\ mod \\ \\ b $ 的方式将其变为正值\n$ \\frac{(a \\cdot x)}{m} +\\frac{(b \\cdot y)}{m} =\\frac{c}{m} $ 此方程的解与原方程相同，所以可以先将方程化简在进行处理\n\n 程序\nprogram modeq;var t,x,y,gd:int64;function gcd(a,b:int64):int64;begin  if b=0 then exit(a);  gcd:=gcd(b,a mod b);end;procedure exgcd(a,b,c:int64);var t:int64;begin  if b=0 then begin    x:=c div a;    y:=0;    exit;  end;  exgcd(b,a mod b,c);  t:=x;  x:=y;  y:=t-(a div b)*y;end;procedure main;var i:longint;    a,b,c,ans_x,ans_y:int64;begin  for i:=1 to t do begin    read(a,b,c);    gd:=gcd(a,b);    if c mod gd&lt;&gt;0 then begin      writeln(&#x27;No&#x27;);      continue;    end;    a:=a div gd;    b:=b div gd;    c:=c div gd;      if c mod b=0 then write(&#x27;0&#x27;,&#x27; &#x27;,c div b,&#x27; &#x27;)      else begin        exgcd(a,b,c);          ans_x:=(x+abs(b*1000000000)) mod b;        ans_y:=(c-a*ans_x) div b;        write(ans_x,&#x27; &#x27;,ans_y,&#x27; &#x27;);      end;    if c mod a=0 then writeln(c div a,&#x27; &#x27;,&#x27;0&#x27;)      else begin        exgcd(b,a,c);          ans_y:=(x+abs(a*1000000000)) mod a;        ans_x:=(c-b*ans_y) div a;        writeln(ans_x,&#x27; &#x27;,ans_y);    end;  end;end;begin  read(t);  main;end.\n T2 买卖\n开始以为是个毒瘤 $ DP $ ，后来发现是贪心，只要找到能把当前可以买入的最便宜的物品卖出赚钱的商店就把物品卖出，如果之后又更优秀的方案，就进行更改：\n\n\n\n编号\n买入\n卖出\n\n\n\n\nA\n$ 7 $\n$ 1 $\n\n\nB\n$ 10 $\n$ 8 $\n\n\nC\n$ 12 $\n$ 12 $\n\n\n\n\n在 $ A $ 处买入物品，在 $ B $ 出卖出价值 $ w=8-7=1 $ ，并将 $ A $ 处物品价格改为 $ 8 $\n发现在 $ C $ 出卖出是更优方案，相当于重新将物品买入，并在 $ C $ 处卖出，价值 $ w=12-8+1=12-7=5 $\n可买入物品的最小值可用小根堆/最小值线段树等数据结构维护\n\n 一定注意初始化\n 程序\nprogram buy;var   tree:array[0..400005]of int64;   a:array[0..100005,1..2]of int64;   n,tar,sum:longint;function min(a,b:int64):int64;begin  if a&lt;b then exit(a) else exit(b);end;procedure re;var i:longint;begin  for i:=1 to n do read(a[i,1]);  for i:=1 to n do read(a[i,2]);end;function search(l,r,t,k:longint):boolean;var mid:longint;begin  search:=false;  if l=r then begin       tree[t]:=k;    exit(true);  end;  mid:=(l+r) shr 1;  if tree[t shl 1 + 1]=tar then search:=search(mid+1,r,t shl 1 + 1,k);  if search=false then search:=search(l,mid,t shl 1,k);  tree[t]:=min(tree[t shl 1],tree[t shl 1 + 1]);  exit(search);end;procedure change(l,r,t,x,k:longint);var mid:longint;begin  if (l=r) and (l=x) then begin    tree[t]:=k;    exit;  end;  mid:=(l+r) shr 1;  if x&lt;=mid then change(l,mid,t shl 1,x,k);  if x&gt;=mid+1 then change(mid+1,r,t shl 1 + 1,x,k);  tree[t]:=min(tree[t shl 1],tree[t shl 1 + 1]);end;procedure main;var x,ans:int64;    i:longint;begin  ans:=0;  for i:=1 to n do begin    change(1,n,1,i,a[i,1]);    if tree[1]&lt;a[i,2] then begin      tar:=tree[1];         inc(ans,a[i,2]-tree[1]);      search(1,n,1,a[i,2]);    end;  end;  writeln(ans);end;begin  fillchar(tree,sizeof(tree),$5f);  read(n);  re;  main;end.\n T3 投资\n这题看起来是个 $ DP $ ，其实是前缀和+小根堆。\n两题都是小根堆，可以复制代码了！！！\n设$ [l,r] $ 是连续天数的范围\n$ ans=max(sum[i]-min(sum[j])) \\ \\ \\ \\ j \\in [i-r,i-l]$\n 程序\nprogram invest;var   a:array[0..100005]of int64;   heap:array[0..100005,1..2]of int64;   n,l,r,tot:longint;function max(a,b:int64):int64;begin  if a&gt;b then exit(a) else exit(b);end;function min(a,b:int64):int64;begin  if a&lt;b then exit(a) else exit(b);end;procedure re;var i:longint;begin  for i:=1 to n do read(a[i]);end;procedure insert(q,p:int64);var i,j,t:int64;begin  inc(tot);     heap[tot,1]:=q;  heap[tot,2]:=p;  i:=tot;  while i shr 1&lt;&gt;0 do begin    j:=i shr 1;    if heap[j,1]&gt;heap[i,1] then begin      t:=heap[j,1];      heap[j,1]:=heap[i,1];      heap[i,1]:=t;      t:=heap[j,2];      heap[j,2]:=heap[i,2];      heap[i,2]:=t;    end      else break;    i:=j;  end;end;procedure del;var i,j,t:longint;begin  heap[1]:=heap[tot];  dec(tot);  i:=1;  while i shl 1&lt;=tot do begin    j:=i shl 1;    if (j+1&lt;=tot) and (heap[j,1]&gt;heap[j+1,1]) then inc(j);    if heap[j,1]&lt;heap[i,1] then begin      t:=heap[j,1];      heap[j,1]:=heap[i,1];      heap[i,1]:=t;      t:=heap[j,2];      heap[j,2]:=heap[i,2];      heap[i,2]:=t;    end      else break;    i:=j;  end;end;procedure main;var sum:array[0..100005]of int64;    ans:int64;    i:longint;begin  fillchar(sum,sizeof(sum),0);  ans:=-10000000000;  sum[1]:=a[1];  if l&lt;=1 then ans:=sum[1];  for i:=2 to n do begin    sum[i]:=sum[i-1]+a[i];       if i-l&gt;0 then insert(sum[i-l],i-l);       while i-heap[1,2]&gt;r do del;    if i&gt;=l then ans:=max(ans,sum[i]-heap[1,1]);  end;  writeln(ans);  end;begin  fillchar(heap,sizeof(heap),$5f);  read(n,l,r);  re;  main;end.\n T4 游戏\n先用 $ manacher $ 求出以每个位置为中心的最长回文串的半径，之后进行统计，半径为 $ t $ 的回文串个数 $ sum[t] $ 为半径大于等于 $ t $ 的回文串个数之和。统计个数后用快速幂计算答案，注意取模。\n 程序\nprogram rehearse;const p=19930726;var   f:array[0..2000005]of longint;   sum:array[0..2000005]of int64;   s:array[0..2000005]of char;   len,n,k:int64;function min(a,b:longint):longint;begin  if a&lt;b then exit(a) else exit(b);end;procedure re;var i:longint;    p:ansistring;begin  readln(p);  len:=1;  s[0]:=&#x27;#&#x27;;  s[len]:=&#x27;#&#x27;;  for i:=1 to n do begin    inc(len);    s[len]:=p[i];    inc(len);    s[len]:=&#x27;#&#x27;;  end;end;procedure manacher;var i,mid,mx:longint;begin  mid:=1;  mx:=1;  for i:=1 to len do begin    if i&lt;mx then f[i]:=min(mx-i,f[mid*2-i])      else f[i]:=1;    while s[i-f[i]]=s[i+f[i]] do inc(f[i]);    if f[i]+i&gt;mx then begin      mx:=f[i]+i;      mid:=i;    end;  end;  for i:=1 to len do    if s[i]&lt;&gt;&#x27;#&#x27; then inc(sum[f[i]]);end;function mul(q,k:int64):int64;var t:int64;begin  t:=q;  mul:=1;  while k&lt;&gt;0 do begin    if k and 1&lt;&gt;0 then mul:=(mul mod p)*(t mod p) mod p;    t:=(t mod p)*(t mod p) mod p;    k:=k shr 1;  end;end;procedure main;var i:longint;    ans,t:int64;begin  ans:=1;  t:=0;  sum[(len div 2) + 3]:=0;  for i:=(len div 2) + 2 downto 1 do begin    sum[i]:=sum[i]+sum[i+1];          if (i-1) mod 2=1 then begin      inc(t,sum[i]);      if t&lt;=k then ans:=(ans mod p)*(mul(i-1,sum[i]) mod p) mod p        else begin          ans:=(ans mod p)*(mul(i-1,k-t+sum[i]) mod p) mod p;          break;        end;    end;  end;  if t&lt;k then writeln(&#x27;-1&#x27;)    else writeln(ans);end;begin  readln(n,k);  re;  manacher;  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day4","url":"/2019/02/18/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay4/","content":" 2019.2.14\n 长沙集训 $ Day 4 $\n今天的题目异常困难，至少这是我最接近爆零的一次\n\n T1 高斯消元\n虽然题目名字是高斯消元，实际上和高斯消元法没半点关系！\n这题的核心解法是栈，在读入时将数字压入栈中，如果栈顶有连续k个相同数字就将他们全部弹出。之后再从数列的首尾模拟将数字删去。\n 程序\nvar  f:array[0..100005,1..2]of int64;  n,m,k:int64;procedure re;var i:longint;    x,t:int64;begin  t:=0;  f[t,1]:=-1;  for i:=1 to n do begin    read(x);    if x=f[t,1] then inc(f[t,2])      else begin        inc(t);        f[t,1]:=x;        f[t,2]:=1;      end;    if f[t,2]=k then begin      f[t,2]:=0;      dec(t);    end;  end;  n:=t;end;procedure main;var i,l,r:longint;    sum,del:int64;begin  r:=n;  sum:=0;  del:=0;  for i:=1 to n do inc(sum,f[i,2]);  for i:=1 to n do begin    if (i&gt;=r) or (f[i,1]&lt;&gt;f[r,1]) then begin      l:=i;      break;    end;    if f[i,2]+f[r,2]=k then begin      if l+1=r then begin        f[i,2]:=0;        f[r,2]:=0;        l:=i;        break;      end else dec(r);    end      else if f[i,2]+f[r,2]&gt;k then begin        dec(f[r,2],k-f[i,2]);        f[i,2]:=0;      end else begin        l:=i;        break;      end;  end;  if (l=r) and (l=1) then begin    writeln(f[l,2]*m mod k);    exit;  end;  if l=r then begin    writeln(sum-1+f[l,2]*m mod k);    exit;  end;  for i:=l to r do inc(del,f[i,2]);  writeln(sum*m-(sum-del)*(m-1));end;begin  read(n,m,k);  re;  main;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day3","url":"/2019/02/17/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay3/","content":" 2019.2.13\n 长沙集训 $ Day 3 $\n今天的题突然变得简单了，感觉比 $ Day 1 $ 还简单，但一看标题…\n$ NOIP $ 模拟赛！！！\n\n T1 A\n没错，今天的题目名称就是这么敷衍，甚至于题目描述也十分模糊…\n第一题是一道模拟水题，只要按照横坐标从左到右枚举一遍，取最大答案即可。\n 评测结果我只有 $ 40 $ 分，但是用数据自测答案却是正确的，在本地用 $ lemon $ 测就 $ AC $ 了！？此问题有待解决…\n 程序\nprogram a;var   m,b,n:int64;   ans:int64;procedure main;var i:longint;    t,sum,max:int64;begin  if (m&lt;0) and (b&gt;0) then begin    writeln((1+b)*b div 2);    exit;  end;  if (m&lt;0) and (b&lt;0) then begin    writeln((1+n)*n div 2);    exit;  end;  if (m&gt;0) and (b&lt;0) then begin    writeln(&#x27;0&#x27;);    exit;  end;                           //特判，防止m&lt;0或b&lt;0   t:=b+1;  ans:=(1+b)*b div 2;  sum:=ans;  max:=ans;  for i:=1 to n do begin      while t-1&gt;-(i/m)+b do begin      dec(t);         dec(sum,t+i-1);         dec(max,i*t+(i*(i-1) div 2));    end;    inc(sum,t);    inc(max,sum);    if max&gt;ans then ans:=max;   end;  writeln(ans);end;begin  ans:=0;  read(m,b);  n:=abs(m*b);  main;end.\n T2 B\n此题虽是 $ T2 $ ，但难度却远超 $ T3 $ ，思路并不复杂，但代码就…\n一看到将区间覆盖成 $ 1 $ 或 $ 0 $ ，立刻就想到线段树，但如何维护？好在我做染色和软件包管理器时的处理方式给了我启发！\n对于 $ tree[t] $ :\n$ tree[t].l $ 维护 $ t $ 区间最左边连续 $ 0 $ 的个数\n$ tree[t].r $ 维护 $ t $ 区间最有边连续 $ 0 $ 的个数\n$ tree[t].p $ 维护 $ t $ 区间最多连续 $ 0 $ 的个数\n有了储存方式，接下来就是修改了：\n\n像如上这些区间的修改是一大难点\n修改 $ tree[t].p $ :\n$ tree[t].p = max(tree[t \\ \\ shl \\ \\ 1].r+tree[t \\ \\ shl \\ \\ 1 + 1].l,tree[t \\ \\ shl \\ \\ 1].p,tree[t \\ \\ shl \\ \\ 1 + 1].p) $\n修改 $ tree[t].l $ 和 $ tree[t].r $ :\n$ tree[t].l=tree[t \\ \\ shl \\ \\ 1].p+tree[t \\ \\ shl \\ \\ 1 + 1].l \\ \\ \\ \\ \\ \\ \\ \\ tree[t \\ \\ shl \\ \\ 1] $ 的区间全是 $ 0 $\n$ tree[t].l=tree[t \\ \\ shl \\ \\ 1].l $\n$ tree[t].r=tree[t \\ \\ shl \\ \\ 1].r+tree[t \\ \\ shl \\ \\ 1 + 1].p \\ \\ \\ \\ \\ \\ \\ \\  tree[t \\ \\ shl \\ \\ 1 + 1] $ 的区间全是 $ 0 $\n$ tree[t].r=tree[t \\ \\ shl \\ \\ 1 + 1].r $\n查找答案：\n\n$ tree[t].l&gt;=len $ 处理答案\n$ tree[t \\ \\ shl \\ \\ 1].p&gt;=len $ 扩展到$ t \\ \\ shl \\ \\ 1 $ 节点\n$ tree[t \\ \\ shl \\ \\ 1].r+tree[t \\ \\ shl \\ \\ 1 + 1].l&gt;=len $ 处理答案\n$ tree[t \\ \\ shl \\ \\ 1 + 1].p&gt;=len $ 扩展到 $ t \\ \\ shl \\ \\ 1 + 1 $ 节点\n$ tree[t].r&gt;=len $ 处理答案\n\n按照从 $ 1 $ 到 $ 5 $ 的步骤处理，随时下放懒标记\n 程序\nprogram b;type tp=record  l,r,p:longint;end;var   tree,tree_simple:array[0..200005]of tp;   p:array[0..200005]of integer;   n,m:longint;function max(a,b:longint):longint;begin  if a&gt;b then exit(a) else exit(b);end;procedure up(t:longint);begin  tree[t].p:=max(tree[t shl 1].r+tree[t shl 1 + 1].l,max(tree[t shl 1].p,tree[t shl 1 + 1].p));  if tree[t shl 1].p=tree_simple[t shl 1].p then tree[t].l:=tree[t shl 1].p+tree[t shl 1 + 1].l    else tree[t].l:=tree[t shl 1].l;  if tree[t shl 1 + 1].p=tree_simple[t shl 1 + 1].p then tree[t].r:=tree[t shl 1].r+tree[t shl 1 + 1].p    else tree[t].r:=tree[t shl 1 + 1].r;end;procedure build_simple(l,r,t:longint);var mid:longint;begin  if l=r then begin    tree_simple[t].p:=1;    tree_simple[t].l:=1;    tree_simple[t].r:=1;    exit;  end;  mid:=(l+r) shr 1;  build_simple(l,mid,t shl 1);  build_simple(mid+1,r,t shl 1 + 1);  tree_simple[t].p:=tree_simple[t shl 1].p+tree_simple[t shl 1 + 1].p;  tree_simple[t].l:=tree_simple[t shl 1].l+tree_simple[t shl 1 + 1].l;  tree_simple[t].r:=tree_simple[t shl 1].r+tree_simple[t shl 1 + 1].r;end;procedure down(t:longint);       //下放懒标记begin  if p[t]=0 then exit;  if p[t]=1 then begin    p[t shl 1]:=p[t];    p[t shl 1 + 1]:=p[t];    tree[t shl 1].p:=0;    tree[t shl 1].l:=0;    tree[t shl 1].r:=0;    tree[t shl 1 + 1].p:=0;    tree[t shl 1 + 1].l:=0;    tree[t shl 1 + 1].r:=0;    p[t]:=0;  end;  if p[t]=2 then begin    p[t shl 1]:=p[t];    p[t shl 1 + 1]:=p[t];    tree[t shl 1]:=tree_simple[t shl 1];    tree[t shl 1 + 1]:=tree_simple[t shl 1 + 1];    p[t]:=0;  end;end;procedure change(l,r,t,x,y,k:longint);var mid:longint;begin           if (x&lt;=l) and (y&gt;=r) then begin    if k=1 then begin      tree[t].p:=0;      tree[t].l:=0;      tree[t].r:=0;    end      else tree[t]:=tree_simple[t];    p[t]:=k;    exit;  end;  mid:=(l+r) shr 1;  down(t);  if x&lt;=mid then change(l,mid,t shl 1,x,y,k);  if y&gt;=mid+1 then change(mid+1,r,t shl 1 + 1,x,y,k);  up(t);end;function dfs(l,r,t,k,len:longint):boolean;var mid:longint;begin  dfs:=false;  mid:=(l+r) shr 1;  down(t);  if tree[t].l&gt;=len then begin    writeln(l);    change(1,n,1,l,l+len-1,k);    exit(true);  end;  if tree[t shl 1].p&gt;=len then dfs:=dfs(l,mid,t shl 1,k,len);  if dfs=true then exit(true);  if tree[t shl 1].r+tree[t shl 1 + 1].l&gt;=len then begin    writeln(mid-tree[t shl 1].r+1);    change(1,n,1,mid-tree[t shl 1].r+1,mid-tree[t shl 1].r+len,k);    exit(true);  end;  if tree[t shl 1 + 1].p&gt;=len then dfs:=dfs(mid+1,r,t shl 1 + 1,k,len);  if dfs=true then exit(true);  if tree[t].r&gt;=len then begin    writeln(r-tree[t].r+1);    change(1,n,1,r-tree[t].r+1,r-tree[t].r+len,k);    exit(true);  end;  exit(false);end;procedure main;var i,x,y,z:longint;begin  for i:=1 to m do begin    read(x);    if x=1 then begin      read(y);      if dfs(1,n,1,1,y)=false then  writeln(&#x27;0&#x27;);    end      else begin        read(y,z);        change(1,n,1,y,y+z-1,2);      end;  end;end;begin  read(n,m);  build_simple(1,n,1);  tree:=tree_simple;  main;end.\n T3 C\n此题其实并不复杂，一看到字符串的循环，立刻就想到 $ KMP $ ，但是…\n我却敲不出 $ KMP $ 的代码，我好弱啊…\n判断循环节方法：\n到第 $ i $ 位时，若 $ i \\ \\ mod \\ \\ (i-next[i])=0 $ 且 $ i \\ \\ div \\ \\ (i-next[i])&gt;1 $ ,则构成循环节。\n 程序\nprogram c;var   s:array[0..1000005]of char;   next:array[0..1000005]of longint;   n:longint;procedure re;var i:longint;    p:ansistring;begin  readln(p);  for i:=1 to n do s[i]:=p[i];end;procedure first;var i,k:longint;begin  i:=0;  k:=-1;  next[0]:=-1;  while i&lt;n do    if (k=-1) or (s[i+1]=s[k+1]) then begin      inc(k);      inc(i);      next[i]:=k;      if (i mod (i-next[i])=0) and (i div (i-next[i])&lt;&gt;1) then writeln(i,&#x27; &#x27;,i div (i-next[i]));    end else k:=next[k];end;begin  readln(n);  re;  first;end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day2","url":"/2019/02/16/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay2/","content":" 2019.2.12\n 长沙集训 $ Day 2 $\n今天的题目真正有了省选难度，要不是第一题是个暴力我就要爆零了…\n这才是大佬们的世界吧…\n\n T1 十字形\n在今天的模拟赛中，这题算非常简单了，最起码是随机数据。\n\n如此将线段分开存储，将 $ a $ 按照 $ len $ 从大到小排序。将 $ b $ 按照 $ p $ 从小到大， $ len $ 从大到小排序。之后枚举 $ a $ ，用二分查找与 $ b $ 的交点，计算答案，在 $ len &lt; 2 \\cdot ans+1 $ 时退出。便可解决此题。\n其实还有更优的解法，可以对 $ ans $ 二分答案，将各线段两端减去 $ ans $ 的长度后，按 $ x $ 坐标枚举竖直线段，用扫描线+线段树进行维护，判断是否有交点。\n T2 集合\n此题与线性基和高斯消元有关，本数学蒟蒻还未能解决，这里先放题解。\n 官方题解\n(1)如果二进制中第 $ i $ 位一共有奇数个 $ 1 $ ,那么这一位一定会给答案增加 $ 2^{i} $ 的贡献，因为奇数个 $ 1 $ 分成两堆，一定有一堆为奇数个，一堆为偶数个。如果二进制中第 $ i $ 位有偶数个 $ 1 $ ,那么我肯定尽量使得两堆都分得奇数个  $ 1 $ ,那么这一位就会对答案贡献 $ 2 \\times 2^{i} $ ,而且肯定是尽量满足高位。这样的话就可以得到 $ 60 $ 个异或方程。\n例如： $ a_{1,1} \\cdot x_1 \\oplus a_{2,1} \\cdot x_2 \\oplus … \\oplus a_{n,1} \\cdot x_n = f_1 $\n$ a_{i,j} $ 表示第 $ i $ 个数的第 $ j $ 位是否为 $ 1 $ , $ \\oplus $ 表示异或，若这一位一共有奇数个 $ 1 $ ,那么\n$ f $ 值为 $ 0 $ ，否则为 $ 1 $\n(2)先考虑和最大，从高位到低位，如果这一位异或和为 $ 1 $ ，和一定是 $ 1 $ ，不用管。否则的话异或和可能是 $ 2 $ 或者 $ 0 $ ，如果可以是 $ 2 $ 的话一定要求是 $ 2 $ 。再考虑 $ x_1 $ 最小。跟上面类似，如果异或和是 $ 1 $ 的话，尽量让 $ x_1 $ 取 $ 0 $ 。关键是如何维护这些限制条件。可以用 $ x_i $ 表示第 $ i $ 个数是否选择，那么每个条件都是形如 $ XOR^{n-1}{i=0} a{i,j} \\cdot x_i =y_j $ 。这样用高斯消元维护一下就可以了，对于每个新方程，如果产生新的主元就加进来。\n 线性基\n线性基是一种贪心的算法。\n用 $ p[i] $ 记录 $ 1 $ 最高位为第i位的数：\n\n$ p[i]=0 $ ，直接记录\n$ p[i]&lt;&gt;0 $ ,将$ x \\ \\ xor \\ \\ p[i] $ ，再继续处理\n\n\nfor t:=62 downto 0 do  if x shr t&lt;&gt;0 then begin    if p[t]=0 then begin p[t]:=x;break; end      else x:=x xor p[t];  end;\n计算答案：\n\n尽量使高位上的 $ 1 $ 更多，这样答案更大\n从高位开始，如果 $ ans \\ \\ xor \\ \\ p[i] $ 更大，则更新 $ ans $\n\nfor i:=62 downto 0 do  if ans xor p[i]&gt;ans then ans:=ans xor p[i];","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day1","url":"/2019/02/15/%E8%AE%B0%E5%BD%95/%E8%AE%AD%E7%BB%83/%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%AD/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-%E9%95%BF%E6%B2%99%E9%9B%86%E8%AE%ADDay1/","content":" 2019.2.11\n 长沙集训 $ Day1 $\n今天是长沙集训的第一天，今天的题目还是比较简单的。\n其实是老师特别出了简单题，照顾我这个蒟蒻！！！\n\n T1完美子串\n这题是普通的模拟，从字符串首开始，将尾指针向后移动。每移动一位就将该位上的字符放入桶中计数。\n如果 $ 26 $ 个字母均已出现，则开始移动头指针，并将头指针处的字符从桶中去除。在所有子串中选择长度最小的作为答案。\n 程序\nprogram str;var   s:array[0..2000005]of char;   sum:array[&#x27;A&#x27;..&#x27;Z&#x27;]of longint;   len,ans:longint;procedure re;var st:ansistring;    i:longint;begin  readln(st);  len:=length(st);  for i:=1 to len do s[i]:=st[i];end;function sc:boolean;var i:char;begin  for i:=&#x27;A&#x27; to &#x27;Z&#x27; do    if sum[i]=0 then exit(false);  exit(true);end;procedure main;var head,tail:longint;begin  ans:=100000000;  head:=0;  tail:=1;  while tail&lt;=len do begin    inc(sum[s[tail]]);    while sc=true do begin      if tail-head&lt;ans then ans:=tail-head;      inc(head);      dec(sum[s[head]]);    end;    inc(tail);  end;  if ans=100000000 then writeln(&#x27;QwQ&#x27;)    else writeln(ans);end;begin  re;  main;end.\n T2游戏\n此题是一道数学题，若不是有 $ CRN $ 巨佬的思路我估计就爆零了…\n假设局游戏的分数是 $ k_{1} \\ \\ k_{2} \\ \\ k_{3} …$\n因为每人的得分只能是 $ k^{2} $ 或 $ k $ ，所以设两人的得分相乘为 $ P $ ， $ P=(k_{1} \\cdot k_{2} \\cdot k_{3} \\cdot … \\cdot k_{n})^{3}$ ,所以 $ \\sqrt[3]{P} $ 一定是一个整数。\n设 $ Q= \\sqrt[3]{P} $ ，两人的得分也一定能被 $ Q $ 整除。\n所以：\n\n$ Q $ 不为整数，输出 $ No $\n两人得分不能被 $ Q $ 整除，输出 $ No $\n$ Q $ 为整数，且两人得分都能被 $ Q $ 整除，输出 $ Yes $\n\n$ Q $ 可以用二分快速求出，记得用 $ int64 $ !!!\n 程序\nprogram game;var   t:longint;function sc(q:int64):int64;var l,r,mid,ans:int64;begin  ans:=-1;  l:=0;  r:=1000001;  while l&lt;=r do begin    mid:=(l+r) shr 1;    if mid*mid*mid=q then begin ans:=mid;break; end;    if mid*mid*mid&lt;q then l:=mid+1      else r:=mid-1;  end;  exit(ans);end;procedure main;var x,y,z:int64;    i:longint;begin  for i:=1 to t do begin    read(x,y);    z:=sc(x*y);       if z=-1 then writeln(&#x27;No&#x27;)      else if (x mod z=0) and (y mod z=0) then writeln(&#x27;Yes&#x27;)        else writeln(&#x27;No&#x27;);  end;end;begin  read(t);  main;end.\n T3泥泞的牧场\n这题是二分图匹配的模板题。\n 二分图\n\n如此，像这种可以分成两份，每一份中的点互不相交的图就是二分图。\n 二分图匹配\n\n如此，连接像这样无公共顶点的两条边，就是一个二分图匹配。\n 最大匹配\n\n最大匹配就是选择尽量多的边，使得选中的边中任意两条边均没有公共点。如果所有的点都是匹配点那就是一个完美匹配。\n上图的最大匹配便是 $ 3 $ 。\n求解二分图匹配的基本算法是匈牙利算法。\n 匈牙利算法\n 增广路\n从一个未匹配的点开始，依次走过未匹配边，匹配边，未匹配边，匹配边… 如果最后的终点是一个未匹配点（即最后一条边是一条未匹配边），那么这条路就是一条增广路。而将增广路上的未匹配边和匹配边进行互换，就会使得匹配边多一条。\n匈牙利算法便是利用增广路进行处理。\n 处理方法\n1.对于一个节点，遍历与其相连的节点，如果可以直接连接，就立即进行连接。\n\n2.继续下一个节点，发现直连节点已被占用。\n\n3.搜索到增广路。\n\n4.依靠增广路进行扩展。\n\n5.非增广路，不进行扩展。\n\n6.无增广路，左侧无空节点，处理结束。\n\n 本题转化\n本题题面虽与二分图无关，但可以通过奇妙的变化，转为二分图匹配问题。\n我们将连续行的 $ * $ 设为左侧图，连续列的 $ * $ 设为右侧图，行列的交点设为在两节点之间连了一条边。\n\n\n之后我们要求出此图的最小顶点覆盖，因为我们在一行&amp;一列放上木板，相当于选取了图中的一个点，覆盖的泥地相当于图中与此顶点相连的边。所以用最少的木板覆盖全部泥地相当于选最少的顶点覆盖全部的边。\n根据二分图特点，最小顶点覆盖=最大匹配，求出该图的最大匹配就是答案。\n 程序\nprogram cover;var   f:array[0..55,0..55]of char;   x,y:array[0..55,0..55]of longint;   p:array[0..505,0..505]of longint;   next,next_f:array[0..505]of longint;   tf:array[0..505,0..505]of boolean;   t:array[0..505]of boolean;   n,m,ans,totx,toty:longint;procedure re;var i,j:longint;    s:string;begin  for i:=0 to 55 do    for j:=0 to 55 do f[i,j]:=&#x27;.&#x27;;  for i:=1 to n do begin    readln(s);    for j:=1 to m do f[i,j]:=s[j];  end;end;procedure cover1(p,q:longint);var i:longint;begin  for i:=q to m do    if f[p,i]=&#x27;*&#x27; then x[p,i]:=totx      else if f[p,i]=&#x27;.&#x27; then break;end;procedure cover2(p,q:longint);var i:longint;begin  for i:=q to n do    if f[i,p]=&#x27;*&#x27; then y[i,p]:=toty      else if f[i,p]=&#x27;.&#x27; then break;end;procedure dfs_first;var i,j:longint;begin  for i:=1 to n do    for j:=1 to m do      if f[i,j]=&#x27;*&#x27; then begin        if f[i,j-1]=&#x27;.&#x27; then begin          inc(totx);          cover1(i,j);        end;        if f[i-1,j]=&#x27;.&#x27; then begin          inc(toty);          cover2(j,i);        end;      end;end;procedure dfs_up;var i,j:longint;begin  for i:=1 to n do    for j:=1 to m do      if tf[x[i,j],y[i,j]]=false then begin        tf[x[i,j],y[i,j]]:=true;        inc(p[x[i,j],0]);        p[x[i,j],p[x[i,j],0]]:=y[i,j];      end;end;function dfs(q:longint):boolean;var i:longint;begin  dfs:=false;  for i:=1 to p[q,0] do    if next_f[q]&lt;&gt;p[q,i] then      if next[p[q,i]]=0 then begin        next[p[q,i]]:=q;        next_f[q]:=p[q,i];        exit(true);      end;  for i:=1 to p[q,0] do    if (next_f[q]&lt;&gt;p[q,i]) and (t[p[q,i]]=false) then begin      t[p[q,i]]:=true;      if dfs(next[p[q,i]])=true then begin        next[p[q,i]]:=q;        next_f[q]:=p[q,i];        exit(true);      end;    end;end;procedure main;var i:longint;begin  ans:=0;  for i:=1 to totx do begin    if dfs(i)=true then inc(ans);    fillchar(t,sizeof(t),false);  end;end;begin  readln(n,m);  re;  dfs_first;  dfs_up;  main;  writeln(ans);end.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"NOIP2018赛后总结","url":"/2018/11/23/%E8%AE%B0%E5%BD%95/%E7%AB%9E%E8%B5%9B/%E6%80%BB%E7%BB%93%E5%BD%92%E7%BA%B3-NOIP2018%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93/","content":" 1.题目难度（个人理解）\n\n 2.考察算法\n暴力枚举\n完全背包\n树上二分\n搜索DFS\n基环树？\n数学（找规律？）\n树上DP\nLCA倍增思想\n动态DP？\n 3.题目分析\n Day1T1.铺设道路（road）\n 考察算法：\n暴力枚举，刷原题\n 解析：\n其实这道题还是很有价值的，如果不是原题的话…\n这题和NOIP2013Day2T1积木大赛一模一样，只是改了题面而已。\n不过对于没做过原题的我，在考场上也是思考了一个多小时…\n其实做法很简单，对于读入的第 iii 块道路，只需比较它和第 i−1i-1i−1 块道路的深度，设 a[i]a[i]a[i] 表示第 iii 块道路的深度， a[i−1]a[i-1]a[i−1] 表示第 i−1i-1i−1 块道路的深度， ansansans 为答案：\n若 a[i−1]≥a[i]a[i-1] \\ge a[i]a[i−1]≥a[i] ,则再填第 i−1i-1i−1 块道路时，第 iii 块道路已经被填过了，所以不用进行任何操作。\n若 a[i−1]&lt;a[i]a[i-1] &lt; a[i]a[i−1]&lt;a[i] ,则在填第 i−1i-1i−1 块道路时，第 iii 块道路还有部分未被填完，此时需要将答案加上两块道路深度的差值，即 ans=ans+a[i]−a[i−1]ans=ans+a[i]-a[i-1]ans=ans+a[i]−a[i−1]\n像这样从头到尾枚举一遍，问题就解决了，最后输出 ansansans ,时间复杂度接近 O(n)O(n)O(n)\n 程序：\nprogram road;var   n,i,t,d:longint;   sum:int64;begin  read(n);  t:=0;  for i:=1 to n do begin    read(d);    if d&gt;t then inc(sum,d-t);    t:=d;  end;  writeln(sum);end.\n Day1T2.货币系统（money）\n 考察算法：\n装满型完全背包\n 解析：\n这题据说也是原题，不过我是不知道原题是啥。\n具体解析和程序点这里\n Day1T3.赛道修建（track）\n 考察算法：\n树上二分，树形DP\n 解析：\n有大佬说这题还是原题！Day1原题大战？\n这题算是很标准的树上二分题目，其实题目说道**“求最短路径的最大长度”**就已经可以明确是二分了，然而我在考场上打 checkcheckcheck 函数打了将近两个小时，结果还炸了，看来以后也得加强编程能力啊！！！\n具体解析和程序点这里\n Day2T1.旅行（travel）\n 考察算法：\n暴力枚举，搜索DFS，基环树？\n 解析：\n 首先对于前 151515 组数据：\n这些数据的处理非常简单，只要从 111 号节点开始，在扩展时优先选择编号小的节点，对树进行一次DFS即可。时间复杂度接近 O(n)O(n)O(n) 。\n 对于所有数据：\n这些数据中，图是一棵基环树，简单的进行一次搜索无法得到正确答案。其实处理方法也很简单，我们先把通过搜索，把图中的环给找到，然后暴力断开环上的每一条边，并在每次断边后的图上进行一次DFS，最后取所有结果中的最优值即可。时间复杂度接近 O(n2)O(n^{2})O(n2) 。\n 程序：\n 期望60分：\nprogram travel;var   l,v:array[0..10005]of longint;   r,path:array[0..5005]of longint;   tf:array[0..5005]of boolean;   n,m,i,x,y,t,k:longint;procedure sc(f,fa:longint);var i,next:longint;begin  while true do begin    next:=100000;    i:=r[f];    while i&lt;&gt;0 do begin      if (tf[v[i]]=false) and (v[i]&lt;next) and (v[i]&lt;&gt;fa) then next:=v[i];      i:=l[i];    end;    if next=100000 then exit;    tf[next]:=true;    inc(k);    path[k]:=next;    sc(next,f);  end;end;begin  read(n,m);  fillchar(r,sizeof(r),0);  fillchar(tf,sizeof(tf),0);  fillchar(l,sizeof(l),0);  fillchar(v,sizeof(v),0);  fillchar(path,sizeof(path),0);  for i:=1 to m do begin    read(x,y);    t:=2*i;    l[t]:=r[x];    r[x]:=t;    v[t]:=y;    l[t-1]:=r[y];    r[y]:=t-1;    v[t-1]:=x;  end;  k:=1;  path[k]:=1;  tf[0]:=true;  sc(1,0);  for i:=1 to k do write(path[i],&#x27; &#x27;);end.\n 期望100分：\nprogram project1;var   r,path,father,son,ans:array[0..5005]of longint;   tf:array[0..5005]of boolean;   l,v:array[0..10005]of longint;   n,m,i,x,y,t,k,p,fat:longint;procedure sc(f,fa:longint);var i,next:longint;begin  while true do begin    next:=100000;    i:=r[f];    while i&lt;&gt;0 do begin      if (v[i]&lt;next) and (v[i]&lt;&gt;fa) and (tf[v[i]]=false) and (v[i]&lt;&gt;0) then next:=v[i];      i:=l[i];    end;    if next=100000 then exit;    tf[next]:=true;    inc(k);    path[k]:=next;    sc(next,f);  end;end;function min:boolean;var i:longint;begin  for i:=1 to n do    if ans[i]&gt;path[i] then exit(true)      else if ans[i]&lt;path[i] then exit(false);  exit(false);end;function del(f,fa:longint):boolean;var i:longint;begin  del:=false;  i:=r[f];  while i&lt;&gt;0 do begin    if v[i]&lt;&gt;fa then begin      if father[v[i]]=0 then father[v[i]]:=f        else begin          p:=v[i];          fat:=father[v[i]];          father[v[i]]:=f;          son[f]:=v[i];          exit(true);        end;      if del(v[i],f)=true then begin        son[f]:=v[i];        exit(true)      end;    end;    i:=l[i];  end;end;procedure cut(x,y:longint);var i,j:longint;begin  i:=r[x];  while i&lt;&gt;0 do begin    if v[i]=y then begin      v[i]:=0;      if i mod 2=0 then j:=i-1 else j:=i+1;      v[j]:=0;      fillchar(tf,sizeof(tf),0);      fillchar(path,sizeof(path),0);      k:=1;      path[k]:=1;      sc(1,0);      if min=true then ans:=path;      v[i]:=y;      v[j]:=x;      exit;    end;    i:=l[i];  end;end;procedure point(p:longint);var i:longint;begin  i:=p;  cut(i,son[i]);  i:=son[i];  while i&lt;&gt;p do begin    cut(i,son[i]);    i:=son[i];  end;end;begin  read(n,m);  fillchar(tf,sizeof(tf),0);  fillchar(path,sizeof(path),0);  fillchar(ans,sizeof(ans),$5f);  k:=0;  for i:=1 to m do begin    read(x,y);    t:=i*2;    l[t]:=r[x];    r[x]:=t;    v[t]:=y;    l[t-1]:=r[y];    r[y]:=t-1;    v[t-1]:=x;  end;  inc(k);  path[k]:=1;  father[1]:=1;  if m=n then begin    del(1,0);    point(p);  end  else begin sc(1,0);ans:=path; end;  for i:=1 to n do write(ans[i],&#x27; &#x27;);end.\n 此题还有更优的 O(nlog⁡n)O(n \\log n)O(nlogn) 算法：具体解析和程序点这里\n Day2T2.填数游戏（game）\n 考察算法：\n数学推导，找规律？\n 解析：\n说实话，我在考场上真没想到这题能找规律，我一直以为这是一个状压DP。后来经过大佬指点，才发现其实是能通过找规律AC的。但这题究竟标算是什么，我到现在也不了解，毕竟NOIP不会出一道打表找规律的题吧?而且这题不管是手摸，还是打表，想发现规律都异常困难，如果真考找规律，这题也是十分毒瘤了！\n具体解析和程序点这里\n Day2T3.保卫王国（defense）\n 考察算法：\n树上DP，LCA倍增思想，动态DP？\n 解析：\n在考场上，我只想出了44分的暴力算法\n考后听说是动态DP模板，可动态DP是NOI的考察内容啊！如果这题考动态DP，那超纲也太严重了吧。一定还有别的做法，在考后我经过反复思考，结合大佬的提示，终于发现了用LCA倍增思想解决问题的方法。\n具体解析和程序点这里\n","categories":["记录","竞赛"],"tags":["Pascal"]}]