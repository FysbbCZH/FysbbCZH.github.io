[{"title":"CCSP2023游记","url":"/posts/a7530484.html","content":"上次写竞赛游记还是高二呢，但和高中时偏向竞赛总结一样的“游记”不同，这真的是一篇游记了。因为这次参赛过程真的就是在旅行中度过的（笑），不过文章里还是有很多对参赛的帮助的，各位想参加CSP和CCSP的朋友也可以认真看看，相信也能有不少收获。\n 一次随意参加的CSP认证\n高中时有幸参加了最后一次NOIP2018，当时因为三道题爆零导致差5分而没拿到省一，等到第二年NOIP就被取消了，而是改成了CSP-J/S认证（都是CCF为了收钱啊），OIer中很多人都说“CSP认证多水啊，以后信竞还有没有含金量啊”。但我到大学大一参加CSP认证的时候，发现题目其实并不是多么简单，从T1到T5那是真的普及到省选的跨越，最后我也只拿了300分，刚刚摸到及格线了算是。\n之后因为疫情、封校等原因，CSP认证也没有正常展开过几次，等到大三下终于恢复正常，团报的名额异常火热，稍微晚点就抢不到，而没有团报要300块钱（CCF你搞认证就是为了收钱吧）。所以直到大四上，也就是刚刚9月份这次，我才终于又参加了第二次CSP认证考试。这次报名前，班上一个大佬还问我：“你不都参加过一次了，再说现在参加这个又有什么作用呢？”是啊，好像也并没有什么作用，但可能就是为了给我的算法竞赛之路画上一个句号吧，我还是参加了这次认证，但也正是如此，才有了之后更多的精彩。\n 入选校队和赛前准备\n这次CSP认证出乎意料的顺利，T1和T2都是简单的前缀和，T3是个大模拟。而在区分度较大的最后两题，T4是一个数据结构，我并没有什么思路，当时已经只剩40分钟，就在我以为这次又得300分结束的时候，我发现T5和NOIP2018的保卫王国几乎如出一辙，一样的树上DP，一样的单点修改，甚至连子任务分布都极为相似，所以我当场断定，这题一定是动态DP，虽然写不了正解，但是凭借记忆，我还是很快完成了60分的子任务，最终凭借着本次CSP的360分，我被学校CCSP队伍选中，获得了参加CCSP2023的资格。\n入队以后，我们每个成员负责分析一道CCSP历年题目，并完成报告。我负责研究CCSP2021的抽卡（题解点这），但其实我并没有花很多时间在研究题目上，因为当时正好是中秋国庆假期，我已经回老家了。而且还先后去了曲阜、济南、泰山、蚌埠游玩（所以我说是真的游记嘛），我是在从济南回家以后，中途休息了三天，正好完成了题解，7号晚上在线上会议讲完题，第二天就又和哥哥去爬泰山了。下山后又去我哥学校逛了几天，正好他宿舍室友不在，我就拿他室友卡伪装成学生进去，住他寝室里，成功省了一笔住宿费。等回学校已经18号了，离比赛也没几天，剩下的时间我就把历年题的标程在Ubuntu下调了调，熟悉下环境。我并没有去动手写更多的代码，其实也有一个原因是CCSP的题目大多难度不高，但是解题过程非常繁琐，所以我也建议大家在研究历年题时不要将过多的精力放在实现上，而是搞懂思路和流程就好。(这里放几张旅游照片，泰山还是很壮丽啊)\n\n    \n    上 · 泰山日出\n    下 · 泰安夜景\n    \n    右\n    ·\n    蚌\n    埠\n    栖\n    岩\n    寺\n    \n\n Day0\n其实CCSP并没有Day0的概念，既没有热身赛，也不能提前试机，甚至连在考场门口拍照都不行，提前到达只是说为了养足精神。我们是中午从学校出发，下午四点到沈阳宾馆。接着去考场签到，顺便看考场，这时候就隐约感觉不妙，因为考场并不是想象中的大机房，而是一个类似会议室的房间，在里面摆了六七张大圆桌，每个桌子用隔板分成八份，各摆上一个笔记本。这环境可以说烂到爆了，人家蓝桥杯都是在机房，CCF收了这么多钱（CCSP报名费500）还搞这种比赛环境，也是真的难绷。\n\n    \n    \n\n晚上教练请我们吃了铁锅炖，不得不说东北的大杂烩还是挺好吃的。\n CCSP特色1-携带电子资料\n回宾馆以后继续准备资料，这里就要提到CCSP很有趣的一点了，NOIP就跟高考一样什么都不给带，需要选手自己或理解或硬背的记忆模板，ACM则允许带纸质资料，减轻了记忆难度，而CCSP更进一步，直接允许带硬盘拷贝代码，并且比赛过程中硬盘可以一直插在电脑上，可以说完全没有死记硬背的要求。这其实挺好的，毕竟实际开发中也有那么多“Ctrl+C/V”的，花精力去背经典模板也没有什么必要。\n Day1\n 试机\nCCF设计的流程很捞，正式赛9点开始，8：00-9：00是试机时间，就是说提前一天试机不好吗。\n真上手摸到电脑，发现之前的担忧果然没错，比赛电脑是联想的T480（具体是哪一款分不清），我也不多说什么，就简单列几个特点：\n\n720P高清显示屏\n87键包浆键盘\n一键起飞的散热引擎\n\n除去这些外表上的落后，实际使用的细节更是拉跨，首先是fn键正好和Ctrl反转位置，导致我总是在保存的时候按倒fn，它“fn+S”的快捷键还是截屏，比赛结束我看图片目录下面得截了90多张图。然后就是缩小的方向键，左右键的上方还是“page up/down”，每次按方向键都可能误触，然后就给我疯狂翻页。最最难绷的还是那个触摸板，它接触不良到就算我的手不碰电脑，鼠标都会在那一直乱窜，必须要使劲按几下触摸板才能解决，关键是我还找不到怎么把触摸板关掉，甚至后来都严重到要使劲锤触摸板才能让鼠标稍微乖巧一点。\n上面还只是硬件，软件上提供了VSCode，看起来还不错，但是当我打开设置界面想调整一下，才发现设置全是空的，整个界面没有一个字母或图标，就算在搜索框搜索也找不到任何设置。后来还好找到了“settings.json”，凭借着记忆和自动补全直接编辑，把字体、格式化、自动保存等功能都打开了，不然就这破电脑加上白板VSC，还不知道得多难受。\n\n    \n    中间那个红色的就是我ヾ(≧▽≦*)o\n\n CCSP特色2-超长比赛时间\n这时候就要说一下CCSP的另一个特色了，就是远超大多数算法竞赛的比赛时间，CCSP要从早上9点持续到晚上9点，整整12个小时，期间CCF会负责提供中饭和晚饭，期间选手可以多次提交评测（每题最多32次），取最高分为最终成绩，最后两个小时封榜。\n T1\n开始后首先看T1（我就不写题目和题解了，想了解的看我校大佬的博客），题面非常啰嗦，但其实就是一个大暴力，依次枚举每个交换要不要做，每个礼包要不要买，再计算价值取个最小的就行。程序写好以后一发提交，结果95分！？接着开始调试，硬是调了40分钟也没找到问题。这总不能在一颗树上吊死，于是开始看下一题。\nT2题面倒是挺简洁，当时隔壁的两位已经在研究T2了，我当时用余光瞥见他们草稿打的飞快，特别是左边那一位都用了两张草稿纸，上面写满了组合数，让我以为这是什么非常复杂的计数问题，想想NOIP2018的填数游戏，当时觉得还是不浪费时间了，于是打了30分暴力就先扔了。\n T3\n然后开始看T3，当时一看到那个“波动最大值的最小化”，我便立刻确定这题是二分答案，为什么呢？请看下图\n\n    \n    因为对此一无所知，导致此题得分很低，当年差5分痛失省一\n    \n\n确定了二分以后，开始思考check方法，题目里那个“波动最大值”其实就是最长子序列问题，所以我猜就是每当最长子序列在哪个位置超了，就倒着往前依次给每个位置减D。这就体现出CCSP的好了，也不用管对不对，先打了再说，打完最暴力的程序，交上去成功10分，证明猜想没错。然后就是优化了，因为每个位置最多减一次D，可以套个并查集，拿20分，然后发现减D操作能差分维护，可以用树状数组，我直接从带的模板里掏了个封装好的代码粘上去，减去了手打数据结构的麻烦（所以说CCSP的赛制真的太舒服了）。优化完拿了40分，这咋才这么点？然后尝试了各种奇异的方法，提交次数都用了20多次，终于发现，减完D以后更新前缀和可以直接在单调队列里维护，加上这个操作，直接变成了80分，算是把O(nlog⁡2n)O(n \\log^2 n)O(nlog2n)的分全拿满了。最后20分应该是类似DP的做法了，因为已经3点多了，感觉继续熬T3不值得，就直接把这20分弃了。\n T2\n看了一下榜，发现T3大部分都是拿10分20分的，而T2很多都AC了，那说明T2难度并不大。于是又回头看T2，觉得可以直接用组合数学硬推，然后就从第二个子任务开始，依次推导每种情况的式子。出乎意料的是，我这次居然没画图也没打表，纯靠推把几种情况都搞出来了。大概一个多小时就把T2正解搞出来了，拿了95分，有个点超时，后来用记忆化的方式优化一下就行了。\n\n    \n        \n        \n    \n    整场比赛我就打了这么点草稿\n\n CCSP特色3-系统设计题\n这是CCSP和其他算法竞赛最大的差别，系统设计题并不考察高难度算法，而更像是去实现一个具体的项目，并且评分也和算法题不同，采用了“竞速”的评分方式，除了10分基础分外，另外90分需要和其他选手比拼程序运行的速度，并按照比例得分，只有最快的选手才能获得满分。（CCSP2023没有采用竞速评分）\n T4\n说到大模拟，搞NOIP的应该看过猪国杀，算是OI里模拟题的极致，我记得当时机房里很多同学都说等退役了要A了体验体验。或许还有人看过未来程序·改，不知道有没有人敢挑战，反正当时机房里每个人都对它望而却步。\n这次的第四题，比“未来程序·改”还要复杂。平常的编程中，有各种变量类型，我们还会定义数组、结构体、联合来简化变成难度，而每个类型的长度都是不同的，将不同长度的变量装在结构体里，在分配内存的时候，就必须面对内存空间占用大小的计算，以及内存空间对齐的问题，第四题给出了一种定义变量的方式，要求写一个编译器，去完成对内存空间的分配。\n编译原理课设可是写了两周才完成，考场上这点时间还写个毛。（清华大佬这题拿了51分，也是真的神）\n T5\n搞完T2时间已经到了五点钟，我才开始看T5，这题也不是什么善茬，起码在篇幅上直接占了一半，有19页长。\n这题研究起来不像是个OI题，倒像是个阅读理解，需要在巨长的文章中找到与答案相关那几个点，最开篇出题人花了5页给我们科普了流处理系统的工作方式，其中唯一有用的就是时间窗口和watermark这个概念。别看说了这么多，其实也很简单：\n\n时间窗口：一个统计的区间，每个到达的事件会被放到对应的区间里统计，出题人已经给出了分配区间的函数，我们只要调用即可\nwatermark：一个时间标记，时间早于watermark标记的事件会被丢弃\n\n 任务一子任务一\n前面5页纸其实就是要分析出这点东西，然后就是任务一，要我们根据事件的到达时间，生成watermark标记，具体的生成方式题目已经给了，我们其实就只要确定时间就行。这里其实题目描述的很迷惑，但我分析了样例，觉得它就是每十个事件取最大值，再减60秒就行。既然有了想法，肯定要先试试，反正就几行代码，然后成功拿下任务一。\n 任务一子任务二\n有了子任务一的积累，子任务二更加简单，就是流从一个变成了两个，我们要按要求取两个流中最小的那个，再判断能不能输出，这样看不就是几个if的事。事实也确实如此，子任务二轻松解决。\n 任务二\n任务二要求对流中的事件和watermark进行区分，事件按时间窗口存储到内存，遇到watermark则将存储的数据输出，也就是个普及组小模拟的水平，搞map嵌套就行（题目里也贴心的提示了）\n 任务三\n任务三开始，出题人又细心的给我们科普了容错机制的内容，但归根到底，任务三和任务二基本是一样的，只不过是输出的时机不同，并且是输出到文件。这里就很有趣了，一个在线评测的OJ，居然还要文件读写，而且还是有的数据输出到标准输出，有的数据输出到文件。大家搞OI的时候经常用freopen，但是这改变了stdout，等输出完文件，你还会改回来吗？反正我不会，但还好在各类课设中我学会了多种文件读写方式，最终用fopen和fprintf解决了问题。\n 比赛结束\n至此CCSP的比赛就全部结束了，整体上说除了电脑太烂，体验都还不错，部分分也很足，最后我是95+100+80+0+100=375分，整场比赛我都在金线上下徘徊，也不知道最终如何？\n还有就是CCF虽然提供中晚餐，但那个盒饭实在是垃圾，如果各位谁体会过疫情封寝，那肯定会记得那时候盒饭的味道。我当时中午吃完，下午就感到恶心，晚上正好肝T5索性就没吃，结果回宾馆还是吐了一堆，也不知道是饭的问题，还是我泡的咖啡的问题。总之如果各位参加CCSP比赛，还是带点面包和压缩饼干吃吧。\n CNCC（Day2）\n参加CCSP可以免费参加CNCC大会，并且可以免费乘坐地铁，还有沈阳故宫等景点可以免费参观，可以说是非常赚了。上午签完到，我也没听报告，直接去景点转了一圈。不得不说沈阳故宫是真的小，建筑也不算豪华，旁边的张学良旧居比它要壮丽多了。\n\n    \n        \n        \n    \n    左边是沈阳故宫大政殿，右边是张学良旧居的大青楼（这名字挺奇怪蛤）\n    \n\n下午是CCSP颁奖，我居然还蹭线拿了金奖，校队成绩也挺好，两金四银，排名第七，应该算是几次CCSP最好的吧。\n 后记\n这应该是我最后一次认真准备和参加的算法竞赛了，大学里，我在算法竞赛方面也并没有什么更加深入的研究，虽然参加ACM，但也没有真的去学更多的内容，仅仅是跟着训练，几场正赛也没有什么成绩。我对算法竞赛投入最多的还得是高中了，几乎所有的知识都是那时候学的，我博客中在“竞赛”分类下的另一篇文章也是NOIP2018的赛后总结，我在本篇文章中也多次提到NOIP2018的题目，确实也是那次比赛对我影响最大，也是我研究最透彻的一次比赛。我之后的很多学习方向，都是以那次比赛为基础的。也正是如此才让我这次CCSP能如此顺利，对“保卫王国”的研究，让我在CSP认证中能拿到关键的60分，获得参加CCSP的资格；“赛道修建”不会二分的失败，让我对二分答案的特色铭记于心，才能在这次比赛中立刻确定T3的算法；“填数游戏”那恶心的计数DP，促使我更多的研究DP和组合数，我才能在第二题不画图的情况下迅速推导出正解。这次CCSP，对我来说并不是ACM的替代，而是一次NOIP的延续，NOIP的三个问题让我差5分失去省一，这次则是让我以5分的优势拿到金奖，也算是真正走到了终点了。\n","categories":["记录","竞赛"],"tags":["竞赛","CCSP"]},{"title":"CCSP2021T2抽卡题解","url":"/posts/53500.html","content":" 1.同时记录SSR和SR数量 O(n3m)O(n^3m)O(n3m)\n使用 dp[t][SSR][SR]dp[t][SSR][SR]dp[t][SSR][SR] 维护手中已经有 ttt 种SSR时的期望，后二维用于记录SSR和SR卡的数量，用于计算答案。\ndp[0][0][0]=∑SSR=2N∑SR=0N−SSRdp[2][SSR][SR]×pi3dp[0][0][0]=\\sum \\limits_{SSR=2}^N \\sum \\limits_{SR=0}^{N-SSR}{dp[2][SSR][SR] \\times \\frac{p_i}{3}}dp[0][0][0]=SSR=2∑N​SR=0∑N−SSR​dp[2][SSR][SR]×3pi​​\ndp[0][0][SR]=∑{dp[0][0][SR−1]×qiSRdp[0][0][SR]×(1−qi−pi)Rdp[0][0][SR]=\\sum\\begin{cases}dp[0][0][SR-1] \\times q_i  &amp;\\text{SR}\\\\ dp[0][0][SR] \\times (1-q_i-p_i) &amp;\\text{R}\\end{cases}dp[0][0][SR]=∑{dp[0][0][SR−1]×qi​dp[0][0][SR]×(1−qi​−pi​)​SRR​\ndp[1][SSR][SR]=∑{dp[0][SSR−1][SR]×pi新SSRdp[1][SSR−1][SR]×pi3已有SSRdp[1][SSR][SR−1]×qiSRdp[1][SSR][SR]×(1−qi−pi)Rdp[1][SSR][SR]=\\sum\\begin{cases}dp[0][SSR-1][SR] \\times p_i &amp;\\text{新SSR} \\\\ dp[1][SSR-1][SR] \\times \\frac{p_i}{3} &amp;\\text{已有SSR}\\\\ dp[1][SSR][SR-1] \\times q_i &amp;\\text{SR}\\\\ dp[1][SSR][SR] \\times (1-q_i-p_i) &amp;\\text{R}\\end{cases}dp[1][SSR][SR]=∑⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​dp[0][SSR−1][SR]×pi​dp[1][SSR−1][SR]×3pi​​dp[1][SSR][SR−1]×qi​dp[1][SSR][SR]×(1−qi​−pi​)​新SSR已有SSRSRR​\ndp[2][SSR][SR]=∑{dp[1][SSR−1][SR]×2pi3新SSRdp[2][SSR−1][SR]×2pi3已有SSRdp[2][SSR][SR−1]×qiSRdp[2][SSR][SR]×(1−qi−pi)Rdp[2][SSR][SR]=\\sum\\begin{cases}dp[1][SSR-1][SR] \\times \\frac{2p_i}{3} &amp;\\text{新SSR} \\\\ dp[2][SSR-1][SR] \\times \\frac{2p_i}{3} &amp;\\text{已有SSR}\\\\ dp[2][SSR][SR-1] \\times q_i &amp;\\text{SR}\\\\ dp[2][SSR][SR] \\times (1-q_i-p_i) &amp;\\text{R}\\end{cases}dp[2][SSR][SR]=∑⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​dp[1][SSR−1][SR]×32pi​​dp[2][SSR−1][SR]×32pi​​dp[2][SSR][SR−1]×qi​dp[2][SSR][SR]×(1−qi​−pi​)​新SSR已有SSRSRR​\n 2.仅记录SSR数量，同时维护SR贡献 O(n2m)O(n^2m)O(n2m)\n用 dp[t][SSR]dp[t][SSR]dp[t][SSR] 维护有 ttt 种SSR时的期望，同时用 dpSR[t][SSR]dpSR[t][SSR]dpSR[t][SSR] 维护SR卡对答案的贡献。\ndp[0][0]=∑SSR=2Ndp[2][SSR]×pi3dp[0][0]=\\sum \\limits_{SSR=2}^N{dp[2][SSR] \\times \\frac{p_i}{3}}dp[0][0]=SSR=2∑N​dp[2][SSR]×3pi​​\ndp[1][SSR]=∑{dp[0][SSR−1]×pi新SSRdp[1][SSR−1]×pi3已有SSRdp[1][SSR]×(1−pi)SR和Rdp[1][SSR]=\\sum\\begin{cases}dp[0][SSR-1] \\times p_i &amp;\\text{新SSR} \\\\ dp[1][SSR-1] \\times \\frac{p_i}{3} &amp;\\text{已有SSR}\\\\ dp[1][SSR] \\times (1-p_i) &amp;\\text{SR和R}\\end{cases}dp[1][SSR]=∑⎩⎪⎪⎨⎪⎪⎧​dp[0][SSR−1]×pi​dp[1][SSR−1]×3pi​​dp[1][SSR]×(1−pi​)​新SSR已有SSRSR和R​\ndp[2][SSR]=∑{dp[1][SSR−1]×2pi3新SSRdp[2][SSR−1]×2pi3已有SSRdp[2][SSR]×(1−pi)SR和Rdp[2][SSR]=\\sum\\begin{cases}dp[1][SSR-1] \\times \\frac{2p_i}{3} &amp;\\text{新SSR} \\\\ dp[2][SSR-1] \\times \\frac{2p_i}{3} &amp;\\text{已有SSR}\\\\ dp[2][SSR] \\times (1-p_i) &amp;\\text{SR和R}\\end{cases}dp[2][SSR]=∑⎩⎪⎪⎨⎪⎪⎧​dp[1][SSR−1]×32pi​​dp[2][SSR−1]×32pi​​dp[2][SSR]×(1−pi​)​新SSR已有SSRSR和R​\ndpSR[t][SSR]=∑{dpSR[t−1][SSR−1]×(3−t+1)pi3新SSRdpSR[t][SSR−1]×t⋅pi3已有SSRdp[t][SSR]×qiSRdpSR[t][SSR]×(1−qi−pi)RdpSR[t][SSR]=\\sum\\begin{cases}dpSR[t-1][SSR-1] \\times \\frac{(3-t+1)p_i}{3} &amp;\\text{新SSR} \\\\ dpSR[t][SSR-1] \\times \\frac{t \\cdot p_i}{3} &amp;\\text{已有SSR}\\\\ dp[t][SSR] \\times q_i &amp;\\text{SR}\\\\ dpSR[t][SSR] \\times (1-q_i-p_i) &amp;\\text{R}\\end{cases}dpSR[t][SSR]=∑⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​dpSR[t−1][SSR−1]×3(3−t+1)pi​​dpSR[t][SSR−1]×3t⋅pi​​dp[t][SSR]×qi​dpSR[t][SSR]×(1−qi​−pi​)​新SSR已有SSRSRR​\n 3.不记录卡的数量，只维护贡献 O(nm)O(nm)O(nm)\n不再记录SSR的数量，而是直接维护其对答案的贡献，每当SSR数量增加一，E((K+1)2)=E(K2)+E(2K)+E(1)E((K+1)^2)=E(K^2)+E(2K)+E(1)E((K+1)2)=E(K2)+E(2K)+E(1)，所以要同时维护右边的三个期望。\n用 dp[t]dp[t]dp[t] 维护有 ttt 种SSR时的期望，dpSR[t]dpSR[t]dpSR[t] 维护SR卡的贡献，对于SSR卡的贡献，用 dpSSR1[t]dpSSR1[t]dpSSR1[t] 维护 E(2K)E(2K)E(2K) 的期望，dpSSR2[t]dpSSR2[t]dpSSR2[t] 维护 E(K2)E(K^2)E(K2) 的期望。\ndp[0]=∑{dp[0]×(1−pi)SR和Rdp[2]×pi3新SSRdp[0]=\\sum\\begin{cases}dp[0] \\times (1-p_i) &amp;\\text{SR和R} \\\\ dp[2] \\times \\frac{p_i}{3} &amp;\\text{新SSR}\\end{cases}dp[0]=∑{dp[0]×(1−pi​)dp[2]×3pi​​​SR和R新SSR​\ndp[1]=∑{dp[0]×pi新SSRdp[1]×pi3已有SSRdp[1]×(1−pi)SR和Rdp[1]=\\sum\\begin{cases}dp[0] \\times p_i &amp;\\text{新SSR} \\\\ dp[1] \\times \\frac{p_i}{3} &amp;\\text{已有SSR}\\\\ dp[1] \\times (1-p_i) &amp;\\text{SR和R}\\end{cases}dp[1]=∑⎩⎪⎪⎨⎪⎪⎧​dp[0]×pi​dp[1]×3pi​​dp[1]×(1−pi​)​新SSR已有SSRSR和R​\ndp[2]=∑{dp[1]×2pi3新SSRdp[2]×2pi3已有SSRdp[2]×(1−pi)SR和Rdp[2]=\\sum\\begin{cases}dp[1] \\times \\frac{2p_i}{3} &amp;\\text{新SSR} \\\\ dp[2] \\times \\frac{2p_i}{3} &amp;\\text{已有SSR}\\\\ dp[2] \\times (1-p_i) &amp;\\text{SR和R}\\end{cases}dp[2]=∑⎩⎪⎪⎨⎪⎪⎧​dp[1]×32pi​​dp[2]×32pi​​dp[2]×(1−pi​)​新SSR已有SSRSR和R​\ndpSR[t]=∑{dpSR[t−1]×(3−t+1)pi3新SSRdpSR[t]×(1−t⋅pi3)已有SSR和Rdp[t]×qiSRdpSR[t]=\\sum\\begin{cases}dpSR[t-1] \\times \\frac{(3-t+1)p_i}{3} &amp;\\text{新SSR} \\\\ dpSR[t] \\times (1-\\frac{t \\cdot p_i}{3}) &amp;\\text{已有SSR和R}\\\\ dp[t] \\times q_i &amp;\\text{SR}\\end{cases}dpSR[t]=∑⎩⎪⎪⎨⎪⎪⎧​dpSR[t−1]×3(3−t+1)pi​​dpSR[t]×(1−3t⋅pi​​)dp[t]×qi​​新SSR已有SSR和RSR​\ndpSRR1[t]=∑{(dpSRR1[t−1]+2dp[t−1])×(3−t+1)pi3新SSR(dpSRR1[t]+2dp[t])×t⋅pi3已有SSRdpSSR1[t]×(1−pi)SR和RdpSRR1[t]=\\sum\\begin{cases}(dpSRR1[t-1]+2dp[t-1]) \\times \\frac{(3-t+1)p_i}{3} &amp;\\text{新SSR} \\\\ (dpSRR1[t]+2dp[t]) \\times \\frac{t \\cdot p_i}{3} &amp;\\text{已有SSR}\\\\ dpSSR1[t] \\times (1-p_i) &amp;\\text{SR和R}\\end{cases}dpSRR1[t]=∑⎩⎪⎪⎨⎪⎪⎧​(dpSRR1[t−1]+2dp[t−1])×3(3−t+1)pi​​(dpSRR1[t]+2dp[t])×3t⋅pi​​dpSSR1[t]×(1−pi​)​新SSR已有SSRSR和R​\ndpSRR2[t]=∑{(dpSRR2[t−1]+dpSSR1[t−1]+dp[t−1])×(3−t+1)pi3新SSR(dpSRR2[t]+dpSSR1[t]+dp[t])×t⋅pi3已有SSRdpSSR2[t]×(1−pi)SR和RdpSRR2[t]=\\sum\\begin{cases}(dpSRR2[t-1]+dpSSR1[t-1]+dp[t-1]) \\times \\frac{(3-t+1)p_i}{3} &amp;\\text{新SSR} \\\\ (dpSRR2[t]+dpSSR1[t]+dp[t]) \\times \\frac{t \\cdot p_i}{3} &amp;\\text{已有SSR}\\\\ dpSSR2[t] \\times (1-p_i) &amp;\\text{SR和R}\\end{cases}dpSRR2[t]=∑⎩⎪⎪⎨⎪⎪⎧​(dpSRR2[t−1]+dpSSR1[t−1]+dp[t−1])×3(3−t+1)pi​​(dpSRR2[t]+dpSSR1[t]+dp[t])×3t⋅pi​​dpSSR2[t]×(1−pi​)​新SSR已有SSRSR和R​\nans=∑{ans答案自身累加(dpSRR2[2]+dpSSR1[2]+dpSR[2]+dp[2])×pi3新SSRans=\\sum\\begin{cases}ans &amp;\\text{答案自身累加} \\\\ (dpSRR2[2]+dpSSR1[2]+dpSR[2]+dp[2]) \\times \\frac{p_i}{3} &amp;\\text{新SSR}\\end{cases}ans=∑{ans(dpSRR2[2]+dpSSR1[2]+dpSR[2]+dp[2])×3pi​​​答案自身累加新SSR​\n 4.利用矩阵乘法进行维护 O(n+m)O(n+m)O(n+m)\n将上一步当中的状态转移改为矩阵形式，除去 dpSSR1[0],dpSSR2[0]dpSSR1[0],dpSSR2[0]dpSSR1[0],dpSSR2[0] 两个恒为0的状态，共有11个状态，成为秩为11的矩阵。\n最终动态规划过程为 S×A1×A2×⋯×An×TS \\times A_1 \\times A_2 \\times \\cdots \\times A_n \\times TS×A1​×A2​×⋯×An​×T，其中 SSS 为第一个元素为1其余为零的行向量，TTT 为最后一个元素为1其余为零的列向量，AiA_iAi​ 是根据转移方程和对应 pi,qip_i,q_ipi​,qi​ 得到的矩阵。因为矩阵乘法的结合律，只要先预处理出 SL[i],SR[i]SL[i],SR[i]SL[i],SR[i] ，表示从 S×A1×⋯×AiS \\times A_1 \\times \\cdots \\times A_iS×A1​×⋯×Ai​ 和 Ai×⋯×An×TA_i \\times \\cdots \\times A_n \\times TAi​×⋯×An​×T 的向量，当询问更改第 ttt 次抽卡的概率，只要计算 SL[t−1]×At′×SR[t+1]SL[t-1] \\times A_t^{&#x27;} \\times SR[t+1]SL[t−1]×At′​×SR[t+1] 即可。\n如果用直接用矩阵相乘，复杂度为 11311^3113 ，因为状态可以直接用向量表示，所以直接维护向量乘积。\n","categories":["题解","杂题整理"],"tags":["CCSP","动态规划","概率论","矩阵加速"]},{"title":"红黑树学习记录","url":"/posts/43886.html","content":" 红黑树性质\n红黑树和基本 AVLAVLAVL 不同，不需要频繁进行高度平衡判断，而是使用黑节点的个数，对树型进行维护。\n具有以下性质：\n\n每个节点只能是黑、红两种颜色的一种\n根节点一定为黑色，外节点看作黑色\n不能有两个相连的节点同为红色\n\n从根到任何一个外节点的路径上，黑色节点个数相同\n\n\n其中 444 性质最为重要，对红黑树的插入、删除更新，都是为满足其性质进行的。\n 插入\n首先需要明确，新插入一个节点时，应该是什么颜色。\n考虑如果是黑色，那新节点插入的路径上，黑色个数增加，显然需要向上进行调整，以确保 444 性质的成立，这就增加了额外的操作。\n所以新增加的节点，颜色应为红色。\n为解释方便，插入部分各节点关系如下：\n\n\n\n其中，000 表示左子树，111 表示右子树。\nNoNoNo 为插入的节点，插入时，按照普通二叉查找树的方式进行插入，待新节点插入到位后，再按照以下情况进行调整。\n处理过程中，要特别注意对根节点的处理。\n这里主要讲解插入节点为左子树的情况，右子树的处理就是其镜像变换，可以通过代码简单描述。\n 1.0 father为黑\n显然，插入后的树满足所有的性质，无需进行更新。\n 1.1 father、uncle为红\n此时，将 fa,unclefa,unclefa,uncle 变为黑色，ffaffaffa 变为红色。但这种处理可能导致 ffaffaffa 出现双红冲突，所以需要继续对 ffaffaffa 进行处理（此时 ffaffaffa 相当于 NoNoNo）。\n\n\n\n 1.2 father为红，uncle为黑\n需注意，uncleuncleuncle 为外节点的话，颜色也是黑色。\n 1.2.1 fa、No不在同一方向\n将 NoNoNo 左旋，变为 1.2.21.2.21.2.2 所属情况，同时待处理的节点变为 fafafa 。\n\n\n\n 1.2.2 fa、No在同一方向\n将 fafafa 右旋，同时 fa,ffafa,ffafa,ffa 颜色互换。\n\n\n\n 删除\n红黑树的删除较为复杂，需针对多种情况进行处理。\n此部分的节点关系如下：\n\n\n\n其中 NoNoNo 为待删除的节点。\n 2.0 No有两个子树\n处理方式同二叉查找树，先将 NoNoNo 和后继 ppp 交换，然后再进行删除。之后情况便转换为 2.1、2.2、2.32.1、2.2、2.32.1、2.2、2.3 其中之一。\n\n\n\n 2.1 No为红色叶节点\n直接将 NoNoNo 删去即可，并不会影响树的性质，此处 fafafa 为白色，表示其颜色无需考虑（之后同理）。\n\n\n\n 2.2 No为黑色，且只有一个子树\n此时 NoNoNo 唯一的一个子节点一定是红色，将 NoNoNo 删除后，用 fafafa 连接到其子节点，并将子节点颜色改为黑色。\n\n\n\n 2.3 No为黑色叶节点\n 2.3.1 br为红色\n将 brbrbr 左旋，同时 br,fabr,fabr,fa 颜色互换。之后继续在调整后的树上，对 NoNoNo 进行调整。\n\n\n\n 2.3.2 br为黑，远侄子为黑，近侄子为红\n此时远侄子一定是外节点，将 blsblsbls 右旋，同时 br,blsbr,blsbr,bls 颜色互换，情况变为 2.3.32.3.32.3.3 ，之后继续在调整后的树上，对 NoNoNo 进行调整。\n\n\n\n 2.3.3 br为黑，远侄子为红\n将 brbrbr 左旋，同时 br,fabr,fabr,fa 颜色互换，brsbrsbrs 变为黑色，删除 NoNoNo 后，fafafa 左儿子为空。\n\n\n\n 2.3.4 fa为红，br为黑叶子\nnls,nrs,bls,brsnls,nrs,bls,brsnls,nrs,bls,brs 此时全为外节点，将 NoNoNo 删除，fafafa 左儿子为空，同时 fa,brfa,brfa,br 颜色互换。\n\n\n\n 2.3.5 fa为黑，br为黑叶子\n与 2.3.42.3.42.3.4 处理方式相同，不过处理完 NoNoNo 后，要将 fafafa 当成新的待处理节点，继续向上更新。\n 部分代码\n 节点结构体\nstruct Node\n&#123;\n    /* 存放数据 */\n    int data;\n    /* 颜色，0红，1黑 */\n    int color;\n    /* 0左，1右，之后涉及到方向都这么规定 */\n    Node *next[2];\n    /* 父亲 */\n    Node *father;\n&#125;;\n这里将左右子节点的指针放到一个数组中，而不是分别开两个变量，是为了简化后续操作做好准备\n 旋转\n显然，旋转分为左旋和右旋，而不同的旋转，需要操作不同的指针。\n但观察旋转方式可以发现，旋转时各指针操作的相对位置是一样的，比如都是保留和自己同方向的子节点，而反方向的子节点接到父节点的同方向。\n\n\n注意观察，左右子节点的变化规律\n\n因此，借助结构体的定义方式，我们可以通过一个函数，解决所有旋转操作。\n/* 将No按照direction反方向旋转 */\n/* 如No右旋时，No为左子树，direction=0 */\nvoid rotate(Node *No, int direction)\n&#123;\n    /* 获取No的父亲和祖先 */\n    Node *fa = No->father, *ffa = fa->father;\n    /* 对父亲进行更改 */\n    No->father = fa->father;\n    fa->father = No;\n    /* 父亲同方向连接No反方向叶节点 */\n    fa->next[direction] = No->next[direction ^ 1];\n    /* 注意子树是否存在 */\n    if (No->next[direction ^ 1])\n        No->next[direction ^ 1]->father = fa;\n    /* 父亲变为反方向叶节点 */\n    No->next[direction ^ 1] = fa;\n    /* 根节点特判 */\n    if (!ffa)\n    &#123;\n        root = No;\n        return;\n    &#125;\n    /* 处理祖先 */\n    if (ffa->next[0] == fa)\n        ffa->next[0] = No;\n    else\n        ffa->next[1] = No;\n&#125;\n 查找\n想要完成插入或者删除，则必须先有查找。\n/* 查找值域为x的节点，找到返回节点，否则返回最后查找失败的叶节点 */\nNode *findNode(const int x)\n&#123;\n    /* 树为空 */\n    if (!root)\n        /* 返回无效值 */\n        return NULL;\n    /* 从根开始 */\n    Node *No = root;\n    while (1)\n    &#123;\n        /* 去右子树 */\n        if (x > No->data)\n        &#123;\n            if (No->next[1])\n                No = No->next[1];\n            else\n                return No;\n        &#125;\n        /* 去左子树 */\n        else if (x &lt; No->data)\n        &#123;\n            if (No->next[0])\n                No = No->next[0];\n            else\n                return No;\n        &#125;\n        /* 找到x */\n        else\n            return No;\n    &#125;\n&#125;\n 插入\n插入时，需要先进行查找，如果值存在，则无需插入，否则，在失败叶节点下插入新节点，并对新节点更新。\n/* 对No进行更新 */\nvoid insertUpdate(Node *No)\n&#123;\n    while (1)\n    &#123;\n        /* getDirection确定No的方向 */\n        int direction = getDirection(No);\n        /* 处理到根节点 */\n        if (direction == -1)\n        &#123;\n            /* root_color is black */\n            No->color = 1;\n            return;\n        &#125;\n        /* 意义同之前的介绍 */\n        Node *fa, *ffa, *uncle;\n        fa = No->father;\n        /* fa黑色，无需处理 */\n        if (fa->color)\n            return;\n        ffa = fa->father;\n        /* uncle为fa的反向节点 */\n        uncle = ffa->next[getDirection(fa) ^ 1];\n        /* 1.1情况 */\n        if (uncle &amp;&amp; uncle->color == 0)\n        &#123;\n            /* changeColor改变节点颜色 */\n            fa->changeColor();\n            ffa->changeColor();\n            uncle->changeColor();\n            No = ffa;\n        &#125;\n        /* 1.2情况 */\n        else\n        &#123;\n            /* 1.2.1情况 */\n            if (ffa->next[direction] != fa)\n            &#123;\n                /* 旋转No */\n                rotate(No, direction);\n                No = fa;\n                continue;\n            &#125;\n            /* 1.2.2情况 */\n            rotate(fa, direction);\n            fa->changeColor();\n            ffa->changeColor();\n            return;\n        &#125;\n    &#125;\n&#125;\n\n/* 插入x */\nvoid insert(const int x)\n&#123;\n    /* 树为空，则直接创建根节点 */\n    if (!root)\n    &#123;\n        root = new Node(x, 1, 0);\n        return;\n    &#125;\n    /* 查找x */\n    Node *No = findNode(x);\n    /* 建立右子树 */\n    if (x > No->data)\n    &#123;\n        No->next[1] = new Node(x, 0, No);\n        /* 对新节点进行更新 */\n        insertUpdate(No->next[1]);\n    &#125;\n    /* 建立左子树 */\n    else if (x &lt; No->data)\n    &#123;\n        No->next[0] = new Node(x, 0, No);\n        insertUpdate(No->next[0]);\n    &#125;\n&#125;\n 删除\n删除操作较为复杂，尤其是删除黑色叶节点，需要注意顺序，一种一种情况去处理。\n/* 针对2.0情况，寻找No的后继 */\nNode *removeChange(Node *No)\n&#123;\n    /* Ne是要寻找的后继，初始为No右子树 */\n    Node *Ne = No->next[1];\n    /* 不断向下，直到Ne没有左子树 */\n    while (Ne->next[0])\n        Ne = Ne->next[0];\n    /* 交换No，Ne */\n    No->data = Ne->data;\n    /* 将后继返回 */\n    return Ne;\n&#125;\n\n/* 针对2.3情况，黑叶子删除后的更新 */\nvoid removeblackNode(Node *No)\n&#123;\n    while (1)\n    &#123;\n        /* 确定No方向 */\n        int direction = getDirection(No);\n        /* 处理到根节点为止 */\n        if (direction == -1)\n        &#123;\n            No->color = 1;\n            return;\n        &#125;\n        /* fa，brother(br)意义同介绍 */\n        Node *fa = No->father;\n        /* br是No反向节点 */\n        Node *brother = fa->next[direction ^ 1];\n        /* 2.3.1情况 */\n        if (brother->color == 0)\n        &#123;\n            rotate(brother, direction ^ 1);\n            swap(fa->color, brother->color);\n        &#125;\n        /* br为黑色 */\n        else if (brother->color == 1)\n        &#123;\n            /* 2.3.3情况 */\n            if (brother->next[direction ^ 1] &amp;&amp; brother->next[direction ^ 1]->color == 0)\n            &#123;\n                rotate(brother, direction ^ 1);\n                swap(fa->color, brother->color);\n                brother->next[direction ^ 1]->color = 1;\n                return;\n            &#125;\n            /* 2.3.2情况 */\n            else if (brother->next[direction] &amp;&amp; brother->next[direction]->color == 0)\n            &#123;\n                swap(brother->color, brother->next[direction]->color);\n                rotate(brother->next[direction], direction);\n            &#125;\n            /* br是黑叶子 */\n            else\n            &#123;\n                /* 2.3.4情况 */\n                if (fa->color == 0)\n                &#123;\n                    fa->changeColor();\n                    fa->next[direction ^ 1]->changeColor();\n                    return;\n                &#125;\n                /* 2.3.5情况 */\n                else\n                &#123;\n                    fa->next[direction ^ 1]->changeColor();\n                    /* 继续处理fa */\n                    No = fa;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n/* No删除后的更新 */\nvoid removeUpdate(Node *No)\n&#123;\n    while (1)\n    &#123;\n        /* 确定No方向 */\n        int direction = getDirection(No);\n        Node *fa = No->father;\n        /* No为叶节点 */\n        if (!(No->next[0] || No->next[1]))\n        &#123;\n            /* 根节点特判 */\n            if (No == root)\n            &#123;\n                root = NULL;\n                /* 处理结束 */\n                goto removeUpdateEnd;\n            &#125;\n            /* 2.1情况 */\n            else if (No->color == 0)\n            &#123;\n                fa->next[direction] = NULL;\n                goto removeUpdateEnd;\n            &#125;\n            /* 2.3情况 */\n            else\n            &#123;\n                /* 针对5种情况处理 */\n                removeblackNode(No);\n                No->father->next[direction] = NULL;\n                goto removeUpdateEnd;\n            &#125;\n        &#125;\n        /* 2.0情况，No两个子树 */\n        else if (No->next[0] &amp;&amp; No->next[1])\n            No = removeChange(No);\n        /* 2.2情况，No只有一个子树 */\n        else\n            for (int i = 0; i &lt;= 1; ++i)\n                if (No->next[i])\n                &#123;\n                    /* 注意根节点的特殊处理 */\n                    if (fa)\n                        fa->next[direction] = No->next[i];\n                    if (No == root)\n                        root = No->next[i];\n                    No->next[i]->father = fa;\n                    No->next[i]->color = 1;\n                    goto removeUpdateEnd;\n                &#125;\n    &#125;\nremoveUpdateEnd:\n    /* 更新完成后再删除No */\n    delete No;\n&#125;\n\n/* 删除值为x的节点 */\nvoid remove(const int x)\n&#123;\n    /* 查找x */\n    Node *No = findNode(x);\n    /* 树为空 || 值为x的节点不存在 , 无需处理 */\n    if (!No || No->data != x)\n        return;\n    /* 进行删除和更新 */\n    removeUpdate(No);\n&#125;\n 总结\n红黑树的代码算是平衡树中比较复杂的，不过虽然看起来代码冗长和复杂，其实就是对之前分析的几种情况的模拟，以上红黑树主要实现部分的代码，删去注释和多余的括号空行后，大概180多行，对于一个复杂的平衡树代码来说，已经算是很正常的了。大部分数据结构的原理都比较简单，代码实现才是难点。\n","categories":["知识","数据结构"],"tags":["数据结构","平衡树","红黑树","C++"]},{"title":"学校数据结构2022-03-11上机题","url":"/posts/46746.html","content":" T1 手撕STL sort\n 问题描述\n模拟实现C++中STL sort的功能。\n设数组 aaa 中有 nnn 个元素，有三个要求。\n\n当递归区间小于设定值时，直接返回。\n当递归深度超过 ⌊2⋅log⁡2n⌋\\lfloor 2 \\cdot \\log_{2}{n} \\rfloor⌊2⋅log2​n⌋ 时，转为堆排序。\n最后对整个数组进行直接插入排序。\n\n 题解\n这题解法都已经给好了，就对着书上把相应的代码抄下来，然后按照题意组合就行了。注意若区间足够小，一定是先返回，只有当要求 111 不满足时，才考虑堆排序。\n T2 冬奥会接驳车\n 问题描述\n一个 n×mn \\times mn×m 的矩阵，其中每个元素为，000 空地，111 障碍，333 起点，444 终点。\n一个人从起点出发，只能上下左右移动，不能碰到障碍，求最少几步能够到终点。\n1≤n,m≤1001 \\le n,m \\le 1001≤n,m≤100\n 题解\n显而易见的 BFSBFSBFS 问题，从起点开始，每次向四个方向扩展，走到的地方如果不是障碍且步数更少就入队，直到走到终点即可。如果所有元素出队后，终点仍未入队（没走到），则无解。\n(X,Y) &#x3D;&gt; 队列Q;   \ndis(X,Y) &#x3D; 0;   &#x2F;&#x2F;起点入队，dis记录步数\nwhile (head &lt; tail)     &#x2F;&#x2F;队列不空\n&#123;\n    Q &#x3D;&gt; (X,Y);\n    for (int i &#x3D; 0; i &lt; 4; ++i)\n    &#123;\n        (X,Y) + next[i] -&gt; (x,y);   &#x2F;&#x2F;向四个方向扩展\n        if (x,y)未过边界 &amp;&amp; (x,y)不是障碍 &amp;&amp; (dis(X,Y) + 1 &lt; dis(x,y))\n        &#123;\n            dis(x,y) &#x3D; dis(X,Y) + 1;\n            (x,y) &#x3D;&gt; Q;     &#x2F;&#x2F;新点入队\n        &#125;\n    &#125;\n&#125;\n时间复杂度 O(n⋅m)O(n \\cdot m)O(n⋅m) 。\n T3 自动纠错\n 问题描述\n两个字符串 s1,s2s1,s2s1,s2 之间的距离 disdisdis 定义为，有三种操作：\n\n删去任意位置一个字符\n增加任意位置一个字符\n改变任意位置一个字符\n\ns1s1s1 改变为 s2s2s2 所需要的最小的操作次数，为两者间的距离。如图所示的距离（上 s1s1s1 ，下 s2s2s2 ）为 444 。\n\n\n\n现有一个字典，其中有 nnn 个元素，每个元素为字符串 sss 和其对应的频率 ppp 。\n给出 mmm 个询问，每个询问为一个字符串 qqq ，问字典中哪些字符串和 qqq 的距离在 ddd 之内，并输出其中频率最高的（频率相同时字典序更小）。\nn≤104,m≤103,d≤2n \\le 10^4,m \\le 10^3,d \\le 2n≤104,m≤103,d≤2\n 题解\n 数据结构\n具体的数据结构题目已经很明显的给出了：\n一种高效的处理方法是：结合各单词间的距离，将字典组织成一棵多叉树。在该树中，每个结点表示一个单词，对于每个结点 ppp ，其第 iii 棵子树包含与 ppp 的距离为 iii 的所有单词对应的结点。\n树的创建过程如下：取字典中任意单词作为根结点，比如第一个单词。然后将剩余单词逐个插入到树中，插入一个新单词 www 时，首先计算该单词与根结点的距离 ddd 。若根结点的第 ddd 个子树为空，则将单词 www 对应的结点作为根结点的第 ddd 个子结点。若根结点的第 ddd 个子树非空，即根结点已有第 ddd 个子结点 pdp_dpd​ 。则按上述规则将单词 www 递归插入以 pdp_dpd​ 为根的子树，即计算 www 与 pdp_dpd​ 的距离…。\n例如字典为 help,hell,hello,shell,helper,sloop,helps,troophelp, hell, hello, shell, helper, sloop, helps, troophelp,hell,hello,shell,helper,sloop,helps,troop ，将 helphelphelp 作为根结点，然后将 hellhellhell 插入，hellhellhell 与 helphelphelp 的距离为 111 ，故 hellhellhell 作为 helphelphelp 的第一个子结点。hellohellohello 与 helphelphelp 的距离为 222 ，故 hellohellohello 作为 helphelphelp 的第 222 个子结点。如下图 (a)(a)(a) 所示。\n\n\n\n然后插入 shell,shellshell,shellshell,shell 与 helphelphelp 的距离为 222 ，故应在 helphelphelp 的第 222 个子树里，但 helphelphelp 已经有第 222 个子结点 hellohellohello 了，此时将 shellshellshell 递归插入以 hellohellohello 为根结点的子树：计算 shellshellshell 与 hellohellohello 的距离为 222 ，将 shellshellshell 作为 hellohellohello 的第 222 个子结点，如上图 (b)(b)(b) 所示。插入 helperhelperhelper 时，helperhelperhelper 与 helphelphelp 的距离为 222 ，将 helperhelperhelper 递归插入以 hellohellohello 为根结点的子树：计算 helperhelperhelper 与 hellohellohello 的距离为 333 ，将 helperhelperhelper 作为 hellohellohello 的第 333 个子结点。以此类推，最终上述字典对应的树结构如上图 (c)(c)(c) 所示。该树结构保证与任意结点距离为 ddd 的单词都在该结点的第 ddd 棵子树里。\n假定我们需要向用户返回与错误单词距离不超过 nnn 的单词，当用户输入一个单词 www 时，在树中查询 www ，计算 www 与根结点 TTT 的距离 ddd ，接下来我们不必考察 TTT 的所有子树中是否包含与 www 距离不超过 nnn 的结点/单词，而只需要递归考察根结点 TTT 的第 d−nd-nd−n 到第 d+nd+nd+n 棵子树即可。例如 n=1,d=5n=1,d=5n=1,d=5 ，我们只需要递归考察根 TTT 的第 444 、第555、第666棵子树是否包含与www距离不超过111的结点/单词。其他子树无需考察，为什么呢？举个例子，我们考虑根TTT的第333棵子树的任意结点PPP。www与TTT的距离为d=5d=5d=5，即www最少经过555步操作才能转换为TTT，TTT与PPP的距离为333，TTT经过最少333步操作才能变为PPP，这意味着www至少需要222步操作才能变为PPP。不可能通过111步操作变为PPP。故第333棵子树的所有结点都不满足条件。\n\n\n\n由于nnn通常很小，因此该方法在查询时往往可以排除很多子树，进而节省时间。当考察一个结点时，计算www与该结点的距离ddd；若d=0d=0d=0，意味着用户输入的单词www在字典中，是正确的单词；若d&gt;nd &gt; nd&gt;n则该结点不是候选单词，继续递归考察该结点第d−nd-nd−n到d+nd+nd+n的子树。若d≤nd ≤ nd≤n则该结点就是候选单词之一，此时可有两种策略，一是将该单词直接返回给用户，二是继续向下考察子树，找出所有候选单词并选择用户历史使用频率最高的单词返回给用户。\n以上为题目给出的算法，注意这个算法时间复杂度并不严格，只是能在某种程度上减少比较次数，但可以确保通过此题（需注意实现算法的常数）。\n 计算字符串距离\n除此以外，还有一个重要的问题就是，如何计算两个字符串的距离。\n可见每个位置都有三种操作，如果直接暴力比较，虽然字符串的长度只有 151515 ，也仍然需要 3153^{15}315 次比较，显然是无法接受的。\n这里提出一种有效的解决方案，这个问题可以使用动态规划解决。\n设 dp[i][j]dp[i][j]dp[i][j] 为 s1s1s1 考虑到 iii 位置，s2s2s2 考虑到 jjj 位置，$s1_{1 \\cdots i},s2_{1 \\cdots j} $ （前缀）的距离。显然对于 i,ji,ji,j 有两种情况：\n\ns1[i]=s2[j]s1[i]=s2[j]s1[i]=s2[j] ，此时 dp[i][j]=dp[i−1][j−1]dp[i][j]=dp[i-1][j-1]dp[i][j]=dp[i−1][j−1]\ns1[i]≠s2[j]s1[i] \\not = s2[j]s1[i]=s2[j] ，此时 dp[i][j]=min{dp[i−1][j−1],dp[i−1][j],dp[i][j−1]}+1dp[i][j]=min\\{dp[i-1][j-1],dp[i-1][j],dp[i][j-1]\\}+1dp[i][j]=min{dp[i−1][j−1],dp[i−1][j],dp[i][j−1]}+1\n\n对于 111 很好理解，两个位置相同，就没必要操作，直接从之前的状态扩展即可。\n对于 222 ，三个式子正好对应三种操作（改变，增加，减少），因为要次数最少，所以取三者最小值，再加上一次操作次数，拓展到新状态。\n边界条件可根据状态得出：\n\ndp[i][0]=idp[i][0]=idp[i][0]=i 显然 s2s2s2 是空，则 s1s1s1 最少通过减 iii 个字符与其相同。\ndp[0][j]=jdp[0][j]=jdp[0][j]=j 同上。\n\nint Dis(char *s1, char *s2)\n&#123;\n    int len1 &#x3D; strlen(s1);\n    int len2 &#x3D; strlen(s2);\n    int dp[Max_len][Max_len] &#x3D; &#123;0&#125;;\n    int len &#x3D; max(len1, len2);\n    for (register int i &#x3D; 0; i &lt;&#x3D; len; ++i)\n        dp[i][0] &#x3D; dp[0][i] &#x3D; i;       &#x2F;&#x2F;边界条件\n    for (register int i &#x3D; 1; i &lt;&#x3D; len1; ++i)\n        for (register int j &#x3D; 1; j &lt;&#x3D; len2; ++j)\n            if (s1[i - 1] &#x3D;&#x3D; s2[j - 1])\n                dp[i][j] &#x3D; dp[i - 1][j - 1];    &#x2F;&#x2F;情况1\n            else\n                dp[i][j] &#x3D; min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;      &#x2F;&#x2F;情况2\n    return dp[len1][len2];\n&#125;\n时间复杂度 O(len2)O(len^2)O(len2) ，lenlenlen 为字符串长度。\n","categories":["题解","吉林大学","数据结构课设"],"tags":["C++","动态规划","快速排序","BFS","字符串"]},{"title":"学校数据结构2022-03-04上机题","url":"/posts/23182.html","content":" T1 冬奥村网络布线方案\n 问题描述\n冬奥会的奥运村是各国运动员在冬奥会期间的住宿公寓，冬奥会期间需要保证奥运村网络畅通，以使运动员都能正常上网。\n假定奥运村有 nnn 个房间，编号为 0⋯n−10 \\cdots n−10⋯n−1 ，每个房间都需要网络连接。房间 iii 有网络，当且仅当满足如下 222 个条件之一：\n\n房间 iii 安装了路由器（成本为 ri&gt;0r_i&gt;0ri​&gt;0 ）\n房间 iii 和房间 jjj 有网线连接且房间 jjj 有网络（在房间 iii 和房间 jjj 之间布置网线的成本为 fi,j&gt;0f_{i,j}&gt;0fi,j​&gt;0 ）\n\n假定你是奥组委的网络工程师，请编写程序为奥组委设计一个网络布线方案（哪些房间安装路由器，哪些房间之间布置网线），使得所有房间都有网络，且总成本最小。\n点数 n≤600n \\le 600n≤600 ，边数不超过 2×1052 \\times 10^52×105 。\n 题解\n可以发现每个点有三种状态，分别是：\n\n第一层：无网络\n第二层：有网络（装有路由器）\n第三层：有网络（其他房间扩散）\n\n据此，可将每个点分成三层，第一层与原点 SSS 连权值为零的边（不要网自然不要费用），第一层向第二层对应的点连边，权值为原点权（装路由器通网的费用），第二层向第三层对应点连权值为零的边（本身装路由器了，自然不需要网线），同时，第三层之间的房间可以相互影响，所以依据原图关系，在相应的点之间连边，费用为原边权（装网线费用）。如下图所示。\n\ngraph BT\n\nA1((0))\nA2((0'))\nA3((0''))\nB1((1))\nB2((1'))\nB3((1''))\nC1((2))\nC2((2'))\nC3((2''))\nD1((3))\nD2((3'))\nD3((3''))\nE1((4))\nE2((4'))\nE3((4''))\nF1((5))\nF2((5'))\nF3((5''))\nG1((6))\nG2((6'))\nG3((6''))\nS((S))\n\nS---|0|A1\nS---|0|B1\nS---|0|C1\nS---|0|D1\nS---|0|E1\nS---|0|F1\nS---|0|G1\nA1---|60|A2\nB1---|10|B2\nC1---|35|C2\nD1---|55|D2\nE1---|40|E2\nF1---|70|F2\nG1---|70|G2\nA2---|0|A3\nB2---|0|B3\nC2---|0|C3\nD2---|0|D3\nE2---|0|E3\nF2---|0|F3\nG2---|0|G3\nA3---|20|B3\nA3---|75|E3\nA3---|45|D3\nB3---|50|D3\nB3---|15|C3\nC3---|5|G3\nF3---|45|G3\nE3---|5|F3\nD3---|25|F3\nD3---|65|G3\n\n可见，最终的目标就是通过连边覆盖图上的全部节点，只需要进行一遍最小生成树的计算即可。从原点 SSS 使用 PrimPrimPrim 计算，时间复杂度 O(n2)O(n^2)O(n2) 。\n T2&amp;T3 冬奥会网站功能提升\n 问题描述\n一个字典里有 nnn 个字符串及其优先级，之后有 mmm 个询问，对于每一个询问，给出一个模式串 ppp ，要求找出优先级前 KKK 个字符串 s1⋯sKs_1 \\cdots s_Ks1​⋯sK​ ，要求 ppp 是 si,i=1⋯Ks_i,i=1 \\cdots Ksi​,i=1⋯K 的前缀，且 p≠sip \\not= s_ip=si​ 。\n 题解\n对于这个问题，我们并不需要相现实中一样，对于每个询问，立即查找答案，而是先将所有的询问保存下来，再用给出的字符串去往询问中放，看他能成为哪个询问的答案。\n这个解法使用了字典树 TrieTrieTrie ，用于处理字符串匹配。\n首先将所有询问的字符串放入一个字典树中，同时在节点做上标记，111 代表这是一个字符串的结尾，如样例中形成的字典树如下：\n\ngraph TB\n\nA((Root))\nB((0))\nC((1))\nD((1))\nE((0))\nF((0))\nG((1))\n\nA--t-->B\nB--h-->C\nC--e-->D\nA-->|x|E\nE-->|x|F\nF-->|x|G\n\n之后将所有字典里的字符串按照题目要求，按优先级从高到低排序，将排序后的字符串放到字典树里比较，如果遇到节点为 111 ，且节点中存储的答案不超过 KKK 时，则将字符串作为答案存入该节点。如 theytheythey ，比较后则会存入左下方的两个节点。\n待所有字典中的字符串都处理完后，再依次用询问的字符串放入字典树比较，匹配成功后，取出末尾节点中的答案输出即可。如 thethethe 则会匹配到最左下方的节点，并输出其中所保存的答案。\n设字符串平均长度为 lenlenlen ，对字典字符串进行排序复杂度 O(nlog⁡n)O(n \\log n)O(nlogn) ，字典树操作复杂度 O(m⋅len)O(m \\cdot len)O(m⋅len) 。\n需要注意的是，在大量的输出数据的情况下，题目 60ms60ms60ms 的时限非常紧促，建议程序中不要使用 stringstringstring 和其他库函数，最好加上 inline,registerinline,registerinline,register 等，整形较小时使用 shortshortshort 而非 long longlong\\ longlong long ，输入输出使用 gets,fputsgets,fputsgets,fputs 等较快的方式。（ scanf,printfscanf,printfscanf,printf 我都过不去）\n优化和卡常前后的速度对比：\n\n\n\n\n","categories":["题解","吉林大学","数据结构课设"],"tags":["C++","最小生成树","字典树Trie"]},{"title":"学校数据结构2021-12-13上机题","url":"/posts/52601.html","content":" T1 小龙猜数字\n 问题描述\n定义字符串的秩为：该字符串长度减去该字符串的最短相等前后缀的长度。若该字符串不存在相等的前后缀，则其秩为 000 。\n给出一个字符串 SSS ，需计算 SSS 及 SSS 中所有前缀子串的秩之和。\n字符串长度不超过 10610^6106 。\n 题解\n此题目为 KMPKMPKMP 数组的应用，但 KMPKMPKMP 失败数组求的是最长的相等前后缀，所以要对其进行修改。&lt;center&gt;&lt;/center&gt;\n如图，对于 ababababababababab 其失败数组标明了前后缀相等的子串为 abababababab ，而子串 abababababab 的失败数组标明了最长前后缀相等的是 ababab ，而因为在原串中前后缀相等的性质，可知原串中必有相等的前后缀 ababab 。\n因此，可通过不断访问子串的失败数组，来得到最小前缀。\n但需要注意，当 SSS 中所有字符都相等时，该算法时间复杂度为 O(n2)O(n^2)O(n2) 。因此需要将子串失败数组，按照类似并查集的方式进行路径压缩。&lt;center&gt; &lt;/center&gt;比如在 ababaababaababa 中，根据失败数组访问子串 abaabaaba 时，发现 abaabaaba 的失败数组为 000 ，则可将 ababaababaababa 失败数组也改成 000 ，同理可将 ababababababababab 失败数组改成 111 。\n T2 二叉树路径和\n 问题描述\n给定一颗二叉树，树有点权，求问是否有一条路径，其点权和为 KKK 。\n“路径”定义为二叉树中的结点序列 vi,vi+1,...,vjv_i ,v_{i+1},..., v_jvi​,vi+1​,...,vj​ ，序列中前一个结点是后一个结点的父结点。\n如有多条路径，输出最短的一条，且最靠右，最靠叶节点。\n有多组数据，总结点数不超过 1.5×1051.5 \\times 10^51.5×105 。\n 题解\n不知此题有没有什么暴力出奇迹的解法，但如果数据强度足够，这题应该是几次上机以来最难的一题。\n首先各种暴力，如两次 DFSDFSDFS ，从叶节点反着找等等，都是时间复杂度 O(n2)O(n^2)O(n2) 的，很容易超时。\n这里提供一种方式，理论上可以通过。\n首先，这题输入就比较麻烦，因为并不知道树有多少个节点，而且还是多组数据，没法用 EOFEOFEOF 等方式判断一组数据是否输入结束。同时为了优化时间，选择读入同时建树，依据二叉树带空指针的先根序列表示法，当对应的树建成，就代表一组数据已经读完了。\n代码结构大概如此：\nbuild:\n    读入左子树信息;\n    if (左子树不是空指针)\n        build(左子树);\n    读入右子树信息;\n    if (右子树不是空指针)\n        build(右子树);\n然后开始对建好的树进行 DFSDFSDFS ，直到叶节点，可见这个操作遍历了树的一条链，遍历过程中，记录每个节点到根节点的点权的前缀和 sumsumsum ，及节点的深度 deepdeepdeep 。\n可知，所求的路径一定在某一条从根到叶节点的链上，而对于一条链上，我们只要找到两个节点 x,yx,yx,y ，使其满足：\ndeepx&lt;=deepydeep_x&lt;=deep_y\ndeepx​&lt;=deepy​\nsumy−sumxfather=K，xfather为x父节点sum_y-sum_{x_{father}}=K，x_{father}为 x 父节点\nsumy​−sumxfather​​=K，xfather​为x父节点\n则 x,yx,yx,y 之间的路径就是一条合法的路径，而求解时可先枚举确定 yyy ，然后求对应的 xxx ，这个过程可暴力枚举，时间复杂度 O(n2)O(n^2)O(n2) 。但该式子为一次函数，所以可以先将 sum,deepsum,deepsum,deep 排序（需要快排、归并等效率较高的排序），然后通过二分查找确定 xxx 以进行优化，优化后的时间复杂度为 O(nlog⁡n)O(n \\log n)O(nlogn) ，再通过对程序细节处理上尽量提高效率，理论上可以稳定通过此题数据。\n对于题目中要求 &lt;font color=red&gt;“若存在多条满足条件的路径，则输出最短（包含结点个数最少）者，若存在多条最短的路径，则输出最靠右下者。”&lt;/font&gt;可在 DFSDFSDFS 顺序上进行修改，优先搜索右子树，同时在枚举 yyy 时，顺序从叶节点到根节点即可。\nDO:\n    Sort(sum,deep);   &#x2F;&#x2F;对sum和deep双关键字排序 \n    For y&#x3D;n to 1 do     &#x2F;&#x2F;n为链上的节点个数，n是叶，1是根\n    &#123;\n        Find(x);        &#x2F;&#x2F;确定对应的x\n        Update(Ans);    &#x2F;&#x2F;更新答案\n    &#125;\n\nDFS:\n    if (该节点不是叶节点)\n    &#123;\n        DFS(右子树);\n        DFS(左子树);\n    &#125;\n    else\n        DO();\n T3 最小支撑树\n 问题描述\n给一个无向图，求最小生成树，注意图可能不连通。\n多组数据，每组数据的点数和边数都不超过 1.5×1031.5 \\times 10^31.5×103 。\n 题解\n最小生成树模板题，推荐 KruskalKruskalKruskal ，利用并查集判断图是否连通即可。\n","categories":["题解","吉林大学","数据结构课设"],"tags":["C++","KMP","二叉树"]},{"title":"Hexo_Kaze主题使用文档","url":"/posts/8878.html","content":" 主题简介\nKaze是基于Hexo博客引擎的响应式主题，由 theme-kaze 开发维护\n 使用须知\n文档并不包含所有配置项，其他选项请参考主题配置和 Hexo文档，如有配置上的其他疑问可以在issue中提出\n 安装主题\n 直接通过npm/yarn安装\n在 Hexo 5.0 及以上版本中您可以直接通过输入\nnpm install hexo-theme-kaze\n直接安装主题\n 其他方式\n如果您有其他需要可以在 your site/themes 下输入\ngit clone https://github.com/theme-kaze/hexo-theme-Kaze.git\n或者下载主题压缩包在 your site/themes 下解压，并且将 hexo-theme-kaze 重命名为  kaze\n重命名为 kaze 是为了与通过 npm/yarn 下载保持一致性\n 持续升级\n在Hexo5.0及以上版本中您可以在站点根目录中新建 _config.kaze.yml 进行自定义配置，具体优先级参见相关文档\n在Hexo其他版本中您可以在站点目录 source 文件夹中新建 _data 文件夹并在期中新建 kaze_config.yml 复制主题配置文件的基本配置，然后就可以进行自定义配置，kaze-config.yml 设置优先于主题配置设置\n之后直接采取 git pull 或覆盖主题目录等方式便可直接升级无需替换配置\n请关注Release中的Breaking Changes会提示对配置造成不下兼容的改动 请自行更改\n 总体\n 多语言\n主题支持i18n国际化，目前支持英文与简体中文，有其他语言支持可提交PR。在站点配置文件中找到language即可修改语言 language: en 设置英文，language: zh-CN 设置简体中文\n 懒加载\n在主题配置选项 lazyload 中设置 enable: true 开启懒加载（默认开启）\nloadingImg 中可以设置加载图，可以在post中设置 banner_img_set 进行覆盖实现缩略图效果\n 文件压缩\n主题自带文件压缩，可以配合GZIP或其他优化手段提高网页访问速度，默认关闭，可以在\nminify:\n  enable: false\n  css: true\n  js: true\n  html: true\n中进行配置\n需要注意开启压缩后会影响 hexo g 的性能\n 主题颜色\n本主题中大部分颜色都可以在主题配置选项 color 中进行配置\n 字号与字体\n在主题配置选项 font 中可以设置 font-size 和 font-family\n og meta 元素\nOpen graph 是由facebook推出的技术，可以帮助您在各类支持该技术的社交媒体上显示网页卡片\nog:\n  enable: true\n  title: true\n  url: true\n  image: true\n  description: true\n  article: true\n\nenable 开启功能（默认开启）\ntitle… 请参见 &lt;a href=&quot;https://ogp.me&quot;&gt;官网文档 &lt;/a&gt;\n\n 静态资源\n主题大部分第三方资源索引都可以在主题配置选项 cdn 中进行配置，可以自定义其他资源路径\n 动画\n在主题配置文件中 animation config 调整主题动画效果，目前仅支持控制回到顶部动画的开关\n 图标\n主题图标依赖于 iconfont，内置了一部分社交图标，您可以自定义其他icon文件或者解决方案来添加自定义图标\n\n 站点访问量统计\n访问量统计目前仅支持不蒜子\nfooter:\n  statistics:\n    enable: false\n    type: busuanzi # now version only supports busuanzi\n    pv:\n      enable: true\n      style: 本站总访问量&#123;&#125;次 # the style will be shown as $1&#123;pv&#125;$2\n    uv:\n      enable: true\n      style: 本站总访客数&#123;&#125;次\nenable 开启访问量统计（默认关闭）\ntype  目前仅支持 busuanzi\npv 访问总量统计\nuv 用户总量统计\n 数据分析\nanalytics:\n  enable: false\n  type: google # google\n  google:\n    id: \nenable 开启分析支持（默认关闭）\ntype 目前仅支持 google\ngoogle.id 有关谷歌分析的具体使用说明和 id 使用可以参考谷歌文档\n 首页\n 文章头图\n在文章 Front-matter 中 banner_img 可以设置首页头图\n 小组件\nwidgets:\n  showWidgetsMobiles: \"none\"\nshowWidgetsMobiles : 在窄屏幕上是否显示小组件，none 关闭（默认），flex 开启\n 关于\n关于页面需要自行创建，在站点 source 中新建 about 文件夹并在文件夹内创建 index.md，该文件至少需要包含\n# at $&#123;yoursite&#125;/about/index.md\n---\ntitle: 关于\nlayout: about\n---\n 社交链接\n在主题配置中\n# about page config\nabout:\n  description: description\n  social_links:\n    - &#123; icon: icon, link: your_links &#125;\n    - ...more\n在主题配置文件中按如上格式填写 social_links 即可创建社交链接，icon 相关可以参见图标\n 友链\n友链格式按如下填写即可生成友链页面\nlinks:\n  example-name-1: \n    url: https://example.com\n    avatar: https://example.com/avatar.jpg\n  example-name-2: \n    url: https://example.com\n    avatar: https://example.com/avatar.jpg\n 文章页\n 搜索功能\nsearch:\n  enable: true\n  path: search.json\n  field: posts\n  searchContent: true\n\nenable 开启搜索功能（默认开启）\npath 文件名称（暂无用处）\nfield 需要搜索的范围，支持 posts | pages | all\nsearchContent 搜索文件是否包含正文内容（不建议开启，包含所有文章内容这样会使得搜索文件异常巨大）替代方案是搜索分类标签或使用algolia等第三方搜索服务（Todo）\n\n 目录\n主题目录通过Hexo原生函数生成，具体可参见 文档\ntoc:\n  showListNumber: false\n  maxDepth: 6\n  minDepth: 1\nshowListNumber 是否生成编号\nmaxDepth TOC最大深度\nminDepth TOC最小深度\n 代码高亮\n参见代码 高亮文档\n 数学公式\n主题支持 mathjax 和 katex 两种渲染引擎，具体参见 相关文档\n copyright\ncopyright:\n  enable: true\n  writer: # if writer is empty we will use config.author as writer\n  declare: 本博客所有文章除特别声明外，均采用&lt;a target=\"_blank\" rel=\"noopener\" href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh\">CC BY-NC-SA 4.0 协议&lt;/a>。转载请注明出处！\n  style: warning\nenable 开起版权说明（默认开启）\nwriter 作者id，如果不填则会使用主题配置 author或站点配置 author\ndeclare 版权声明具体内容，支持 html 语句\nstyle 声明内容样式，与 note 样式相同\n版权内容有三部分：作者、文章链接、版权声明\n作者使用 writer 参数，文章链接基于站点配置文件中 url参数生成，版权声明使用 declare 参数\n Front-matter\n banner_img\n设置文章与首页头图\n banner_img_set\n在图片加载时预先加载的图片，可以设置为 loading 图或缩略图等\n excerpt\n为文章设置在首页显示的简介，还可以通过 &lt;!--more--&gt; 来控制显示\n 评论\n支持 valine，gitalk 和 livere\n具体设置可参考主题配置文档说明和相关评论插件文档\n 字数统计\n主题集成 hexo-wordcount 插件，在主题配置文件中设置\nwordcount:\n  enable: true\n开启（默认开启）\n 图片画廊\n图片画廊功能基于 fslightbox，在主题配置文件中设置\nfslightbox:\n  enable: true\n开启（默认开启）\n 标签插件\n主题集成了一些标签方便书写\n note\n在 markdown 文件中如下书写即可\n&#123;% note style %&#125;\n...markdown content\n&#123;% endnote %&#125;\n有五种样式可以选择，primary，success，info，warning，danger\nprimary\nsuccess\ninfo\nwarning\ndanger\n 备案信息\n您可以在主题配置文件内增加您的备案信息。\nfooter:\n  #------------------------\n  # 备案配置\n  # 请将公安备案的缩略图置于 $&#123;yoursite&#125;/img/beian.png\n  RecordInfo: \"\" # '某ICP备xxx号'\n  govRecordInfo: \"\" # '某公网安备xxx号'\n  govRecordUrl: \"\" # 公网安备案信息地址\n  #------------------------","categories":["知识","BLOG","Kaze"],"tags":["Hexo","Kaze","BLOG"]},{"title":"代码高亮","url":"/posts/29740.html","content":" 简介\n\n\n\n\n\n\n\n\n 高亮方案\n本主题没有使用自定义高亮方式，高亮方案在Hexo本身支持的 highlightjs 和 prismjs 基础上修改得到\n 使用highlightjs\nhighlight:\n  enable: true\n  line_number: false\n  auto_detect: false\n  tab_replace: ''\n  wrap: true\n  hljs: true\nprismjs:\n  enable: false\n  ...\nhighlight 和 prismjs 的 enable: true 只能保留一个\n在站点配置文件将 highlight 设置 enable: true 即可开启，line_number 选项本主题暂不支持显示\n若需要支持代码高亮可设置 hljs: true，该配色方案参考了 tomorrow night 等配色主题\n其他具体参数设置可参考 Hexo相关文档 \n 使用prismjs\n在 prismjs 中设置 enable: true 和 preprocess: true 即可开启 默认支持 Line Numbers 和 Show Languages 两个插件 如果需要其他插件支持可以设置 preprocess: false\n当前主题版本不支持 preprocess: false 自动引入相关文件 如有相关需求请自行引入相关 css 与 js 文件\n设置 line_number: true 即可显示行号\n 演示\n以下演示采用 prism，highlight 在主题效果可参见（TODO）\n有八种高亮主题可选择\ndefault coy dark funky okaidia solarizedlight tomorrow twilight\n Javascript\nconst smoothScrollToTop = () => &#123;\n  let yTopValve = (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop);\n  if (yTopValve > 1) &#123;\n    window.requestAnimationFrame(smoothScrollToTop);\n    scrollTo(0, Math.floor(yTopValve * 0.85));\n  &#125; else &#123;\n    scrollTo(0, 0);\n  &#125;\n&#125;;\n\nsetTimeout(() => &#123;\n  document.getElementById('scrollbutton').onclick = smoothScrollToTop;\n&#125;, 0);\n C++\n#include&lt;cstdio>\n#include&lt;iostream>\n#include&lt;algorithm>\nconst int maxn=1050;\nconst int maxm=20000010;\nint h,n,v[maxn],w[maxn],f[maxm],maxx;\nint main()\n&#123;\n\tcin>>h>>n;\n\tmemset(f,0x3f,sizeof(f));\n\tf[0]=0;\n\tfor(int i=1;i&lt;=n;i++) cin>>v[i]>>w[i],maxx=max(v[i],maxx);\n\tfor(int i=1;i&lt;=n;i++)\n\t&#123;\n\t\tfor(int j=v[i];j&lt;=h+maxx;j++)\n\t\t\tf[j]=min(f[j],f[j-v[i]]+w[i]);\n\t&#125;\n\tint ans=inf;\n\tfor(int i=h;i&lt;=h+maxx;i++) ans=min(ans,f[i]);\n\tcout&lt;&lt;ans&lt;&lt;endl;\n\treturn 0;\n&#125;\n PHP\n&lt;?php\nerror_reporting(0);\nif(!isset($_GET['num']))&#123;\n    show_source(__FILE__);\n&#125;else&#123;\n        $str = $_GET['num'];\n        $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^'];\n        foreach ($blacklist as $blackitem) &#123;\n                if (preg_match('/' . $blackitem . '/m', $str)) &#123;\n                        die(\"what are you want to do?\");\n                &#125;\n        &#125;\n        eval('echo '.$str.';');\n&#125;\n?>\n JSON\n&#123;\n  \"name\": \"hexo-theme-kaze\",\n  \"description\": \"hexo-theme-kaze\",\n  \"author\": \"theme-kaze\",\n  \"license\": \"MIT\",\n  \"bugs\": &#123;\n    \"url\": \"https://github.com/theme-kaze/hexo-theme-Kaze/issues\"\n  &#125;,\n  \"homepage\": \"https://github.com/theme-kaze/hexo-theme-Kaze#readme\"\n&#125;\n Python\nimport requests\nimport re\nimport sys\nimport os\nurl = 'https://twoshot.hgame.n3ko.co/'\nheaders = &#123;\n    'Content-Type': 'application/x-www-form-urlencoded',\n    'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36',\n&#125;\np = requests.get(url+'random.php?times=228', headers=headers)\nrandnum = re.findall(r'\\d*', p.text)[1:-2:2]\nfirstnum = randnum[0]\nlastnum = randnum[227]\ncontent = os.popen(\"python3 ./reverse_mt_rand.py \" +\n                   firstnum+' '+lastnum+' 0 0').read()\nq = requests.post(url+'/verify.php', headers=headers, data=&#123;'ans': content&#125;)\nprint(q.text)\n Go\n// backup my secret key into DB\n_, err = db.Exec(fmt.Sprintf(`INSERT INTO secret(secret) VALUES('%s');`, secretKey))\nif err != nil &#123;\n    return err\n&#125;\n\nif u.TotalBalance > 999999 || win &#123;\n    flag = os.Getenv(\"flag\")\n&#125; else &#123;\n    flag = \"nothing to show, to be a winner\"\n&#125;\n\n  function changePrismTheme(e) {\n    let text = e.target.innerHTML;\n    let linkList = document.head.getElementsByTagName('link');\n    for(let item of linkList) {\n      if(item.dataset.prism) {\n        document.head.removeChild(item);\n      }\n    }\n    let link = document.createElement('link');\n    link.rel = 'stylesheet';\n    link.dataset.prism = text;\n    if(text === 'default') {\n      text = 'prism';\n    } else {\n      text = 'prism-' + text;\n    }\n    link.href='/js/lib/prism/' + text +'.min.css';\n    document.head.appendChild(link);\n  }\n  setTimeout(() => {\n    let buttonList = document.getElementsByClassName('postbutton');\n    Array.prototype.forEach.call(buttonList, item => {\n      item.onclick = changePrismTheme;\n    });\n  }, 0);\n\n","categories":["知识","BLOG","Kaze"],"tags":["Kaze","BLOG"]},{"title":"公式渲染","url":"/posts/13098.html","content":" 简介\n 启用公式\n本主题支持 mathjax 和 katex 两大渲染引擎，您可以在博客主题设置 latex 中  enable: true 启用。\n 更换渲染器\n由于Hexo本身渲染器的冲突，有一部分公式无法渲染，建议采用其他渲染器，首先\nnpm uninstall hexo-renderer-marked -S\n之后 mathjax推荐 hexo-renderer-kramed，katex推荐 hexo-renderer-markdown-it-plus\nnpm install hexo-renderer-kramed -S\nnpm install hexo-renderer-markdown-it-plus -S\n注意，您只可以保留一个渲染器\n 演示\n以下所有公式均通过 katex 渲染\n 整行公式\nf(a)=12πi∮f(z)z−adzf(a) = \\frac{1}{2\\pi i} \\oint\\frac{f(z)}{z-a}dz\nf(a)=2πi1​∮z−af(z)​dz\ncos⁡(θ+ϕ)=cos⁡(θ)cos⁡(ϕ)−sin⁡(θ)sin⁡(ϕ)\\cos(\\theta+\\phi)=\\cos(\\theta)\\cos(\\phi)−\\sin(\\theta)\\sin(\\phi)\ncos(θ+ϕ)=cos(θ)cos(ϕ)−sin(θ)sin(ϕ)\n∫D(∇⋅F)dV=∫∂DF⋅ndS\\int_D ({\\nabla\\cdot} F)dV=\\int_{\\partial D} F\\cdot ndS\n∫D​(∇⋅F)dV=∫∂D​F⋅ndS\n∇⃗×F⃗=(∂Fz∂y−∂Fy∂z)i+(∂Fx∂z−∂Fz∂x)j+(∂Fy∂x−∂Fx∂y)k\\vec{\\nabla} \\times \\vec{F} =\\left( \\frac{\\partial F_z}{\\partial y} - \\frac{\\partial F_y}{\\partial z} \\right) \\mathbf{i}+ \\left( \\frac{\\partial F_x}{\\partial z} - \\frac{\\partial F_z}{\\partial x} \\right) \\mathbf{j}+ \\left( \\frac{\\partial F_y}{\\partial x} - \\frac{\\partial F_x}{\\partial y} \\right) \\mathbf{k}\n∇×F=(∂y∂Fz​​−∂z∂Fy​​)i+(∂z∂Fx​​−∂x∂Fz​​)j+(∂x∂Fy​​−∂y∂Fx​​)k\nσ=1N∑i=1N(xi−μ)2\\sigma = \\sqrt{ \\frac{1}{N} \\sum_{i=1}^N (x_i -\\mu)^2}\nσ=N1​i=1∑N​(xi​−μ)2​\n(∇XY)k=Xi(∇iY)k=Xi(∂Yk∂xi+ΓimkYm)(\\nabla_X Y)^k = X^i (\\nabla_i Y)^k =X^i \\left( \\frac{\\partial Y^k}{\\partial x^i} + \\Gamma_{im}^k Y^m \\right)\n(∇X​Y)k=Xi(∇i​Y)k=Xi(∂xi∂Yk​+Γimk​Ym)\ndet(JG)=∂xd+1∂zd+1∂xd+2∂zd+2...∂xD∂zD=βd+1βd+2...βDdet(J_G) =\\frac{\\partial{x_{d+1}}}{\\partial{z_{d+1}}}\\frac{\\partial{x_{d+2}}}{\\partial{z_{d+2}}}...\\frac{\\partial{x_D}}{\\partial{z_D}} \\\\\n=β_{d+1}β_{d+2}...β_{D}\ndet(JG​)=∂zd+1​∂xd+1​​∂zd+2​∂xd+2​​...∂zD​∂xD​​=βd+1​βd+2​...βD​\n 行内公式\n求根公式是x=−b±b2−4ac2ax = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}x=2a−b±b2−4ac​​\nE=mc2E=mc^2E=mc2是质能方程式\n对于一个序列a1,a2,⋯ ,ama_1,a_2,\\cdots,a_ma1​,a2​,⋯,am​，有a1+a2+⋯+am=2⋅(a1⊕a2⊕⋯⊕am)a_1+a_2+\\cdots+a_m=2\\cdot(a_1\\oplus a_2\\oplus\\cdots\\oplus a_m)a1​+a2​+⋯+am​=2⋅(a1​⊕a2​⊕⋯⊕am​)\n","categories":["知识","BLOG","Kaze"],"tags":["Kaze","BLOG"]},{"title":"STL-快速排序","url":"/posts/32547.html","content":" 一、快速排序\n Ⅰ. 格式\nsort(arr+m,arr+n,cmp);\n将数组 $ arr $ 中下标为 $ m $ 的元素到下标为 $ n-1 $ 的元素，按照定义的函数 $ cmp $ 中的规则排序。\n Ⅱ. 排序规则\nint cmp(const int &amp;a,const int &amp;b)\n&#123;\n    return a&gt;b;\n&#125;\n如上的排序规则为从大到小排序，当 $ a=b $ 时应返回 $ 0 $ 。可以对结构体排序。\n必须包含头文件 algorithm\\color{red} {algorithm}algorithm 。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"文件操作","url":"/posts/16177.html","content":" 一、重定向型\n格式：\nFILE *freopen(const char *filename, const char *mode, FILE *stream );\n\nfreopen(&quot;pro.in&quot;,&quot;r&quot;,stdin);\nfreopen(&quot;pro.out&quot;,&quot;w&quot;,stdout);\nfclose(stdin);\nfclose(stdout);\n$ filename $ 要打开的文件名\n$ mode $ 文件打开的模式，和 $ fopen $ 中的模式（ $ r/w $ ）相同\n$ stream $ 文件指针，通常使用标准流文件（ $ stdin/stdout/stderr $ ）\n其中 $ stdin $ 是标准输入流，默认为键盘；$ stdout $ 是标准输出流，默认为屏幕；$ stderr $ 是标准错误流，一般把屏幕设为默认。通过调用 $ freopen $ ，就可以修改标准流文件的默认值，实现重定向。\n使用 $ freopen() $ 函数的优点：\n我们不再需要修改 $ scanf $ ，$ printf $ ，$ cin $ 和 $ cout $ 。而是维持代码的原样就可以了。因为 $ freopen() $ 函数重定向了标准流，使其指向前面指定的文件，省时省力。最后只要使用 $ fclose $ 关闭输入文件和输出文件即可。\n需调用头文件 $ \\color{red} {cstdio} $ 。\n 二、$ fopen $ 型\n格式：\n#include &lt;cstdio&gt;\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint a, b, c;\nchar s[20];\nFILE *fin, *fout;\n\nint main()\n&#123;\n    fin &#x3D; fopen(&quot;pro.in&quot;, &quot;rb&quot;);\n    fout &#x3D; fopen(&quot;pro.out&quot;, &quot;wb&quot;);\n    fscanf(fin, &quot;%d %d&quot;, &amp;a, &amp;b);\n    scanf(&quot;%d&quot;, &amp;c);\n    fprintf(fout, &quot;%d&quot;, a + b + c);\n    printf(&quot;%d&quot;, a * b * c);\n    return 0;\n&#125;\n\npro.in输入：  1 2\n终端输入：    4\npro.out输出： 7\n终端输出：    8\n$ fopen $ 对 $ scanf,printf $ 适用。\n先声明变量 $ fin $ 和 $ fout $ ，把 $ scanf $ 改成 $ fscanf $ ，第一个参数为 $ fin $ ；把 $ printf $ 改成 $ fprintf $ ，第一个参数为 $ fout $ ，最后执行 $ fclose $ ，关闭两个文件。\n 三、文件输入输出流\n格式：\n#include &lt;fstream&gt;\n\nusing namespace std;\n\nint a, b, c;\nchar s[20];\n\nint main()\n&#123;\n    ifstream fin(&quot;pro.in&quot;);\n    ofstream fout(&quot;pro.out&quot;);\n    fin &gt;&gt; a &gt;&gt; b;\n    fout &lt;&lt; a + b;\n    return 0;\n&#125;\n若想用fin作为输入对象，fout作为输出对象，则可以使用如下定义：\nifstream  fin(&quot;输入文件名.扩展名&quot;);\nofstream  fout(&quot;输出文件名.扩展名&quot;);\n如果想再次使用cin和cout，只需要把fin和fout的声明语句去掉，并加上这样两行即可：\n#define fin cin\n#define fout cout","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-函数","url":"/posts/52970.html","content":" 一、函数\n Ⅰ. 定义\n定义方式：\n数据类型 函数名(形参)\n&#123;\n    函数体；\n&#125;\n\nint add(int a,int b)\n&#123;\n    return a+b;\n&#125;\n\n函数的数据类型是函数的返回值类型，若类型为 voidvoidvoid 则无返回值。\n形参可以是空的，但圆括号必须存在。\n\n Ⅱ. 函数的声明\n方式：\n数据类型 函数名(形参);\n\nint add(int a,int b);   &#x2F;&#x2F;或者int add(int,int);\n若函数在调用之前定义，则无需声明。\n Ⅲ. 函数的调用\n ① 传值调用\n方式：\nint x, y;\n\nvoid swap(int a, int b)\n&#123;\n    int t;\n    t &#x3D; a, a &#x3D; b, b &#x3D; t;\n    return;\n&#125;\n\nint main()\n&#123;\n    x &#x3D; 1, y &#x3D; 2;\n    swap(x, y);\n    printf(&quot;%d %d&quot;, x, y);\n    return 0;\n&#125;\n\n输出：1 2\n传值调用时，将全局变量 x,yx,yx,y 的值赋予局部变量 a,ba,ba,b ，虽函数内交换了 a,ba,ba,b 的值但 x,yx,yx,y 的值并未被影响。\n ② 传址调用\n方式：\nint x, y;\n\nvoid swap(int &amp;a, int &amp;b)\n&#123;\n    int t;\n    t &#x3D; a, a &#x3D; b, b &#x3D; t;\n    return;\n&#125;\n\nint main()\n&#123;\n    x &#x3D; 1, y &#x3D; 2;\n    swap(x, y);\n    printf(&quot;%d %d&quot;, x, y);\n    return 0;\n&#125;\n\n输出：2 1\n与①中相比，函数的形参变成了指针，此时传入局部变量 a,ba,ba,b 的是全局变量 x,yx,yx,y 的内存地址，进行交换时直接对内存地址里的内容造成影响，相当于交换 x,yx,yx,y 的值。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-字符串","url":"/posts/61271.html","content":" 一、字符数组\n字符数组定义格式同一般数组，但数组类型使字符型。\n字符数组的初始化：\nchar s1[5]&#x3D;&#123;&#39;a&#39;,&#39;b,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;&#125;;    &#x2F;&#x2F;存单个字符\nchar s2[6]&#x3D;&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;,&#39;\\0&#39;&#125;;  &#x2F;&#x2F;存字符串，注意虽然只有五个字符，但数组要开到6，因为第六位要存结束符\\0\nchar s[3][4]&#x3D;&#123;&quot;abc&quot;,&quot;def&quot;,&quot;ghi&quot;&#125;;   &#x2F;&#x2F;用字符串给二维字符数组初始化，相当于存了三个字符串分别于s[0],s[1],s[2]中\n当初始化的元素个数少于数组总个数时，其余位数为空字符。\n字符数组中也可以存放若干个字符，也可以来存放字符串。两者的区别是字符串有一结束符( \\0 )。反过来说，在一维字符数组中存放着带有结束符的若干个字符称为字符串。字符串是一维数组，但是一维字符数组不等于字符串。\n 二、字符与字符串的区别\n\n两者的定界符不同，字符常量由单引号括起来，字符串常量由双引号括起来。\n字符常量只能是单个字符，字符串常量则可以是多个字符。\n可以把一个字符常量赋给一个字符变量，但不能把一个字符串常量赋给一个字符变量。\n字符常量占一个字节，而字符串常量占用字节数等于字符串的字节数加 $ 1 $ 。增加的一个字节中存放字符串结束标志 ‘\\0’ 。例如：字符常量 ‘a’ 占一个字节，字符串常量 “a” 占二个字节。\n\n 三、字符串输入与输出\n Ⅰ. 输入\n ① 使用 $ scanf $ 读入：\nscanf(&quot;%s&quot;,s1);\n\nscanf(&quot;%s%s%s&quot;,s1,s2,s3);\n输入：a b c\n结果：s1&#x3D;&#39;a&#39;    s2&#x3D;&#39;b&#39;     s3&#x3D;&#39;c&#39;\n\nscanf(&quot;%s&quot;,s1);\n输入：a b c\n结果：s1&#x3D;&#39;a&#39;    s2&#x3D;&#39;&#39;      s3&#x3D;&#39;&#39;\n\n这里的字符串名称之前不加 ‘&amp;’ 这个取地址符。\n系统会自动在输入的字符串常量后添加 ‘\\0’ 标志，因此输入时，仅输入字符串的内容即可。\n输入多个字符串时，以空格分隔。如果仅有一个输入字符串名称的情况下，字符串变量仅获取空格前的内容。\n\n ② 使用 $ gets $ 读入：\ngets(s1);   &#x2F;&#x2F;不能gets(s1,s2);\n\n使用 $ gets $ 只能输入一个字符串。\n使用 $ gets $ ，是从光标开始的地方读到换行符也就是说读入的是一整行，而使用 $ scanf $ 是从光标开始的地方到空格，如果这一行没有空格，才读到行尾。\n\n Ⅱ. 输出\n ① 使用 $ printf $ 输出：\nprintf(&quot;$s&quot;,s1);\n\n用 ‘%s’ 格式输出时，$ printf $ 的输出项只能是字符串(字符数组)名称，而不能是数组元素。\n输出字符串不包括字符串结束标志符 ‘\\0’ 。\n\n ② 使用 $ puts $ 输出：\nputs(s1);   &#x2F;&#x2F;和scanf(&quot;%s\\n&quot;,s1);等价\n 四、字符串处理函数\n\n\n\n函数类型\n作用\n\n\n\n\n$ strcat(str1,str2) $\n将$ str2 $ 接到 $ str1 $ 之后，结果返回 $ str1 $\n\n\n$ strncat(str1,str2,n) $\n将$ str2 $ 的前 $ n $ 个字符接到 $ str1 $ 之后，结果返回 $ str1 $\n\n\n$ strcpy(str1,str2) $\n将$ str2 $ 赋值给 $ str1 $ ，结果返回 $ str1 $\n\n\n$ strncpy(str1,str2,n) $\n将$ str2 $ 的前 $ n $ 个字符赋值给 $ str1 $ ，结果返回 $ str1 $\n\n\n$ strcmp(str1,str2) $\n比较$ str1 $ 和 $ str2 $ 的大小，结果（ $ -1,0,1 $ ）返回函数本身\n\n\n$ strncmp(str1,str2,n) $\n比较$ str1 $ 和 $ str2 $ 前 $ n $ 个字符的大小，结果（ $ -1,0,1 $ ）返回函数本身\n\n\n$ strlen(str) $\n计算$ str $ 的长度，终止符 $ \\text{\\0} $ 不算在长度之内，结果返回函数本身\n\n\n$ strlwr(str) $\n将$ str $ 中的字母全部换为小写\n\n\n$ strupr(str) $\n将$ str $ 中的字母全部换为大写\n\n\n\n使用以上函数，必须包含头文件 $ \\color{red} {cstring} $ 。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-数组","url":"/posts/58653.html","content":" 一、一维数组\n Ⅰ. 一维数组的定义和使用\n定义：\n数据类型 数组名[常量表达式];\n\nint a[100];\nint b[10*5];\na[10]a[10]a[10] 表示数组 aaa 中有 101010 个元素，分别是 a0,⋯ ,a9a_0 , \\cdots , a_9a0​,⋯,a9​ ，注意没有 a10a_{10}a10​ 。\n数组引用：\n数组名[常量表达式]\n\na[1]\nb[i++]\nc[i+j]\nC++C++C++ 中直能引用数组元素，不能引用整个数组。\n Ⅱ. 一维数组的操作\n初始化：\n变量类型 数组名[常量表达式]&#x3D;&#123;值1,值2,...&#125;;\n\nint a[5]&#x3D;&#123;1,2,3,4,5&#125;;\nint b[10]&#x3D;&#123;1,2,3&#125;;   &#x2F;&#x2F;此时对前三个元素初始化成括号内的值，其余元素初始化为0\nint c[5]&#x3D;&#123;&#125;;    &#x2F;&#x2F;将所有元素初始化为0\n赋值:\nmemcpy(b,a,(变量类型)*k);   &#x2F;&#x2F;从数组a中复制k个元素到数组b\nmemcpy(b,a,sizeof(a));  &#x2F;&#x2F;将数组a整个复制到数组b\nmemset(a,0,sizeof(a));  &#x2F;&#x2F;将数组a中每个元素都赋值为0\n和 PascalPascalPascal 不同，在 C++C++C++ 中数组不能进行赋值操作。使用以上操作时需包含头文件 cstring\\color{red} {cstring}cstring 。\n 二、多维数组\n定义：\n变量类型 数组名[常量表达式1][常量表达式2]...[常量表达式n];\n\nint a[5][5];\nint b[10][5][5];\n二维数组初始化：\n变量类型 数组名[常量表达式1][常量表达式2]&#x3D;&#123;值,...&#125;;\n\nint a[2][3]&#x3D;&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;;","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-循环结构","url":"/posts/23530.html","content":" 一、$ for $ 语句\n使用方式：\nfor (循环变量初值;条件表达式;增值表达式)\n&#123;\n    语句1；\n    语句2；\n    ...\n&#125;\n\nfor (i&#x3D;0;i&lt;&#x3D;5;i++)\nfor语句的执行过程可由以下 $ 4 $ 步来描述。\n①执行“控制变量初始化语句”，使控制变量获得一个初值。\n②判断控制变量是否满足“条件表达式”，若满足条件则执行一遍循环体，否则结束整个for语句，继续执行 $ for $ 循环下面的句子。\n③根据增量表达式，计算出控制变量所得到的新值\n④自动转到第②步。\n可以在 $ for $ 循环“循环变量初值”中声明变量，这些变量只在 $ for $ 循环结构中有效，离开了该 $ for $ 结构，变量就无效了。如：\nfor (int i&#x3D;0;i&lt;&#x3D;5;i++)\n 二、$ while $ 语句\n使用方式：\nwhile (条件表达式)\n&#123;\n    语句1；\n    语句2；\n    ......\n&#125;\n先判断条件表达式，若条件表达式为真，则执行循环体，否则跳出循环体。\n 三、$ do-while $ 语句\n使用方式：\ndo\n&#123;\n    语句1；\n    语句2；\n    ......\n&#125;\nwhile (条件表达式)\n先执行循环体，再判断条件表达式，若条件表达式为真，则再次执行循环体，否则跳出循环体。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-选择结构","url":"/posts/26987.html","content":" 一、$ if $ 选择结构\n Ⅰ. $ if $ 语句\n使用方式：\nif (条件表达式) &#123;执行内容&#125;\nif (a&lt;&#x3D;10) &#123;a++;&#125;\n当 $ \\color{red}{条件表达式} $ 成立时，$ \\color{red}{执行内容} $ 才会被执行，否则会被跳过。\n Ⅱ. $ else $ 语句\n使用方式：\nif (条件表达式) &#123;执行内容1&#125;\nelse &#123;执行内容2&#125;\n\nif (a&lt;&#x3D;10) &#123;a++;&#125;\nelse &#123;a--;&#125;\n当 $ \\color{red}{条件表达式} $ 成立时，$ \\color{red}{执行内容1} $ 会被执行，否则 $ \\color{red}{执行内容2} $ 会被执行。\n和 $ Pascal $ 相同，$ C++ $ 中 $ if $ 也可以嵌套。\n Ⅲ. 三目运算符 $ ?: $\n使用方式：\n变量&#x3D;条件表达式?值1:值2;\n\na&#x3D;3&#x3D;&#x3D;9?1:2;\n结果：a&#x3D;2\n当 $ \\color{red}{条件表达式} $ 成立时，变量为 $ \\color{red}{值1} $ ，否则变量为 $ \\color{red}{值2} $ 。\n 二、$ switch $ 选择结构\n使用方式：\nswitch (表达式)\n&#123;\ncase 常量表达式1:\n     执行内容1;\n     break;\ncase 常量表达式2:\n     执行内容2;\n     break;\ncase 常量表达式3:\n     执行内容3;\n     break;\n......\ndefault:\n     执行内容n;\n&#125;\n\na&#x3D;1;\nswitch (a)\n    &#123;\n    case 2:\n        printf(&quot;b&quot;);\n    case 1:\n        printf(&quot;a&quot;);\n    &#125;\n输出：a\n\na&#x3D;1;\nswitch (a)\n    &#123;\n    case 1:\n        printf(&quot;a&quot;);\n    case 2:\n        printf(&quot;b&quot;);\n    &#125;\n输出：ab\n$ switch $ 语句执行过程分为以下 $ 3 $ 步：\n①计算出 $ switch $ 后面圆括号内表达式的值，假定为 $ M $ ，若它不是整型，系统将自动舍去其小数部分，只取其整数部分作为结果值。\n②依次计算出每个 $ case $ 后常量表达式的值，假定它们为 $ M_1,M_2,\\cdots $ ，同样若它们的值不是整型，则自动转换为整型。\n③让 $ M $ 依次同 $ M_1,M_2,\\cdots $ 进行比较，一旦遇到 $ M $ 与某个值相等，则就从对应标号的语句开始执行；在碰不到相等的情况下，若存在 $ default $ 语句，则就执行其冒号后面的语句序列，否则不执行任何操作；当执行到复合语句最后的右花括号时就结束整个 $ switch $ 语句的执行。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"基础语法-顺序结构","url":"/posts/20389.html","content":" 一、常量和变量\n Ⅰ. 常量\n 定义：\nconst 常量类型 常量符号&#x3D;常量；\nconst int a&#x3D;100;\n 类型：\n① 整形常量：\n十进制：$ 100_{(10)},-1_{(10)} $\n八进制：以 $ 0 $ 开头，后由 $ 0 \\backsim 7 $ 的字符构成。如 $ 012 $ 表示 $ 12_{(8)} $\n十六进制：以 $ 0x $ 开头，后由 $ 0 \\backsim F $ 的字符构成。如 $ 0xF1A $ 表示 $ F1A_{(16)} $ 。\n② 实型常量：\n实型有两种写法，其一是直接写出数值，如 $ 1.3,-0.18 $ ，第二种使用科学计数法表示，如：\nM E XM \\ E \\ X\nM E X\n其中 $ M $ 为一个实数， $ X $ 为一个整数。\n其意味着：\nM×10XM \\times 10^X\nM×10X\n1.52 E 2=1.52×102=1521.52 \\ E \\ 2=1.52 \\times 10^2 =152\n1.52 E 2=1.52×102=152\n152 E −2=152×10−2=1.52152 \\ E \\ -2=152 \\times 10^{-2}=1.52\n152 E −2=152×10−2=1.52\n③ 字符型常量：\n如‘a’、‘1’、‘?’，注意 &lt;font color='red'&gt;‘’&lt;/font&gt;不能省去，且‘a’表示一个 &lt;font color='red'&gt;字符 &lt;/font&gt;，“a”表示一个 &lt;font color='red'&gt;字符串 &lt;/font&gt;。\n Ⅱ. 变量\n 定义：\n变量类型 变量名，变量名，......；\nint a,b;\nchar s,k;\nfloat n,m;\n和 $ Pascal $ 中不同， $ C++ $ 可以在定义时给变量赋值，如：\nint a&#x3D;100;\nchar s&#x3D;&#39;x&#39;;\nfloat n&#x3D;5E2;\n 变量类型：\n变量的类型可以是标准数据类型（$ int,long \\ long,char,float,double,\\cdots $），也可以是用户自定义的类型（结构体）。\n 二、标准数据类型\n这些数据类型都是由系统定义的简单数据类型。\n Ⅰ. 整形\n\n\n\n数据类型\n$ C++ $ 定义标识符\n$ Pascal $ 定义标识符\n占字节数\n取值范围\n\n\n\n\n短整型\n$ short $\n$ integer $\n$ 2 $\n$ [-2{15},2{15}-1] $\n\n\n无符号短整型\n$ unsigned \\ short $\n$ word $\n$ 2 $\n$ [0,2^{16}-1] $\n\n\n长整型\n$ long $\n$ longint $\n$ 4 $\n$ [-2{31},2{31}-1] $\n\n\n无符号长整形\n$ unsigned \\ long $\n$ dword $\n$ 4 $\n$ [0,2^{32}-1] $\n\n\n超长整形\n$ long \\ long $\n$ int64 $\n$ 8 $\n$ [-2{63},2{63}-1] $\n\n\n无符号超长整形\n$ unsigned \\ long \\ long $\n$ qword $\n$ 8 $\n$ [0,2^{64}-1] $\n\n\n\n Ⅱ. 实型\n\n\n\n数据类型\n$ C++ $ 定义标识符\n$ Pascal $ 定义标识符\n占字节数\n取值范围\n有效位数\n\n\n\n\n单精度实型\n$ float $\n$ real $\n$ 4 $\n$ [-3.4E+38,3.4E+38] $\n$ 6 $\n\n\n双精度实型\n$ double $\n$ double $\n$ 8 $\n$ [-1.7E+308,1.7E+308] $\n$ 15 $\n\n\n长双精度实型\n$ long \\ double $\n$ extended $\n$ 16 $\n$ [-3.4E+4932,1.1E+4932] $\n$ 18 $\n\n\n布尔型\n$ bool $\n$ boolean $\n$ 1 $\n$ true,false $\n$ \\diagdown $\n\n\n\n Ⅲ. 字符型\n见 $ ASCLL $ 码表。\n\n Ⅳ. 强制类型转换\n(类型名)(表达式)\n(int)(4.7)&#x3D;4;\n 三、输入与输出\n Ⅰ. 字符输入输出\n函数：$ getchar(),putchar() $\n使用此函数必须包含头文件 &lt;font color='red'&gt;cstdio &lt;/font&gt;。\n使用方式：\n字符型变量&#x3D;getchar();\nputchar(字符型变量&#x2F;ASCLL码);\n\nchar s;\ns&#x3D;getchar();\nputchar(s);\nputchar(66);\n\n输入：Z\n输出：ZB\n$ getchar() $ 输入的所有元素都按字符处理，且可以 &lt;font color='red'&gt;读入回车 &lt;/font&gt;。\n Ⅱ. 流输入输出\n函数：$ cin,cout,endl $\n使用此函数必须包含头文件 &lt;font color='red'&gt;iostream &lt;/font&gt;，且需使用 &lt;font color='red'&gt;using namespace std;&lt;/font&gt;。\n使用方式：\ncin&gt;&gt;变量；\ncout&lt;&lt;变量&#x2F;字符串；\n\ncin&gt;&gt;a&gt;&gt;b;\ncout&lt;&lt;&quot;a&#x3D;&quot;&lt;&lt;a&lt;&lt;&quot;\\nb&#x3D;&quot;&lt;&lt;b&lt;&lt;endl;\ncout&lt;&lt;&quot;A&quot;;\n\n输入：1 A\n输出：\na&#x3D;1\nb&#x3D;A\nA\n Ⅲ. 格式化输入输出\n函数：$ scanf,printf $\n使用此函数必须包含头文件 &lt;font color=&quot;red&quot;&gt;cstdio &lt;/font&gt;。\n使用方法：\nscanf(&quot;格式符 格式符&quot;,&amp;变量,&amp;变量);\nprintf(&quot;格式符 格式符&quot;,变量,变量);\n\nscanf(&quot;%d%c&quot;,&amp;a,&amp;b);\nprintf(&quot;a&#x3D;%d\\nb&#x3D;%c\\nA&quot;,a,b);\n\n输入：1A\n输出：\na&#x3D;1\nb&#x3D;A\nA\n$ scanf $ 中的 &lt;font color=&quot;green&quot;&gt;&amp;变量 &lt;/font&gt;是变量的内存地址，可以是变量地址，也可以是字符串首地址。\n 输入格式符：\n\n\n\n符号\n说明\n\n\n\n\n$ d $\n输入十进制整数\n\n\n$ u $\n以无符号形式输入十进制整数\n\n\n$ o $\n输入八进制整数\n\n\n$ x $\n输入十六进制整数\n\n\n$ c $\n输入单个字符\n\n\n$ s $\n输入字符串\n\n\n$ f $\n输入实数\n\n\n\n\n\n\n附加格式\n说明\n\n\n\n\n$ l $\n输入长整型数（$ ld,lo,lx $）和 $ double $ 型实数（$ lf $）\n\n\n$ h $\n输入短整型数（$ hd,ho,hx $）\n\n\n域宽（一个整数）\n指定输入所占列宽\n\n\n$ * $\n表示对应输入值不赋给变量\n\n\n\n 输出格式符\n\n\n\n符号\n说明\n\n\n\n\n$ d $\n输出十进制整数\n\n\n$ u $\n以无符号形式输出十进制整数\n\n\n$ o $\n输出八进制整数\n\n\n$ x $\n输出十六进制整数\n\n\n$ c $\n输出单个字符\n\n\n$ s $\n输出字符串\n\n\n$ f $\n以小数形式输出实数\n\n\n$ e $\n以科学记数法形式输出实数\n\n\n\n\n\n\n参数\n说明\n\n\n\n\n$ m $\n指定宽度，实际宽度不足$ m $ 时补空格，大于 $ m $ 时按实际宽度输出\n\n\n$ .n $\n不对整形使用，对于实型表示保留$ n $ 位小数，对于字符串表示最多含有 $ n $ 个字符\n\n\n$ - $\n表示左对齐\n\n\n$ l $\n输出长整型\n\n\n$ 0 $\n跟$ m $ 一起使用，表示宽度不足 $ m $ 时补 $ 0 $\n\n\n\n使用格式：$ %,-,0,m,.n,l $\nscanf(&quot;%2d%3d%4d&quot;,&amp;a,&amp;b,&amp;c);\nscanf(&quot;%f&quot;,&amp;d);\nscanf(&quot;%5s&quot;,&amp;s);\nprintf(&quot;a&#x3D;%d\\nb&#x3D;%d\\nc&#x3D;%d\\nd&#x3D;%.5f\\ns&#x3D;%7.3s\\n&quot;,a,b,c,d,s);\n\n输入：\n123456789\n512E-2\nabcdefg\n输出：\na&#x3D;12\nb&#x3D;345\nc&#x3D;6789\nd&#x3D;5.12000\ns&#x3D;    abc\n 四、运算符与表达式\n Ⅰ. 赋值语句\n变量&#x3D;表达式;\na&#x3D;10*19;\na&#x3D;b&#x3D;c&#x3D;d&#x3D;100;\n Ⅱ. 算术运算符\n\n\n\n类型\n运算符\n\n\n\n\n加\n$ + $\n\n\n减\n$ - $\n\n\n乘\n$ * $\n\n\n除\n$ / $\n\n\n取模\n$ % $\n\n\n\n表达式+表达式\n表达式-表达式\n表达式*表达式\n表达式&#x2F;表达式\n表达式%表达式\n\n1+1&#x3D;2;\n1-1&#x3D;0;\n1*2&#x3D;2;\n5&#x2F;2&#x3D;2;\n5.0&#x2F;2&#x3D;2.5;\n5&#x2F;2.0&#x3D;2.5;\n5%2&#x3D;1;\n$ a++ $ 表示调用 $ a $ 后将 $ a+1 $ 。\n$ ++a $ 表示将 $ a+1 $ 后再调用 $ a $ 。（减法相同）\n Ⅲ. 关系运算符\n\n\n\n类型\n运算符\n\n\n\n\n大于\n$ &gt; $\n\n\n小于\n$ &lt; $\n\n\n等于\n$ == $\n\n\n大于等于\n$ &gt;= $\n\n\n小于等于\n$ &lt;= $\n\n\n不等于\n$ != $\n\n\n\n关系运算符的结果只能是 $ 0(false) $ 或 $ 1(true) $ 。\n Ⅳ. 逻辑运算符\n\n\n\n类型\n运算符\n\n\n\n\n与\n$ &amp;&amp; $\n\n\n或\n$\n\n\n非\n$ ! $\n\n\n\n与运算符(&amp;&amp;)和或运算符(||)均为双目运算符，具有左结合性。 非运算符(!)为单目运算符，具有右结合性。\n逻辑运算符的结果只能是 $ 0(false) $ 或 $ 1(true) $ 。\n Ⅴ. 位运算符\n\n\n\n类型\n运算符\n\n\n\n\n按位与\n$ &amp; $\n\n\n按位或\n$\n\n\n按位异或\n$ \\land $\n\n\n取反\n$ \\sim $\n\n\n左移\n$ &lt;&lt; $\n\n\n右移\n$ &gt;&gt; $\n\n\n\n Ⅵ. 运算表达式简写\n变量&#x3D;变量 运算符 表达式\n变量 运算符&#x3D;表达式\n\na&#x3D;a+2;\na+&#x3D;2;\n Ⅶ. 常用运算函数\n\n\n\n类型\n函数\n\n\n\n\n绝对值\n$ abs(x) $\n\n\n自然数指数$ e^x $\n$ exp(x) $\n\n\n下取整\n$ floor(x) $\n\n\n上取整\n$ ceil(x) $\n\n\n自然数对数$ \\ln{x} $\n$ log(x) $\n\n\n指数函数$ x^t $\n$ pow(x,t) $\n\n\n随机函数（在$ [0,x-1] $ 生成随机数）\n$ rand(x) $\n\n\n平方根\n$ sqrt(x) $\n\n\n\n使用这类函数时，必须包含头文件 &lt;font color=&quot;red&quot;&gt;cmath &lt;/font&gt;。\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"写出第一个C++程序","url":"/posts/15963.html","content":"$ Pascal $ 作为我参加信息学竞赛使用的语言，伴随我走过了多年的时光，但随着计算机语言的发展，它已经逐渐被淘汰。我也必须跟上步伐，学习现在普遍使用的高级语言 $ C++ $ 。\n\n 第一个程序 $ Hello \\ World $\n#include &lt;iostream&gt;\n\nusing namespace std;\n\nint main()\n&#123;\n    cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endl;\n    return 0;\n&#125;\n这可以算作是一个模板的 $ C++ $ 程序，首先要写出使用的头文件，之后是主函数（main），主函数在程序中一定最先开始执行。主函数如果正常结束就会返回 $ 0 $ ，否则会返回其他的值。\n 头文件\n使用 $ C++ $ 编写程序和 $ Pascal $ 还是有很大的不同的，最为主要的就是 $ C++ $ 中的 &lt;font color='red'&gt;头文件 &lt;/font&gt;，这些是调用 $ C++ $ 函数库的必须手段。\n其使用方式为：\n#include &lt;头文件名称&gt;\n 这里先总结一些常用的头文件：\n Ⅰ. $ iostream $ :\n包括函数：$ cin,cout,endl $\n注意：该头文件没有定义全局命名空间，必须使用 $ using \\ namespace \\ std; $\n Ⅱ. $cstdio $ :\n包括函数：$ getchar,putchar,scanf,printf,freopen $\n Ⅲ. $ cstring $ :\n包括函数：$ memset $\n","categories":["编程语言","C++"],"tags":["C++"]},{"title":"长沙集训-2019-08-21","url":"/posts/18025.html","content":" &lt;center&gt;长沙集训 $ Day 3 $ 2019-08-21 &lt;/center&gt;\n 得分：$ 193/300 $\n\n T1 $ Matrix $\n\n 基本思路\n此题可以用枚举解决，分别枚举每一列作为矩形中间点统计答案，最后取最大值。每次统计答案时，分别算出每一列相邻的 $ 1 $ 的个数 $ sum $：\n\n之后从该列向两边查找（其实只向一边也可以），如果当前枚举的列为 $ k $ ，查找到的列为 $ i $ ，则答案为 $ |i-j| \\cdot sum[i] $ 。\n直接暴力查找的时间复杂度时 $ O(n \\cdot m^2) $ ，为了加快速度，可以预处理出以 $ i $ 为中心的每行连续 $ 1 $ 的左右端点，之后计算 $ sum $ 时用前缀和处理。使时间复杂度降低为 $ O(n \\cdot m) $ 。\n 程序\nprogram matrix;\n\ntype tp&#x3D;record\n  l,r:longint;\nend;\n\nvar\n   f:array[0..1005,0..1005]of tp;\n   a:array[0..1005,0..1005]of integer;\n   sum:array[0..1005]of longint;\n   n,m:longint;\n\nfunction max(a,b:longint):longint;\nbegin\n  if a&gt;b then exit(a)\n    else exit(b);\nend;\n\nprocedure re;\nvar i,j:longint;\n    s:ansistring;\nbegin\n  for i:&#x3D;1 to n do begin\n    readln(s);\n    for j:&#x3D;1 to m do\n      if s[j]&#x3D;&#39;0&#39; then a[i,j]:&#x3D;0\n        else a[i,j]:&#x3D;1;\n  end;\nend;\n\nprocedure first;\nvar i,j,loc:longint;\n    t:boolean;\nbegin\n  for i:&#x3D;1 to n do begin\n    loc:&#x3D;1;\n    t:&#x3D;false;\n    for j:&#x3D;1 to m do\n      if a[i,j]&lt;&gt;0 then begin\n        if t&#x3D;true then begin\n          f[i,j].l:&#x3D;f[i,j-1].l;\n          f[i,j].r:&#x3D;f[i,j-1].r;\n        end\n          else begin\n            while a[i,loc]&lt;&gt;0 do inc(loc);\n            t:&#x3D;true;\n            f[i,j].l:&#x3D;j;\n            f[i,j].r:&#x3D;loc;\n          end;\n      end\n        else begin\n          t:&#x3D;false;\n          inc(loc);\n        end;\n  end;\nend;\n\nfunction ans(x:longint):longint;\nvar i,t:longint;\nbegin\n  fillchar(sum,sizeof(sum),0);\n  for i:&#x3D;1 to n do\n    if a[i,x]&#x3D;1 then begin\n      inc(sum[f[i,x].l]);\n      dec(sum[f[i,x].r]);\n    end;\n  for i:&#x3D;1 to n do\n    sum[i]:&#x3D;sum[i]+sum[i-1];\n  ans:&#x3D;0;\n  t:&#x3D;0;\n  for i:&#x3D;x+1 to n do\n    if sum[i]&#x3D;sum[i-1] then inc(t)\n      else break;\n  for i:&#x3D;x downto 1 do begin\n    inc(t);\n    ans:&#x3D;max(ans,sum[i]*t);\n  end;\n  t:&#x3D;0;\n  for i:&#x3D;x-1 downto 1 do\n    if sum[i]&#x3D;sum[i+1] then inc(t)\n      else break;\n  for i:&#x3D;x to n do begin\n    inc(t);\n    ans:&#x3D;max(ans,sum[i]*t);\n  end;\nend;\n\nprocedure main;\nvar i,j,anss:longint;\nbegin\n  anss:&#x3D;0;\n  for i:&#x3D;1 to m do \n    anss:&#x3D;max(anss,ans(i));\n  writeln(anss);\nend;\n\nbegin\n  readln(n,m);\n  re;\n  first;\n  main;\nend.\n\n\n T2 $ Present $\n\n 基本思路\n刚看到题面，第一反应：“这不是背包板子吗！”。看到数据范围：“。。。”。\n这三天的 $ T2 $ 都异常巧妙，昨天考了最小生成树，今天的 $ T2 $ 则是一个最短路径。从原题上完全看不出和图论的联系，但是却能根据题目的特点进行转化：\n假设所有的物品中，价值最小为 $ p_{min} $ 。如果一个值 $ W = \\sum_{i=1}^n p_i \\cdot k_i $ 可以被组成，那么 $ W = \\sum_{i=1}^n p_i \\cdot (k_i + p_{min} \\cdot s_i) $ 也一定能被组成。\n可以借此降低背包的上界，将最大容量从 $ 4 \\times 10^7 $ 降为 $ p_{min} \\cdot \\sum_{i=1}^n p_i $ ，时间复杂度为 $ O(n \\cdot p_{min} \\cdot \\sum_{i=1}^n p_i ) $ 。可以通过 $ 60 $% 的数据。\n接下来，解决方法就非常巧妙了。由上可知，对于每一个询问 $ Q = C + p_{min} \\cdot k $ ，只要判断 $ Q \\mod p_{min} $ 能否被组成即可。所以我们只要知道能够被组成的数 $ K(K \\mod p_{min} = C) $ ，的最小值是否小于 $ Q $ 即可。而解决这个问题，可以将 $ [0,p_{min}-1] $ 的每个数当成一个点，对于点 $ f $ ，将其向 $ (f + p_i) \\mod p_{min} $ 的点连一条权值为 $ p_i $ 的无向边，最后算出从 $ 0 $ 到 $ i $ 的最短路便是 $ K(K \\mod p_{min} = i) $ 的最小值。\n 程序\nprogram present;\nvar\n   dis:array[0..10005]of longint;\n   a:array[0..505]of longint;\n   n,m,w:longint;\n\nfunction min(a,b:longint):longint;\nbegin\n  if a&lt;b then exit(a)\n    else exit(b);\nend;\n\nprocedure re;\nvar i:longint;\nbegin\n  w:&#x3D;maxint;\n  for i:&#x3D;1 to n do begin\n    read(a[i]);\n    w:&#x3D;min(w,a[i]);\n  end;\nend;\n\nprocedure spfa;\nvar i,head,tail,f,v:longint;\n    p:array[0..10005]of longint;\n    tf:array[0..10005]of boolean;\nbegin\n  fillchar(dis,sizeof(dis),$3f);\n  fillchar(tf,sizeof(tf),0);\n  dis[0]:&#x3D;0;\n  head:&#x3D;0;\n  tail:&#x3D;1;\n  p[tail]:&#x3D;0;\n  tf[0]:&#x3D;true;\n  while head&lt;tail do begin\n    inc(head);\n    head:&#x3D;head mod 10000;\n    f:&#x3D;p[head];\n    for i:&#x3D;1 to n do begin\n      v:&#x3D;(f+a[i]) mod w;\n      if (a[i]&lt;&gt;w) and (dis[f]+a[i]&lt;dis[v]) then begin\n        dis[v]:&#x3D;dis[f]+a[i];\n        if tf[v]&#x3D;false then begin\n          inc(tail);\n          tail:&#x3D;tail mod 10000;\n          p[tail]:&#x3D;v;\n          tf[v]:&#x3D;true;\n        end;\n      end;\n    end;\n    tf[f]:&#x3D;false;\n  end;\nend;\n\nprocedure main;\nvar i,ans,x:longint;\nbegin\n  spfa;\n  ans:&#x3D;0;\n  for i:&#x3D;1 to m do begin\n    read(x);\n    if dis[x mod w]&lt;&#x3D;x then inc(ans);\n  end;\n  writeln(ans);\nend;\n\nbegin\n  read(n,m);\n  re;\n  main;\nend.\n\n\n T3 $ Mahjong $\n\n\n 基本思路\n这是三天中最水的 $ T3 $ ，没有任何算法，就是按照题意模拟和枚举。主意好细节就可以，注意要先确定雀头，再查找顺子和刻子。对特殊牌型先行处理。\n这题说明了看题是多重要，我没看到“字牌不能成顺子”，结果 $ 100 \\to 63 $ 。\n 程序\nprogram mahjong;\n\ntype arr&#x3D;array[1..15]of longint;\n\ntype tp&#x3D;record\n  a:longint;\n  b:char;\nend;\n\nvar\n   m,s,p,c:arr;\n   ans:array[0..105]of tp;\n   t:longint;\n\n\nprocedure re;\nvar ss:string;\n    i,t:longint;\nbegin\n  readln(ss);\n  i:&#x3D;1;\n  while i&lt;&#x3D;length(ss) do begin\n    val(ss[i],t);\n    case ss[i+1] of\n      &#39;m&#39;:inc(m[t]);\n      &#39;s&#39;:inc(s[t]);\n      &#39;p&#39;:inc(p[t]);\n      &#39;c&#39;:inc(c[t]);\n    end;\n    inc(i,3);\n  end;\nend;\n\nfunction sc(m,s,p,c:arr):boolean;\nvar i,sum:longint;\nbegin\n\n  &#x2F;&#x2F;找刻子和顺子\n  sum:&#x3D;0;\n  for i:&#x3D;1 to 9 do\n    if m[i]&gt;0 then begin\n      if m[i]&lt;3 then while (m[i]&gt;0) and (m[i+1]&gt;0) and (m[i+2]&gt;0) do begin\n        inc(sum);\n        dec(m[i]);\n        dec(m[i+1]);\n        dec(m[i+2]);\n      end;\n      if m[i]&gt;&#x3D;3 then begin\n        inc(sum);\n        dec(m[i],3);\n      end;\n      while (m[i]&gt;0) and (m[i+1]&gt;0) and (m[i+2]&gt;0) do begin\n        inc(sum);\n        dec(m[i]);\n        dec(m[i+1]);\n        dec(m[i+2]);\n      end;\n    end;\n  for i:&#x3D;1 to 9 do\n    if s[i]&gt;0 then begin\n      if s[i]&lt;3 then while (s[i]&gt;0) and (s[i+1]&gt;0) and (s[i+2]&gt;0) do begin\n        inc(sum);\n        dec(s[i]);\n        dec(s[i+1]);\n        dec(s[i+2]);\n      end;\n      if s[i]&gt;&#x3D;3 then begin\n        inc(sum);\n        dec(s[i],3);\n      end;\n      while (s[i]&gt;0) and (s[i+1]&gt;0) and (s[i+2]&gt;0) do begin\n        inc(sum);\n        dec(s[i]);\n        dec(s[i+1]);\n        dec(s[i+2]);\n      end;\n    end;\n  for i:&#x3D;1 to 9 do\n    if p[i]&gt;0 then begin\n      if p[i]&lt;3 then while (p[i]&gt;0) and (p[i+1]&gt;0) and (p[i+2]&gt;0) do begin\n        inc(sum);\n        dec(p[i]);\n        dec(p[i+1]);\n        dec(p[i+2]);\n      end;\n      if p[i]&gt;&#x3D;3 then begin\n        inc(sum);\n        dec(p[i],3);\n      end;\n      while (p[i]&gt;0) and (p[i+1]&gt;0) and (p[i+2]&gt;0) do begin\n        inc(sum);\n        dec(p[i]);\n        dec(p[i+1]);\n        dec(p[i+2]);\n      end;\n    end;\n  for i:&#x3D;1 to 9 do\n    if c[i]&gt;&#x3D;3 then begin\n      inc(sum);\n      dec(c[i],3);\n    end;\n  if sum&lt;4 then exit(false)\n    else exit(true);\n  &#x2F;&#x2F;\n\nend;\n\nfunction check(m,s,p,c:arr):boolean;\nvar i,sum:longint;\n    tf:boolean;\nbegin\n\n  &#x2F;&#x2F;七对子\n  sum:&#x3D;0;\n  for i:&#x3D;1 to 9 do\n    if m[i]&gt;&#x3D;2 then inc(sum);\n  for i:&#x3D;1 to 9 do\n    if s[i]&gt;&#x3D;2 then inc(sum);\n  for i:&#x3D;1 to 9 do\n    if p[i]&gt;&#x3D;2 then inc(sum);\n  for i:&#x3D;1 to 9 do\n    if c[i]&gt;&#x3D;2 then inc(sum);\n  if sum&#x3D;7 then exit(true);\n  if sum&#x3D;0 then exit(false);\n  &#x2F;&#x2F;\n\n  &#x2F;&#x2F;国士无双\n  tf:&#x3D;true;\n  for i:&#x3D;2 to 8 do\n    if m[i]&lt;&gt;0 then tf:&#x3D;false;\n  for i:&#x3D;2 to 8 do\n    if s[i]&lt;&gt;0 then tf:&#x3D;false;\n  for i:&#x3D;2 to 8 do\n    if p[i]&lt;&gt;0 then tf:&#x3D;false;\n  for i:&#x3D;1 to 7 do\n    if c[i]&#x3D;0 then tf:&#x3D;false;\n  if (tf&#x3D;true) and (m[1]&gt;0) and (m[9]&gt;0) and (s[1]&gt;0) and (s[9]&gt;0) and (p[1]&gt;0) and (p[9]&gt;0) then exit(true);\n  &#x2F;&#x2F;\n\n  &#x2F;&#x2F;找对子\n  for i:&#x3D;1 to 9 do\n    if m[i]&gt;&#x3D;2 then begin\n      dec(m[i],2);\n      if sc(m,s,p,c)&#x3D;true then exit(true);\n      inc(m[i],2);\n    end;\n  for i:&#x3D;1 to 9 do\n    if s[i]&gt;&#x3D;2 then begin\n      dec(s[i],2);\n      if sc(m,s,p,c)&#x3D;true then exit(true);\n      inc(s[i],2);\n    end;\n  for i:&#x3D;1 to 9 do\n    if p[i]&gt;&#x3D;2 then begin\n      dec(p[i],2);\n      if sc(m,s,p,c)&#x3D;true then exit(true);\n      inc(p[i],2);\n    end;\n  for i:&#x3D;1 to 7 do\n    if c[i]&gt;&#x3D;2 then begin\n      dec(c[i],2);\n      if sc(m,s,p,c)&#x3D;true then exit(true);\n      inc(c[i],2);\n    end;\n  &#x2F;&#x2F;\n\n  exit(false);\n\nend;\n\nprocedure main;\nvar i,t:longint;\nbegin\n  t:&#x3D;0;\n  for i:&#x3D;1 to 9 do\n    if m[i]+1&lt;5 then begin\n      inc(m[i]);\n      if check(m,s,p,c)&#x3D;true then begin\n        inc(t);\n        ans[t].a:&#x3D;i;\n        ans[t].b:&#x3D;&#39;m&#39;;\n      end;\n      dec(m[i]);\n    end;\n  for i:&#x3D;1 to 9 do\n    if s[i]+1&lt;5 then begin\n      inc(s[i]);\n      if check(m,s,p,c)&#x3D;true then begin\n        inc(t);\n        ans[t].a:&#x3D;i;\n        ans[t].b:&#x3D;&#39;s&#39;;\n      end;\n      dec(s[i]);\n    end;\n  for i:&#x3D;1 to 9 do\n    if p[i]+1&lt;5 then begin\n      inc(p[i]);\n      if check(m,s,p,c)&#x3D;true then begin\n        inc(t);\n        ans[t].a:&#x3D;i;\n        ans[t].b:&#x3D;&#39;p&#39;;\n      end;\n      dec(p[i]);\n    end;\n  for i:&#x3D;1 to 7 do\n    if c[i]+1&lt;5 then begin\n      inc(c[i]);\n      if check(m,s,p,c)&#x3D;true then begin\n        inc(t);\n        ans[t].a:&#x3D;i;\n        ans[t].b:&#x3D;&#39;c&#39;;\n      end;\n      dec(c[i]);\n    end;\n  if t&#x3D;0 then writeln(&#39;Nooten&#39;)\n    else begin\n      write(t,&#39; &#39;);\n      for i:&#x3D;1 to t do\n        write(ans[i].a,ans[i].b,&#39; &#39;);\n      writeln;\n    end;\nend;\n\nbegin\n  readln(t);\n  while t&gt;0 do begin\n    fillchar(m,sizeof(m),0);\n    fillchar(s,sizeof(s),0);\n    fillchar(p,sizeof(p),0);\n    fillchar(c,sizeof(c),0);\n    dec(t);\n    re;\n    main;\n  end;\nend.\n\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训-2019-08-20","url":"/posts/34472.html","content":" 长沙集训 $ Day 2 $ 2019-08-20\n 得分： $ 105/300 $\n\n T1 $ mine $\n\n 基本思路\n此题可以使用 $ Dp $ 解决，设 $ Dp[i,j,k] $ 表示当前处理到第 $ i $ 位，第 $ i $ 位字符为 $ j $ 类型，第 $ i-1 $ 为符号为 $ k $ 类型时的方案数。\n$ s_i=* \\   \\to \\   j,k=1 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ 0 \\ \\to \\ j,k=2 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ 1 \\ \\to \\ j,k=3 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ 2 \\ \\to \\ j,k=4 \n \\ \\ \\ \\ \\ \\ \\ \\ \\ ? \\ \\to \\ j,k=0 $\n状态可从 $ Dp[i-1,k,l] $ 转移得到，其中要注意各种细节问题。\n 程序\nprogram mine;\n\nconst p&#x3D;1000000007;\n\nvar\n   s:array[0..1000005]of longint;\n   f:array[0..1000005,1..4,1..4]of longint;\n   n:longint;\n\nfunction min(a,b:longint):longint;\nbegin\n  if a&lt;b then exit(a)\n    else exit(b);\nend;\n\nprocedure re;\nvar s1:ansistring;\n    i:longint;\nbegin\n  readln(s1);\n  s1:&#x3D;s1;\n  n:&#x3D;length(s1);\n  for i:&#x3D;1 to n do\n    case s1[i] of\n      &#39;*&#39;:s[i]:&#x3D;1;\n      &#39;0&#39;:s[i]:&#x3D;2;\n      &#39;1&#39;:s[i]:&#x3D;3;\n      &#39;2&#39;:s[i]:&#x3D;4;\n      &#39;?&#39;:s[i]:&#x3D;0;\n    end;\nend;\n\nprocedure main;\nvar i,j,k:longint;\n    ans:int64;\nbegin\n  ans:&#x3D;0;\n  if s[1]&#x3D;0 then begin\n    f[1,1,1]:&#x3D;1;\n    f[1,2,2]:&#x3D;1;\n    f[1,3,2]:&#x3D;1;\n  end\n    else if s[1]&#x3D;1 then f[1,1,1]:&#x3D;1\n      else if s[1]&#x3D;2 then f[1,2,2]:&#x3D;1\n        else if s[1]&#x3D;3 then f[1,3,2]:&#x3D;1;\n  for i:&#x3D;2 to n do\n    for j:&#x3D;1 to 4 do\n      for k:&#x3D;1 to 4 do\n        if ((s[i]&#x3D;j) or (s[i]&#x3D;0)) and ((s[i-1]&#x3D;k) or (s[i-1]&#x3D;0)) then begin\n          if (j&#x3D;1) and (k&#x3D;1) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]+f[i-1,k,3]+f[i-1,k,4]) mod p;\n          if (j&#x3D;1) and (k&#x3D;3) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,2]+f[i-1,k,3]+f[i-1,k,4]) mod p;\n          if (j&#x3D;1) and (k&#x3D;4) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]) mod p;\n          if (j&#x3D;2) and (k&#x3D;2) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,2]+f[i-1,k,3]+f[i-1,k,4]) mod p;\n          if (j&#x3D;2) and (k&#x3D;3) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]) mod p;\n          if (j&#x3D;3) and (k&#x3D;1) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]+f[i-1,k,3]+f[i-1,k,4]) mod p;\n          if (j&#x3D;3) and (k&#x3D;2) and (i&lt;&gt;n) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,2]+f[i-1,k,3]+f[i-1,k,4]) mod p;\n          if (j&#x3D;3) and (k&#x3D;3) and (i&lt;&gt;n) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]) mod p;\n          if (j&#x3D;4) and (k&#x3D;1) and (i&lt;&gt;n) then f[i,j,k]:&#x3D;(f[i,j,k]+f[i-1,k,1]+f[i-1,k,3]+f[i-1,k,4]) mod p;\n        end;\n  for i:&#x3D;1 to 4 do\n    for j:&#x3D;1 to 4 do\n      ans:&#x3D;(ans+f[n,i,j]) mod p;\n  writeln(ans);\nend;\n\nbegin\n  re;\n  main;\nend.\n\n T2 $ water $\n\n\n 基本思路\n这题是一道十分奇妙的图论题。首先考虑一个点的积水深度如何计算，假设这个点开始时有无限的水深，这些多出来的水肯定会沿着一某些路径流走，随着水深不断下降，显然当水深到达所有路径中最大点高度的最小值时，余下的水就无法流走了，这时的水深就是答案。\n现在的问题就是如何找出这个最小值。要求出最小值，首先要找到这条路径，所有点的路径是一棵瓶颈生成树。\n 瓶颈生成树：无向图 $ G $ 的一颗瓶颈生成树是这样的一颗生成树，它最大的边权值在G的所有生成树中是最小的。\n无向图 $ G $ 的最小生成树一定是瓶颈生成树（逆命题不成立），因为如果最小生成树不是瓶颈生成树，则最小生成树中一定有一条边可以被更换为更小的权值，不满足最小生成树的性质。\n对于此题，将一个点与其上下左右四个点之间连边，边权为两个顶点高度的较大值。对于四周的点，还要将它们向一个 $ 0 $ 号节点连边，边权为 $ 0 $ 和点的高度中的较大值。之后在建成的图上求出最小生成树，就可以求出水流的所有路径。\n之后以 $ 0 $ 节点为生成树的根，通过 $ DFS $ 处理答案，其中 $ i $ 节点的水深为从 $ i $ 到根的路径上，边权的最大值减去节点 $ i $ 的高度。\n 程序\nprogram water;\n\nconst x:array[1..4]of longint&#x3D;(1,0,-1,0);\n      y:array[1..4]of longint&#x3D;(0,1,0,-1);\n\ntype tp&#x3D;record\n  x,y,w:longint;\nend;\n\ntype tp2&#x3D;record\n  l,v,w:longint;\nend;\n\nvar\n   map,ans:array[0..305,0..305]of longint;\n   fa,r,maxx:array[0..1000005]of longint;\n   e:array[0..200005]of tp2;\n   a:array[0..500005]of tp;\n   n,m,tot,i:longint;\n\nfunction max(a,b:longint):longint;\nbegin\n  if a&gt;b then exit(a)\n    else exit(b);\nend;\n\nprocedure build(x,y,z:longint);\nbegin\n  inc(i);\n  e[i].l:&#x3D;r[x];\n  r[x]:&#x3D;i;\n  e[i].v:&#x3D;y;\n  e[i].w:&#x3D;z;\n  inc(i);\n  e[i].l:&#x3D;r[y];\n  r[y]:&#x3D;i;\n  e[i].v:&#x3D;x;\n  e[i].w:&#x3D;z;\nend;\n\nprocedure qsort(l,r:longint);\nvar i,j,mid:longint;\n    t:tp;\nbegin\n  i:&#x3D;l;\n  j:&#x3D;r;\n  mid:&#x3D;a[(i+j) shr 1].w;\n  repeat\n    while a[i].w&lt;mid do inc(i);\n    while a[j].w&gt;mid do dec(j);\n    if i&lt;&#x3D;j then begin\n      t:&#x3D;a[i];\n      a[i]:&#x3D;a[j];\n      a[j]:&#x3D;t;\n      inc(i);\n      dec(j);\n    end;\n  until i&gt;j;\n  if i&lt;r then qsort(i,r);\n  if l&lt;j then qsort(l,j);\nend;\n\nfunction find(q:longint):longint;\nbegin\n  if fa[q]&#x3D;q then exit(q);\n  fa[q]:&#x3D;find(fa[q]);\n  exit(fa[q]);\nend;\n\nprocedure re;\nvar i,j:longint;\nbegin\n  for i:&#x3D;1 to n do\n    for j:&#x3D;1 to m do\n      read(map[i,j]);\nend;\n\nprocedure dfs(f,fa:longint);\nvar i,x,y:longint;\nbegin\n  x:&#x3D;(f-1) div m;\n  y:&#x3D;f-x*m;\n  ans[x,y]:&#x3D;maxx[f]-map[x,y];\n  i:&#x3D;r[f];\n  while i&lt;&gt;0 do begin\n    if e[i].v&lt;&gt;fa then begin\n      maxx[e[i].v]:&#x3D;max(maxx[f],max(maxx[e[i].v],e[i].w));\n      dfs(e[i].v,f);\n    end;\n    i:&#x3D;e[i].l;\n  end;\nend;\n\nprocedure main;\nvar i,j,k:longint;\nbegin\n  for i:&#x3D;1 to n do\n    for j:&#x3D;1 to m do\n      for k:&#x3D;1 to 4 do begin\n        inc(tot);\n        a[tot].x:&#x3D;(i)*m+j;\n        a[tot].y:&#x3D;(i+x[k])*m+j+y[k];\n        if (i+x[k]&lt;1) or (j+y[k]&lt;1) or (i+x[k]&gt;n) or (j+y[k]&gt;m) then a[tot].y:&#x3D;1;\n        a[tot].w:&#x3D;max(map[i,j],map[i+x[k],j+y[k]]);\n      end;\n  qsort(1,tot);\n  for i:&#x3D;1 to 2*n*m do begin\n    maxx[i]:&#x3D;-maxint;\n    fa[i]:&#x3D;i;\n  end;\n  for i:&#x3D;1 to tot do  begin  \n    if find(a[i].x)&lt;&gt;find(a[i].y) then begin\n      fa[find(a[i].x)]:&#x3D;find(a[i].y);\n      build(a[i].x,a[i].y,a[i].w);\n    end;\n  end;\n  dfs(1,1);\n  for i:&#x3D;1 to n do begin\n    for j:&#x3D;1 to m do\n      write(ans[i,j],&#39; &#39;);\n    writeln;\n  end;\nend;\n\nbegin\n  read(n,m);\n  re;\n  main;\nend.\n\n T3 $ gcd $\n\n\n 基本思路\n咕\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训-2019-08-19","url":"/posts/28776.html","content":" 长沙集训 $ Day 1 $ 2019-08-19\n 得分： $ 70 / 300 $\n\n T1梦境\n\n\n 基本思路\n此题是一个基本的贪心，将区间升序排序后，对于每个转折点，将包括该点的所有区间右端点放入小根堆中，取堆顶元素进行匹配后删除即可。\n 程序\nprogram dream;\n\ntype tp&#x3D;record\n  l,r:longint;\nend;\n\nvar\n   a:array[0..200005]of tp;\n   b,heap:array[0..200005]of longint;\n   n,m,tot:longint;\n\nprocedure qsort1(l,r:longint);\nvar i,j,mid:longint;\n    t:tp;\nbegin\n  i:&#x3D;l;\n  j:&#x3D;r;\n  mid:&#x3D;a[(i+j) shr 1].l;\n  repeat\n    while a[i].l&lt;mid do inc(i);\n    while a[j].l&gt;mid do dec(j);\n    if i&lt;&#x3D;j then begin\n      t:&#x3D;a[i];\n      a[i]:&#x3D;a[j];\n      a[j]:&#x3D;t;\n      inc(i);\n      dec(j);\n    end;\n  until i&gt;j;\n  if l&lt;j then qsort1(l,j);\n  if i&lt;r then qsort1(i,r);\nend;\n\nprocedure qsort2(l,r:longint);\nvar i,j,mid,t:longint;\nbegin\n  i:&#x3D;l;\n  j:&#x3D;r;\n  mid:&#x3D;b[(i+j) shr 1];\n  repeat\n    while b[i]&lt;mid do inc(i);\n    while b[j]&gt;mid do dec(j);\n    if i&lt;&#x3D;j then begin\n      t:&#x3D;b[i];\n      b[i]:&#x3D;b[j];\n      b[j]:&#x3D;t;\n      inc(i);\n      dec(j);\n    end;\n  until i&gt;j;\n  if l&lt;j then qsort2(l,j);\n  if i&lt;r then qsort2(i,r);\nend;\n\nprocedure insert(q:longint);\nvar i,j,t:longint;\nbegin\n  inc(tot);\n  i:&#x3D;tot;\n  heap[tot]:&#x3D;q;\n  while (i shr 1)&lt;&gt;0 do begin\n    j:&#x3D;i shr 1;\n    if heap[j]&gt;heap[i] then begin\n      t:&#x3D;heap[j];\n      heap[j]:&#x3D;heap[i];\n      heap[i]:&#x3D;t;\n    end\n      else exit;\n    i:&#x3D;j;\n  end;\nend;\n\nprocedure del;\nvar i,j,t:longint;\nbegin\n  heap[1]:&#x3D;heap[tot];\n  heap[tot]:&#x3D;2000000000;\n  dec(tot);\n  i:&#x3D;1;\n  while (i shl 1)&lt;&#x3D;tot do begin\n    j:&#x3D;i shl 1;\n    if (j+1&lt;&#x3D;tot) and (heap[j+1]&lt;heap[j]) then inc(j);\n    if heap[i]&gt;heap[j] then begin\n      t:&#x3D;heap[i];\n      heap[i]:&#x3D;heap[j];\n      heap[j]:&#x3D;t;\n    end\n      else exit;\n    i:&#x3D;j;\n  end;\nend;\n\nprocedure re;\nvar i:longint;\nbegin\n  for i:&#x3D;1 to n do\n    read(a[i].l,a[i].r);\n  for i:&#x3D;1 to m do\n    read(b[i]);\n  qsort1(1,n);\n  qsort2(1,m);\nend;\n\nprocedure main;\nvar i,j:longint;\n    ans:int64;\nbegin\n  for i:&#x3D;1 to 200005 do heap[i]:&#x3D;2000000000;\n  tot:&#x3D;0;\n  j:&#x3D;1;\n  ans:&#x3D;0;\n  for i:&#x3D;1 to m do begin\n    while (a[j].l&lt;&#x3D;b[i]) and (j&lt;&#x3D;n) do begin\n      insert(a[j].r);\n      inc(j);\n    end;\n    while heap[1]&lt;b[i] do del;\n    if heap[1]&lt;&gt;2000000000 then begin\n      inc(ans);\n      del;\n    end;\n  end;\n  writeln(ans);\nend;\n\nbegin\n  read(n,m);\n  re;\n  main;\nend.\n\n T2玩具\n\n\n 基本思路\n本题可以转化为，有一棵树，开始时只有一个根节点，之后有 $ n-1 $ 次操作，每次会将一个新的节点等概率的连接到一个已有的节点上，问操作完成后树的期望深度。\n显然的概率 $ Dp $ ，假设已放入 $ i $ 个节点后，形成的森林中深度最大的子树中有 $ j $ 个节点。用 $ Dp[i,j] $ 记录其概率，则该状态只可能由两种情况扩展得到，分别是 $ Dp[i-1,j] $ 和 $ Dp[i-1,j-1] $ ，可得转移方程：\nDp[i,j]=Dp[i−1,j−1]⋅j−1i+Dp[i−1,j]⋅i−jiDp[i,j]=Dp[i-1,j-1] \\cdot \\frac{j-1}{i} + Dp[i-1,j] \\cdot \\frac{i-j}{i}\nDp[i,j]=Dp[i−1,j−1]⋅ij−1​+Dp[i−1,j]⋅ii−j​\nDp[1,1]=1Dp[1,1]=1\nDp[1,1]=1\n用 $ f[i,j] $ 记录树中节点个数为 $ i $ 时，树的深度不超过 $ j $ 的概率， $ g[i,j] $ 记录节点个数为 $ i $ 的森林中，深度最深的子树深度不超过 $ j $ 的概率。可得状态转移方程：\ng[i,j]=∑k=1if[k,j]⋅g[i−k,j]⋅Dp[i,k]g[i,j]=\\sum_{k=1}^{i} f[k,j] \\cdot g[i-k,j] \\cdot Dp[i,k]\ng[i,j]=k=1∑i​f[k,j]⋅g[i−k,j]⋅Dp[i,k]\nf[i,j]=g[i−1,j−1],j&gt;0f[i,j]=g[i-1,j-1] , j&gt;0\nf[i,j]=g[i−1,j−1],j&gt;0\ng[0,i]=1,i∈[0,n]g[0,i]=1 , i \\in [0,n]\ng[0,i]=1,i∈[0,n]\nf[1,0]=1f[1,0]=1\nf[1,0]=1\nf[i,0]=0,i∈[2,n]f[i,0]=0 , i \\in [2,n]\nf[i,0]=0,i∈[2,n]\n则树的深度为 $ i $ 的概率可用 $ f[n,i]-f[n,i-1] $ 得到。\n 程序\nprogram toy;\nvar\n   dp:array[0..205,0..205]of longint;\n   n,p:longint;\n\nprocedure first;\nvar i,j:longint;\n    f:array[0..1005]of int64;\nbegin\n  f[0]:&#x3D;0;\n  f[1]:&#x3D;1;\n  for i:&#x3D;2 to 1000 do\n    f[i]:&#x3D;p-(p div i)*f[p mod i] mod p;\n  dp[1,1]:&#x3D;1;\n  for i:&#x3D;2 to n do\n    for j:&#x3D;1 to i do\n      dp[i,j]:&#x3D;(dp[i-1,j-1]mod p*(j-1)mod p*f[i]mod p+dp[i-1,j]mod p*(i-j)mod p*f[i]mod p) mod p;\nend;\n\nprocedure main;\nvar i,j,k,ans:longint;\n    f,g:array[0..205,0..205]of longint;\nbegin\n  fillchar(f,sizeof(f),0);\n  fillchar(g,sizeof(g),0);\n  for i:&#x3D;0 to n do\n    g[0,i]:&#x3D;1;\n  for i:&#x3D;1 to n do\n    for j:&#x3D;0 to n do begin\n      if j&#x3D;0 then begin\n        if i&#x3D;1 then f[i,j]:&#x3D;1\n          else f[i,j]:&#x3D;0;\n      end\n        else f[i,j]:&#x3D;g[i-1,j-1];\n      for k:&#x3D;1 to i do\n        g[i,j]:&#x3D;(g[i,j]+f[k,j] mod p*g[i-k,j] mod p*dp[i,k] mod p) mod p;\n    end;\n  ans:&#x3D;0;\n  for i:&#x3D;1 to n do\n    ans:&#x3D;(ans+(f[n,i]-f[n,i-1])*i) mod p;\n  if ans&lt;0 then inc(ans,p);\n  writeln(ans);\nend;\n\nbegin\n  read(n,p);\n  first;\n  main;\nend.\n\n T3飘雪圣域\n\n\n 基本思路\n这题看上去像是在树上找连通块，其实和树根本没啥关系。容易想到，在 $ k $ 个节点中，只要两个节点之间连边，则连通块就会减少 $ 1 $ 个，所以我们只要知道区间内节点之间连边的数量，就可以算出连通块个数。\n为了维护边的条数，可以将询问离线，将所有询问区间左端点升序排序，并将所有边按小顶点升序排序。之后用树状数组维护区间内边的条数，首先将所有边的大顶点放入树状数组，之后按照区间进行枚举，对于每一个区间，将小顶点小于区间左端点的边的大顶点从树状数组中删去，之后计算答案（$ l-r+1-边数 $)。\n 程序\nprogram icekingdom;\n\ntype tp&#x3D;record\n  l,r:longint;\nend;\n\ntype tp2&#x3D;record\n  l,r,num:longint;\nend;\n\nvar\n   e:array[0..200005]of tp;\n   f:array[0..200005]of tp2;\n   tree,ans:array[0..200005]of longint;\n   n,q:longint;\n\nprocedure qsort1(l,r:longint);\nvar i,j,mid:longint;\n    t:tp;\nbegin\n  i:&#x3D;l;\n  j:&#x3D;r;\n  mid:&#x3D;e[(i+j) shr 1].l;\n  repeat\n    while e[i].l&lt;mid do inc(i);\n    while e[j].l&gt;mid do dec(j);\n    if i&lt;&#x3D;j then begin\n      t:&#x3D;e[i];\n      e[i]:&#x3D;e[j];\n      e[j]:&#x3D;t;\n      inc(i);\n      dec(j);\n    end;\n  until i&gt;j;\n  if i&lt;r then qsort1(i,r);\n  if l&lt;j then qsort1(l,j);\nend;\n\nprocedure qsort2(l,r:longint);\nvar i,j,mid:longint;\n    t:tp2;\nbegin\n  i:&#x3D;l;\n  j:&#x3D;r;\n  mid:&#x3D;f[(i+j) shr 1].l;\n  repeat\n    while f[i].l&lt;mid do inc(i);\n    while f[j].l&gt;mid do dec(j);\n    if i&lt;&#x3D;j then begin\n      t:&#x3D;f[i];\n      f[i]:&#x3D;f[j];\n      f[j]:&#x3D;t;\n      inc(i);\n      dec(j);\n    end;\n  until i&gt;j;\n  if i&lt;r then qsort2(i,r);\n  if l&lt;j then qsort2(l,j);\nend;\n\nprocedure re;\nvar i,x,y:longint;\nbegin\n  for i:&#x3D;1 to n-1 do begin\n    read(x,y);\n    if x&gt;y then begin\n      e[i].l:&#x3D;y;\n      e[i].r:&#x3D;x;\n    end\n      else begin\n        e[i].l:&#x3D;x;\n        e[i].r:&#x3D;y;\n      end;\n  end;\n  for i:&#x3D;1 to q do begin\n    read(f[i].l,f[i].r);\n    f[i].num:&#x3D;i;\n  end;\n  qsort1(1,n-1);\n  qsort2(1,q);\nend;\n\nfunction low(q:longint):longint;\nbegin\n  exit(q and -q);\nend;\n\nprocedure add(x,q:longint);\nbegin\n  while x&lt;&#x3D;n do begin\n    inc(tree[x],q);\n    inc(x,low(x));\n  end;\nend;\n\nfunction sum(x:longint):longint;\nbegin\n  sum:&#x3D;0;\n  while x&gt;&#x3D;1 do begin\n    inc(sum,tree[x]);\n    dec(x,low(x));\n  end;\nend;\n\nprocedure main;\nvar i,j:longint;\nbegin\n  for i:&#x3D;1 to n-1 do\n    add(e[i].r,1);\n  j:&#x3D;1;\n  for i:&#x3D;1 to q do begin\n    while (j&lt;n) and (e[j].l&lt;f[i].l) do begin\n      add(e[j].r,-1);\n      inc(j);\n    end;\n    ans[f[i].num]:&#x3D;f[i].r-f[i].l+1-sum(f[i].r)-sum(f[i].l);\n  end;\n  for i:&#x3D;1 to q do\n    writeln(ans[i]);\nend;\n\nbegin\n  read(n,q);\n  re;\n  main;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day10","url":"/posts/46456.html","content":" 2019.2.20\n 长沙集训 $ Day 10 $\n昨天已经对网络流最大流有所了解，并且已经能够使用几种基本算法解题。虽然 $ Dinic $ 算法可以解决大部分问题，但如果遇到 $ n,m $ 较大的情况，还是需要更为优秀的算法。\n\n 网络最大流（加强版）：\n相较于普通版的最大流，本题的 $ n $ 有所减小，但 $ m $ 却增加了 $ 20000 $ ，并且出题人显然制作了针对普通 $ Dinic $ 的数据，所以我们需要更为快速的算法。\n $ ISAP $ 算法\n$ ISAP $ 算法是对普通 $ Dinic $ 的进一步优化，该算法先进行一次 $ BFS $ ，找出各节点到 $ T $ 的深度，之后在进行 $ DFS $ 搜索增广路径更新流量，同时更新深度，如果出现断层就结束算法。\n更新节点深度：如果后续节点传回该节点的消耗总流量比当前节点可用流量上限小，即 $ flow_n&lt;dis $ ,则该节点在此高度已无法做出贡献，就将该节点的高度提高 $ 1 $ 。\n断层：如果某一深度（该深度小于 $ n $ ）没有节点，则视为出现断层，此时残量网络中已不存在增广路，结束算法。\n$ ISAP $ 算法的优点是只需运行一边 $ BFS $ ,无需为网络图重新分层，所以能极大加快处理速度。\n $ HLPP $ 算法\n实际上 $ ISAP $ 仍无法通过这道毒瘤题，我们看到了题目中所写的“预流推进”。我们之前所说的算法都是基于增广路进行扩展，而预流推进则类似手动模拟网络流的方式，先将所有的流量尽可能推给后续节点，如果流量超额，再通过反向网络推回。但直接这样进行推进可能会出现两个节点将流量互相-i推给对方，直到 $ TLE $ 为止。所以我们需要给每个节点标号，标号为 $ h_i $ 的节点只能将流量推给标号 $ h_i-1 $ 的节点，当一个节点存在超额流无法推出，就将其标号设为与其相连结点的最小标号+ $ 1 $ ,并将其压入队列，队列为空时结束算法。\n为了加快速度，我们一般先从 $ T $ 开始进行一遍 $ BFS $ ,对节点进行预标号。同时如果处理过程中发现 $ h_i $ 的标号没有节点，那么此时标号比 $ h_i $ 高的节点就全部无法做出贡献，将它们的标号设为 $ n+1 $ 。\n以上是普通预流推进算法，而 $ HLPP $ 中最高标号的意思就是：每次从队列中取出标号最高的节点进行处理，这样做的时间复杂度接近 $ O(n^{2} \\cdot \\sqrt m) $ ，在 $ n $ 较小而 $ m $ 很大时有很高的效率。\n 各种算法的时间复杂度\n虽然 $ HLPP $ 的理论时间复杂度比 $ Dinic $ 低，但因为 $ Dinic $ 处理随机图时的复杂度远低于上限，而 $ HLPP $ 的复杂度基本都在最高复杂度附近，所以在数据较小时 $ HLPP $ 与 $ Dinic $ 的速度并无太大差别。\n\n $ HLPP $ 程序\nprogram project1;\ntype tp=record\n  h,pos:longint;\nend;\n\nconst max_n=1205;\n      max_m=120005;\n      max_int=1061109567;\n\nvar\n   flow:array[0..2*max_n]of int64;\n   r,h,num:array[0..2*max_n]of longint;\n   tf:array[0..max_n]of boolean;\n   l,v,w:array[0..2*max_m]of longint;\n   heap:array[0..2*max_n]of longint;\n   n,m,s,t,tot:longint;\n\nfunction min(a,b:longint):longint;\nbegin\n  if a&lt;b then exit(a) else exit(b);\nend;\n\nfunction search(q:longint):longint;\nbegin\n  if q mod 2=0 then exit(q-1)\n    else exit(q+1);\nend;\n\nprocedure re;\nvar i:longint;\n    t,x,y,z:int64;\nbegin\n  t:=0;\n  for i:=1 to m do begin\n    read(x,y,z);\n    inc(t);\n    l[t]:=r[x];\n    r[x]:=t;\n    v[t]:=y;\n    w[t]:=z;\n    inc(t);\n    l[t]:=r[y];\n    r[y]:=t;\n    v[t]:=x;\n    w[t]:=0;\n  end;\nend;\n\nprocedure insert(pos:longint);\nvar i,j:longint;\n    t:longint;\nbegin\n  inc(tot);\n  heap[tot]:=pos;\n  i:=tot;\n  while (i shr 1)&lt;>0 do begin\n    j:=i shr 1;\n    if h[heap[i]]>h[heap[j]] then begin\n      t:=heap[i];\n      heap[i]:=heap[j];\n      heap[j]:=t;\n    end\n      else break;\n    i:=j;\n  end;\nend;\n\nprocedure del;\nvar i,j:longint;\n    t:longint;\nbegin\n  heap[1]:=heap[tot];\n  dec(tot);\n  i:=1;\n  while (i shl 1)&lt;=tot do begin\n    j:=i shl 1;\n    if (j+1&lt;=tot) and (h[heap[j+1]]>h[heap[j]]) then inc(j);\n    if h[heap[i]]&lt;h[heap[j]] then begin\n      t:=heap[i];\n      heap[i]:=heap[j];\n      heap[j]:=t;\n    end\n      else break;\n    i:=j;\n  end;\nend;\n\nprocedure bfs;\nvar i,f,head,tail:longint;\n    p:array[0..2*max_n]of longint;\nbegin\n  fillchar(h,sizeof(h),$3f); \n  head:=0;\n  tail:=1;\n  p[tail]:=t;\n  h[t]:=0;\n  while head&lt;tail do begin\n    inc(head);\n    f:=p[head];\n    i:=r[f];\n    while i&lt;>0 do begin\n      if (w[search(i)]&lt;>0) and (h[v[i]]>h[f]+1) then begin\n        h[v[i]]:=h[f]+1;\n        inc(tail);\n        p[tail]:=v[i];\n      end;\n      i:=l[i];\n    end;\n  end;  \nend;\n\nprocedure reup(f:longint);\nvar i:longint;\nbegin\n  h[f]:=max_int;  \n  i:=r[f];\n  while i&lt;>0 do begin\n    if (w[i]&lt;>0) and (h[v[i]]+1&lt;h[f]) then h[f]:=h[v[i]]+1;  \n    i:=l[i];\n  end;\nend;\n\nprocedure push(f:longint);\nvar i:longint;\n    tt:longint;\nbegin\n  i:=r[f];   \n  while i&lt;>0 do begin\n    if (w[i]&lt;>0) and (h[f]=h[v[i]]+1) then begin\n      tt:=min(flow[f],w[i]);\n      dec(w[i],tt);\n      inc(w[search(i)],tt);\n      dec(flow[f],tt);\n      inc(flow[v[i]],tt);   \n      if (tf[v[i]]=false) and (v[i]&lt;>s) and (v[i]&lt;>t) then begin\n        tf[v[i]]:=true;\n        insert(v[i]);\n      end;\n    end;\n    i:=l[i];\n    if flow[f]=0 then break;\n  end;\nend;\n\nprocedure hlpp;\nvar i,f,j:longint;\n    tt:longint;\nbegin\n  h[s]:=n;\n  flow[s]:=max_int;\n  fillchar(num,sizeof(num),0);\n  for i:=1 to n do\n    if h[i]&lt;>max_int then inc(num[h[i]]);\n  i:=r[s];\n  while i&lt;>0 do begin\n    if w[i]&lt;>0 then begin\n      tt:=w[i]; \n      dec(w[i],tt);\n      inc(w[search(i)],tt);\n      dec(flow[s],tt);\n      inc(flow[v[i]],tt);\n      if (v[i]&lt;>s) and (v[i]&lt;>t) and (tf[v[i]]=false) then begin\n        tf[v[i]]:=true;  \n        insert(v[i]);\n      end;\n    end;\n    i:=l[i];\n  end;\n  while tot&lt;>0 do begin\n    f:=heap[1];\n    del;\n    tf[f]:=false;\n    push(f);   \n    if flow[f]&lt;>0 then begin\n      dec(num[h[f]]);\n      if num[h[f]]=0 then\n        for j:=1 to n do\n          if (j&lt;>s) and (j&lt;>t) and (h[j]>h[f]) and (h[j]&lt;=n) then h[j]:=n+1;\n      reup(f);\n      inc(num[h[f]]);\n      insert(f);\n      tf[f]:=true;\n    end;\n  end;\n  writeln(flow[t]);\nend;\n\nbegin\n  read(n,m,s,t);\n  re;\n  bfs;\n  hlpp;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day9","url":"/posts/65410.html","content":" 2019.2.19\n 长沙集训 $ Day 9 $\n今天并没有什么新内容，所以我自学了图论中的重要算法——网络最大流\n\n 网络最大流：\n给定一个网络图，求网络中的最大流量。\n 反向网络\n求解网络流最为暴力的算法就是通过一遍遍 $ BFS $ 来寻找是否有一条流量不为零的链连接源点（$ S ）和汇点（）和汇点（）和汇点（ T $），如果有就进行更新并计算答案。这条链就是所谓的增广路。\n但这种方式有可能会走入错误的道路，如下图（网络图是有向图， $ 1 $ 为源点， $ 4 $ 为汇点）。\n\n如果程序选择这条链为增广路，那计算出的最大流只有 $ 1 $ ，但实际最大流显然是 $ 2 $ 。该如何解决这个问题呢？其实很简单，那就是建立反向网络。（建立反向网络实际上是在原图中连反向边，这里为了表述清楚所以分开画图）\n\n初始时反向网络的所有边流量上限都为 $ 0 $ ，当找到一条增广路进行更新时，将原网络中的边减少流量上限，给反向网络中的边增加流量上限。\n\n这样，即使第一遍走了 $ 1 \\to 2 \\to 3 \\to 4 $ 这条路径，第二遍 $ BFS $ 时依然可以找到 $ 1 \\to 3 \\to 2 \\to 4 $ 这条增广路，完美解决了之前的问题。事实上，建立反向网络是网络流算法普遍使用的处理方式。\n为什么这样做是对的呢？思考一下，走过刚刚的两条路径，实际上 $ 2 \\to 3 $ 的路径上，流量上限仍未 $ 1 $ ,而 $ 3 \\to 2 $ 路径的流量上限仍为 $ 0 $ 。相当于走了 $ 1 \\to 2 \\to 4 $ 和 $ 1 \\to 3 \\to 4 $ 这两条链。\n\n $ E-K $ 算法\n$ E-K $ 算法实际上就是上文说到的暴力 $ BFS $ ，每找到一条增广路就进行更新，复杂度极高，且容易被卡。\n $ Dinic $ 算法\n$ Dinic $ 算法应该是使用最多的网络流增广路算法，实际上是对 $ E-K $ 算法的优化，具体做法是增加了分层图的处理。先用一次 $ BFS $ 给网络图分层，之后用 $ DFS $ 搜索增广路，相比之前的 $ BFS $ 暴力，效率已有很大的提高。\n$ Dinic $ 算法的最差时间复杂度为 $ O(n^{2} \\cdot m) $ ，但其实算法大部分情况下的复杂度都远低于上限，且大部分网络流题目的图都比较小， $ n $ 基本上是 $ [10^{2} , 10^{3}] $ 之间，熟练使用 $ Dinic $ 算法便可应对大部分题目。\n $ Dinic $ 算法程序\nprogram project1;\nconst max_n=10005;\n      max_m=100005;\n\nvar\n   r,deep:array[0..max_n]of int64;\n   l,v,w:array[0..4*max_m]of int64;\n   n,m,s,t:longint;\n\nfunction min(a,b:int64):int64;\nbegin\n  if a&lt;b then exit(a) else exit(b);\nend;\n\nfunction search(q:longint):longint;\nbegin\n  if q mod 2=0 then exit(q-1)\n    else exit(q+1);\nend;\n\nprocedure re;\nvar i,t,x,y,z:longint;\nbegin\n  t:=0;\n  for i:=1 to m do begin\n    read(x,y,z);\n    inc(t);\n    l[t]:=r[x];\n    r[x]:=t;\n    v[t]:=y;\n    w[t]:=z;\n    inc(t);\n    l[t]:=r[y];\n    r[y]:=t;\n    v[t]:=x;\n    w[t]:=0;\n  end;\nend;\n\nfunction bfs:boolean;\nvar i,f,head,tail:longint;\n    p:array[0..6*max_m]of longint;\nbegin\n  fillchar(deep,sizeof(deep),0);\n  head:=0;\n  tail:=1;\n  deep[s]:=1;\n  p[tail]:=s;\n  while head&lt;tail do begin\n    inc(head);\n    f:=p[head];\n    i:=r[f];\n    while i&lt;>0 do begin\n      if (w[i]>0) and (deep[v[i]]=0) then begin\n        deep[v[i]]:=deep[f]+1;\n        inc(tail);\n        p[tail]:=v[i];\n      end;\n      i:=l[i];\n    end;\n  end;\n  if deep[t]=0 then exit(false)\n    else exit(true);\nend;\n\nfunction dfs(f,dis:int64):int64;\nvar i:longint;\nbegin\n  dfs:=0;\n  if f=t then exit(dis);\n  i:=r[f];\n  while i&lt;>0 do begin\n    if (w[i]>0) and (deep[v[i]]=deep[f]+1) then dfs:=dfs(v[i],min(dis,w[i]));\n    if dfs>0 then begin\n      dec(w[i],dfs);\n      inc(w[search(i)],dfs);\n      exit(dfs);\n    end;\n    i:=l[i];\n  end;\n  exit(0);\nend;\n\nprocedure main;\nvar ans,df:int64;\nbegin\n  ans:=0;\n  while bfs=true do begin\n    df:=dfs(s,maxint);\n    while df&lt;>0 do begin\n      inc(ans,df);\n      df:=dfs(s,maxint);\n    end;\n  end;\n  writeln(ans);\nend;\n\nbegin\n  read(n,m,s,t);\n  re;\n  main;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day8","url":"/posts/16195.html","content":" 2019.2.18\n 长沙集训 $ Day 8 $\n$ Day 6 $ 讲解了 $ CDQ $ 分治，今天有学到了一种树上分治方法——点分治。\n\n 点分治:\n给出一棵树，询问树上有无距离为 $ k $ 的点对存在。\n对于此类问题，最基础的方法是 $ DFS $ 树上的每一条链，寻找有无链长为 $ k $ ,但是这样的做法时间复杂度为 $ O(n^{2}) $ ,肯定会 $ TLE $ 。这时，我们便可使用点分治来解决问题。\n实际上，如果选一个节点为根，树上的链可以分成两种，即经过树根和在子树中。\n\n而这便是点分治的基础，我们选择一个根，进行一次 $ DFS $ ，处理完所有经过根的路径，之后我们将根删除。原有的树被分为多棵子树，在所有子树中进行同样的操作，直到所有节点都被删除。\n但根节点的选择也是有技巧的，如上图中选择 $ R $ 为根和选择 $ K $ 为根，分治的次数是不同的，如何选取一个节点，使分治次数最少？事实上，这个点就是树的重心。\n 树的重心\n性质：以删去重心后，形成所有子树中，最大的子树最小。\n如上图中，树的重心为 $ R $ 。因为以 $ R $ 为根时，最大子树为 $ 4 $ ，其余各点为根时，没有任何一个点能使最大子树小于 $ 4 $ 。\n我们可以利用性质来寻找树的重心，只需通过一次树形 $ DP $ ，找出每个点的最大子树即可。\nprocedure find(f,fa,sum_root:longint);  //sum_root为整棵树的大小，f为当前节点，fa为f的父节点\nvar i:longint;\nbegin\n  i:=r[f];\n  sum[f]:=0;          //sum[f]记录以f为根的子树的大小，max_next[f]记录删去f后形成的最大子树大小\n  max_next[f]:=0;\n  while i&lt;>0 do begin\n    if (v[i]&lt;>fa) and (tf[v[i]]=false) then begin\n      find(v[i],f,sum_root);\n      inc(sum[f],sum[v[i]]);\n      max_next[f]:=max(max_next[f],sum[v[i]]);\n    end;\n    i:=l[i];\n  end;\n  inc(sum[f]);\n  max_next[f]:=max(max_next[f],sum_root-sum[f]);\n  if (max_next[f]&lt;max_next[find_root]) or (find_root=0) then find_root:=f;    //  find_root记录重心\nend;\n 分治处理\n找到重心后，我们便可以通过DFS查找答案，但此时要注意这种特殊情况。\n\n像这样的两条链是不能将他们的长度加在一起的，但显然这种情况在记录答案时是不好处理的，所以我们可以跑两遍 $ DFS $ ，第一遍记录答案（不论正误），第二遍将错误的答案减掉。\nprocedure dfs(f,fa,len:longint);\nvar i:longint;\nbegin\n  i:=r[f];\n  inc(tot);\n  dis[tot]:=len;\n  while i&lt;>0 do begin\n    if (v[i]&lt;>fa) and (tf[v[i]]=false) then dfs(v[i],f,len+w[i]);\n    i:=l[i];\n  end;\nend;\n\nfunction solve(q,k:longint;len:int64):int64;\nvar i,j:longint;\nbegin\n  tot:=0;  \n  dfs(q,0,len);\n  if k=1 then begin\n    for i:=1 to tot do\n      for j:=i+1 to tot do\n        inc(ans[dis[i]+dis[j]]);\n  end\n    else begin\n      for i:=1 to tot do\n        for j:=i+1 to tot do\n          dec(ans[dis[i]+dis[j]]);\n    end;\nend;\n\nprocedure next(q:longint);\nvar i:longint;\nbegin\n  tf[q]:=true;\n  solve(q,1,0);             //注意这两次solve时参数的不同\n  i:=r[q];  \n  while i&lt;>0 do begin\n    if tf[v[i]]=false then begin\n      solve(v[i],0,w[i]);  \n      find_root:=0;\n      find(v[i],q,sum[v[i]]); \n      next(find_root);\n    end;\n    i:=l[i];\n  end;\nend;\n 复杂度\n根据树的重心的性质，我们可以确定分治次数不超过 $ \\log n $ 次，由此可得出算法的时间复杂度：\n\n分治 $ O(\\log n) $\n查找答案 $ O(n) $\n\n总时间复杂度接近 $ O(n \\log n) $\n其实点分治的难点并不在分治，而是在计算答案的过程，某些题目中不能单纯使用暴力计算答案，还要和其他算法、数据结构相结合（如二分、树状数组），又或者计算答案的过程十分繁琐（如树上游戏），所以还是需要熟练运用多种算法才能顺利解决点分治问题。\n 程序\nprogram project1;\nvar\n   r,sum,max_next,dis:array[0..10005]of longint;\n   tf:array[0..10005]of boolean;\n   ans:array[0..10000005]of longint;\n   l,v,w:array[0..20005]of longint;\n   n,m,find_root,tot:longint;\n\nfunction max(a,b:int64):int64;\nbegin\n  if a>b then exit(a) else exit(b);\nend;\n\nprocedure re;\nvar i,t,x,y,z:longint;\nbegin\n  t:=0;\n  for i:=1 to n-1 do begin\n    read(x,y,z);\n    inc(t);\n    l[t]:=r[x];\n    r[x]:=t;\n    v[t]:=y;\n    w[t]:=z;\n    inc(t);\n    l[t]:=r[y];\n    r[y]:=t;\n    v[t]:=x;\n    w[t]:=z;\n  end;\nend;\n\nprocedure find(f,fa,sum_root:longint);\nvar i:longint;\nbegin\n  i:=r[f];\n  sum[f]:=0;\n  max_next[f]:=0;\n  while i&lt;>0 do begin\n    if (v[i]&lt;>fa) and (tf[v[i]]=false) then begin\n      find(v[i],f,sum_root);\n      inc(sum[f],sum[v[i]]);\n      max_next[f]:=max(max_next[f],sum[v[i]]);\n    end;\n    i:=l[i];\n  end;\n  inc(sum[f]);\n  max_next[f]:=max(max_next[f],sum_root-sum[f]);\n  if (max_next[f]&lt;max_next[find_root]) or (find_root=0) then find_root:=f;\nend;\n\nprocedure dfs(f,fa,len:longint);\nvar i:longint;\nbegin\n  i:=r[f];\n  inc(tot);\n  dis[tot]:=len;\n  while i&lt;>0 do begin\n    if (v[i]&lt;>fa) and (tf[v[i]]=false) then dfs(v[i],f,len+w[i]);\n    i:=l[i];\n  end;\nend;\n\nfunction solve(q,k:longint;len:int64):int64;\nvar i,j:longint;\nbegin\n  tot:=0;   \n  dfs(q,0,len);\n  if k=1 then begin\n    for i:=1 to tot do\n      for j:=i+1 to tot do\n        inc(ans[dis[i]+dis[j]]);\n  end\n    else begin\n      for i:=1 to tot do\n        for j:=i+1 to tot do\n          dec(ans[dis[i]+dis[j]]);\n    end;\nend;\n\nprocedure next(q:longint);\nvar i:longint;\nbegin\n  tf[q]:=true;\n  solve(q,1,0);\n  i:=r[q];  \n  while i&lt;>0 do begin\n    if tf[v[i]]=false then begin\n      solve(v[i],0,w[i]);\n      find_root:=0;\n      find(v[i],q,sum[v[i]]); \n      next(find_root);\n    end;\n    i:=l[i];\n  end;\nend;\n\nprocedure main;\nvar i,x:longint;\nbegin\n  for i:=1 to m do begin\n    read(x);\n    if ans[x]&lt;>0 then writeln('AYE')\n      else writeln('NAY');\n  end;\nend;\n\nbegin\n  read(n,m);\n  re;\n  find_root:=0;\n  find(1,0,n); \n  next(find_root);\n  main;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day7","url":"/posts/15107.html","content":" 2019.2.17\n 长沙集训 $ Day 7 $\n\n T1 X国的军队\n此题和国王游戏类似，看似毒瘤 $ DP $ ，其实是贪心+排序。\n先看简单的情况：\n\n\n\n据点\n火力$ a $\n人数$ b $\n\n\n\n\n$ A $\n$ a_1 $\n$ b_1 $\n\n\n$ B $\n$ a_2 $\n$ b_2 $\n\n\n\n先打 $ A $ 再打 $ B $ ，需要总人数 $ sum_A=b_2-(b_1-a_1)+b_1 $\n先打 $ B $ 再打 $ A $ ，需要总人数 $ sum_B=b_1-(b_2-a_2)+b_2 $\n用两数相减比较大小：\n$ sum_A-sum_B=(b_2-a_2)-(b_1-a_1) $\n\n$ sum_A $ 小，先打 $ A $ 更优，此时 $ (b_2-a_2) &lt; (b_1-a_1) $\n$ sum_B $ 小，先打 $ B $ 更优，此时 $ (b_2-a_2) &gt; (b_1-a_1) $\n\n由此可知，不论何时， $ b-a $ 最大的据点一定是优先攻击的目标，只有这样我们才能以最小的人数攻击所有据点。\n只需将数据以 $ b-a $ 从大到小排序后计算答案即可。\n 程序\nprogram army;\ntype tp=record\n  a,b,c:longint;\nend;\nvar\n   f:array[0..100005]of tp;\n   t,n:int64;\n\nprocedure re;\nvar i:longint;\nbegin\n  for i:=1 to n do begin\n    read(f[i].a,f[i].b);\n    f[i].c:=f[i].b-f[i].a;\n  end;\nend;\n\nprocedure qsort(l,r:longint);\nvar i,j:longint;\n    t,mid:tp;\nbegin\n  i:=l;\n  j:=r;\n  mid.a:=f[(l+r) shr 1].a;\n  mid.c:=f[(l+r) shr 1].c;\n  repeat\n    while (f[i].c>mid.c) or ((f[i].c=mid.c) and (f[i].a&lt;mid.a)) do inc(i);\n    while (f[j].c&lt;mid.c) or ((f[j].c=mid.c) and (f[j].a>mid.a)) do dec(j);\n    if i&lt;=j then begin\n      t:=f[i];\n      f[i]:=f[j];\n      f[j]:=t;\n      inc(i);\n      dec(j);\n    end;\n  until i>j;\n  if i&lt;r then qsort(i,r);\n  if l&lt;j then qsort(l,j);\nend;\n\nprocedure main;\nvar i:longint;\n    ans,num:int64;\nbegin\n  while t>0 do begin\n    read(n);\n    re;\n    qsort(1,n);\n    num:=0;\n    ans:=0;\n    for i:=1 to n do begin\n      if f[i].b-num>0 then begin\n        inc(ans,f[i].b-num);\n        num:=f[i].b;\n      end;\n      num:=num-f[i].a;\n    end;\n    writeln(ans);\n    dec(t);\n  end;\nend;\n\nbegin\n  read(t);\n  main;\nend.\n\n T2 排列组合\n题目要我们对于每个给定 $ n $ 求这个式子的值：\n$ C_{n}^{1} \\cdot C_{n}^{1} + C_{n}^{2} \\cdot C_{n}^{2} + C_{n}^{3} \\cdot C_{n}^{3} + \\ … \\  + C_{n}^{n} \\cdot C_{n}^{n} $\n组合数公式：\n$ C_{n}^{m}=\\frac{n!}{m! \\cdot (n-m)!}$\n最简单的做法就是利用公式，对于每一个 $ n $ 求值，这样一次求值的时间复杂度是 $ O(n) $ ,有 $ T $ 次询问，总时间复杂度是 $ O(n \\cdot T) $ ，保证 $ TLE $\n所以我们要 $ O(n) $ 求出所有式子的值，然后 $ O(1) $ 处理询问。\n这里要用到组合数平方和公式：\n$ C_{n}^{1} \\cdot C_{n}^{1} + C_{n}^{2} \\cdot C_{n}^{2} + C_{n}^{3} \\cdot C_{n}^{3} + \\ … \\  + C_{n}^{n} \\cdot C_{n}{n}=C_{2n}{n} $\n对于此题，我们只要求出 $ C_{2n}^{n} \\ \\ \\ , n \\in [1,1000000] $  的值即可。\n 程序\nprogram pc;\nconst p=1000000007;\n\nvar\n   f,ans:array[0..1000005]of int64;\n   t,i:longint;\n\nprocedure up;\nvar i:longint;\n    l,r,ans_c:int64;\nbegin\n  l:=2;\n  r:=2;\n  ans_c:=2;\n  ans[1]:=2;\n  for i:=2 to 1000005 do begin\n    inc(r);  \n    ans_c:=(((ans_c*r) mod p)*f[i]) mod p;\n    inc(r);\n    ans_c:=(((ans_c*r) mod p)*f[l]) mod p;\n    inc(l);\n    ans[i]:=ans_c;\n  end;\nend;\n\nprocedure main;\nvar i,x:longint;\nbegin\n  for i:=1 to t do begin\n    read(x);\n    writeln(ans[x]);\n  end;\nend;\n\nbegin\n  read(t);\n  f[0]:=0;\n  f[1]:=1;\n  for i:=2 to 1000005 do\n    f[i]:=p-(p div i)*f[p mod i]mod p;\n  up;\n  main;\nend.\n\n T3 回文\n看到求回文串，本来以为是要对 $ manacher $ 进行优化，最后发现正解和 $ manacher $ 一点关系都没有，而是毒瘤 $ DP $ ！\n设 $ tf[i,j] $ 记录区间 $ [i,j] $ 是否为回文串：\n$ tf[i,j]=tf[i+1,j-1] \\ \\ and \\ \\ (s[i]=s[j]) $\n$ tf[i,j]=0 $ 表示区间未处理\n$ tf[i,j]=1 $ 表示区间是回文串\n$ tf[i,j]=2 $ 表示区间不是回文串\n设 $ dp[i,j] $ 表示区间 $ [i,j] $ 的回文串个数：\n当 $ tf[i,j]=2 $ 时：$ dp[i,j]=dp[i+1,j]+dp[i,j-1]-dp[i+1,j-1] $\n当 $ tf[i,j]=1 $ 时：$ dp[i,j]=dp[i+1,j]+dp[i,j-1]-dp[i+1,j-1]+1 $\n 程序\nprogram pal;\nvar\n   tf:array[0..5005,0..5005]of integer;\n   dp:array[0..5005,0..5005]of int64;\n   s:array[0..5005]of char;\n   len:longint;\n\nprocedure re;\nvar p:ansistring;\n    i:longint;\nbegin\n  readln(p);\n  len:=length(p);\n  for i:=1 to len do s[i]:=p[i];\nend;\n\nprocedure dp_up;\nvar i:longint;\nbegin\n  for i:=1 to len do begin\n    tf[i,i]:=1;   \n    dp[i,i]:=1;\n    dp[i,i+1]:=2;\n    if s[i]=s[i+1] then begin\n      tf[i,i+1]:=1;\n      inc(dp[i,i+1]);\n    end;\n  end;\nend;\n\nfunction dfs(l,r:longint):boolean;\nbegin\n  if l>r then exit(false);\n  dfs:=false;  \n  if tf[l,r]=2 then exit(false);\n  if tf[l,r]=1 then exit(true)\n    else begin\n      if (dfs(l+1,r-1)=true) and (s[l]=s[r]) then tf[l,r]:=1\n        else tf[l,r]:=2;\n      if tf[l,r]=1 then exit(true)\n        else exit(false);\n    end;\nend;\n\nprocedure dp_;\nvar i,j,l:longint;\nbegin        \n  for i:=1 to len do begin\n    l:=0;\n    for j:=i to len do begin\n      inc(l);\n      dp[l,j]:=dp[l+1,j]+dp[l,j-1]-dp[l+1,j-1];\n      if dfs(l,j)=true then inc(dp[l,j]);  \n    end;\n  end;\nend;\n\nprocedure main;\nvar i,t,x,y:longint;\nbegin\n  read(t);\n  for i:=1 to t do begin\n    read(x,y);\n    writeln(dp[x,y]);\n  end;\nend;\n\nbegin\n  re;  \n  dp_up;\n  dp_;\n  main;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day6","url":"/posts/64450.html","content":" 2019.2.16\n 长沙集训 $ Day 6 $\n今天没有模拟赛，而是介绍了一种神奇的算法，现在让我们一起了解一下 $ CDQ $ 分治的魅力。\n\n 三维偏序问题：\n共有 $ n $ 个元素，对于第 $ i $ 个元素，给出三个量：$ a_i \\ \\ , \\ \\ b_i \\ \\ ,\\ \\ c_i $ ,询问$       a_j&lt;a_i , b_j&lt;b_i , c_j&lt;c_i $ 的元素有多少个。\n如果 $ n $ 很小，我们可以用三维前缀和解决这个问题，但当 $ n=10000 $ 或者更大时，显然需要二维树形结构来维护，但树形结构消耗空间大，编程难度高，且处理时常数复杂度高。这时，我们便可以用 $ CDQ $ 分治来解决问题。\n先从二位偏序看起:\n要解决二维偏序，我们可以先使用快排将第一维处理为有序排列。之后再利用树状数组或分治在第二维上统计答案。（例如逆序对）\n现在问题变成了三维，我们依然可以沿用解决二维偏序问题的思路。依然用快排处理第一维（例如将其从小到大排列），但这时不能直接将第二维再次排序，否则会打乱第一维的顺序。为解决这个问题，我们可以用分治将数列分成左右两份。注意到左边的 $ a_i $ 一定小于右边的 $ a_j $ ,此时我们将左右两边的 $ b $ 分别排成有序数列，虽然 $ a $ 的顺序会被打乱，但左边 $ a $ 一定是比右边 $ a $ 小。此时，我们便可以统计左边元素对右边元素的贡献。通过层层分治，可以求出所有贡献。\n\n 如何排序\n对第二维元素可以用快排排序，这样的时间复杂度：\n\n快排 $ O(n \\log n) $\n分治 $ O(\\log n) $\n处理答案 $ O(n) $\n\n总时间复杂度接近 $ O(n \\log^{2} n) $\n这个速度已经可以解决大部分问题，但其实还有更快的处理方式。因为分治的过程类似归并排序，所以我们可以在处理答案时对b进行归并排序，这样的时间复杂度：\n\n分治 $O(\\log n) $\n处理答案+排序 $ O(n) $\n\n总时间复杂度接近 $ O(n \\log n) $\n 处理答案\n对答案的处理一般是使用树状数组进行统计，但其实我们可以再次利用 $ CDQ $ 分治的方法，继续对第三维进行分治，即在 $ b $ 排序后，再将区间分为两份，对 $ c $ 进行排序并统计答案。这种 $ CDQ $ 嵌套还可以继续进行，以解决四维、五维偏序问题。\n 程序（ $ CDQ $ 套 $ CDQ $ ）\nprogram project1;\ntype tp=record\n  a,b,c,tot,tf,ans:longint;\n  tfp:boolean;\nend;\n\nvar\n   f,a,b:array[0..100005]of tp;\n   ans:array[0..100005]of longint;\n   n,k:longint;\n\nfunction max(a,b:longint):longint;\nbegin\n  if a>b then exit(a) else exit(b);\nend;\n\nprocedure re;\nvar i:longint;\nbegin\n  for i:=1 to n do\n    read(f[i].a,f[i].b,f[i].c);\nend;\n\nprocedure qsort(l,r:longint);\nvar i,j:longint;\n    t,mid:tp;\nbegin\n  i:=l;\n  j:=r;\n  mid:=f[(i+j) div 2];\n  repeat\n    while (f[i].a&lt;mid.a) or ((f[i].a=mid.a) and (f[i].b&lt;mid.b)) or ((f[i].a=mid.a) and (f[i].b=mid.b) and (f[i].c&lt;mid.c)) do inc(i);\n    while (f[j].a>mid.a) or ((f[j].a=mid.a) and (f[j].b>mid.b)) or ((f[j].a=mid.a) and (f[j].b=mid.b) and (f[j].c>mid.c)) do dec(j);\n    if i&lt;=j then begin\n      t:=f[i];\n      f[i]:=f[j];\n      f[j]:=t;\n      inc(i);\n      dec(j);\n    end;\n  until i>j;\n  if i&lt;r then qsort(i,r);\n  if l&lt;j then qsort(l,j);\nend;\n\nprocedure cdq_c(l,r:longint);\nvar i,j,mid,t,sum,ii:longint;\nbegin\n  if l=r then begin\n    if f[l].tfp=false then begin\n      inc(ans[f[l].ans],f[l].tot-1);\n      f[l].tfp:=true;\n    end;  \n    exit;\n  end;\n  mid:=(l+r) shr 1;\n  cdq_c(l,mid);\n  cdq_c(mid+1,r);\n  i:=l;\n  j:=mid+1;\n  t:=l-1;\n  sum:=0;\n  while t&lt;=r-1 do begin\n    inc(t);          \n    if ((a[i].c&lt;=a[j].c) or (j>r)) and (i&lt;=mid) then begin\n      b[t]:=a[i];\n      inc(sum,b[t].tf*b[t].tot);\n      inc(i);\n    end\n      else begin\n        b[t]:=a[j];        \n        inc(j);\n      end;\n  end;\n  for i:=l to r do a[i]:=b[i];\nend;\n\nprocedure cdq_b(l,r:longint);\nvar i,mid,j,t:longint;\nbegin\n  if l=r then begin\n    cdq_c(l,r);\n    exit;\n  end;\n  mid:=(l+r) shr 1;\n  cdq_b(l,mid);\n  cdq_b(mid+1,r);\n  i:=l;\n  j:=mid+1;\n  t:=l-1;   \n  while t&lt;=r-1 do begin\n    inc(t);\n    if ((f[i].b&lt;=f[j].b) or (j>r)) and (i&lt;=mid) then begin\n      a[t]:=f[i];\n      a[t].tf:=1;\n      inc(i);\n    end\n      else begin\n        a[t]:=f[j];\n        a[t].tf:=0;\n        inc(j);\n      end;\n  end;\n  for i:=l to r do f[i]:=a[i];\n  cdq_c(l,r);\nend;\n\nprocedure main;\nvar i,j:longint;\n    sum:array[0..100005]of longint;\nbegin\n  j:=1;\n  f[1].tot:=1;\n  for i:=2 to n do\n    if ((f[i].a=f[j].a) and (f[i].b=f[j].b) and (f[i].c=f[j].c)) then inc(f[j].tot)\n      else begin\n        inc(j);\n        f[j]:=f[i];\n        f[j].tot:=1;\n      end;\n  for i:=1 to j do f[i].ans:=i;\n  fillchar(sum,sizeof(sum),0);\n  fillchar(ans,sizeof(ans),0);\n  cdq_b(1,j);\n  for i:=1 to j do inc(sum[ans[f[i].ans]],f[i].tot);\n  for i:=0 to n-1 do writeln(sum[i]);\nend;\n\nbegin\n  read(n,k);\n  re;\n  qsort(1,n);\n  main;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day5","url":"/posts/64130.html","content":" 2019.2.15\n 长沙集训 $ Day 5 $\n今天的题目还是比较简单的，但是我的程序却出现了许多严重的 $ bug $ ,最终让我获得了 $ 20 $ 分的“好成绩”…\n\n T1 modeq\n这题可以说是扩展欧几里得算法的板子题了，分别套用一次 $ exgcd $ 求出最小 $ x,y $ ，然而我调试时把绝对值删了，后来又忘了改回去，最后 $ 100 \\to 0 $\n求解方法：\n对于方程 $ a \\cdot x + b \\cdot y = c $\n\n只有在 $ c \\ \\ mod \\ \\ gcd(a,b) = 0 $ 时，方程才有解\n若 $ exgcd $ 解出的 $ x $ 为负值，可用 $ x=(x+abs(b*n)) \\ \\ mod \\ \\ b $ 的方式将其变为正值\n$ \\frac{(a \\cdot x)}{m} +\\frac{(b \\cdot y)}{m} =\\frac{c}{m} $ 此方程的解与原方程相同，所以可以先将方程化简在进行处理\n\n 程序\nprogram modeq;\nvar t,x,y,gd:int64;\n\nfunction gcd(a,b:int64):int64;\nbegin\n  if b=0 then exit(a);\n  gcd:=gcd(b,a mod b);\nend;\n\nprocedure exgcd(a,b,c:int64);\nvar t:int64;\nbegin\n  if b=0 then begin\n    x:=c div a;\n    y:=0;\n    exit;\n  end;\n  exgcd(b,a mod b,c);\n  t:=x;\n  x:=y;\n  y:=t-(a div b)*y;\nend;\n\nprocedure main;\nvar i:longint;\n    a,b,c,ans_x,ans_y:int64;\nbegin\n  for i:=1 to t do begin\n    read(a,b,c);\n    gd:=gcd(a,b);\n    if c mod gd&lt;>0 then begin\n      writeln('No');\n      continue;\n    end;\n    a:=a div gd;\n    b:=b div gd;\n    c:=c div gd;  \n    if c mod b=0 then write('0',' ',c div b,' ')\n      else begin\n        exgcd(a,b,c);  \n        ans_x:=(x+abs(b*1000000000)) mod b;\n        ans_y:=(c-a*ans_x) div b;\n        write(ans_x,' ',ans_y,' ');\n      end;\n    if c mod a=0 then writeln(c div a,' ','0')\n      else begin\n        exgcd(b,a,c);  \n        ans_y:=(x+abs(a*1000000000)) mod a;\n        ans_x:=(c-b*ans_y) div a;\n        writeln(ans_x,' ',ans_y);\n    end;\n  end;\nend;\n\nbegin\n  read(t);\n  main;\nend.\n\n T2 买卖\n开始以为是个毒瘤 $ DP $ ，后来发现是贪心，只要找到能把当前可以买入的最便宜的物品卖出赚钱的商店就把物品卖出，如果之后又更优秀的方案，就进行更改：\n\n\n\n编号\n买入\n卖出\n\n\n\n\nA\n$ 7 $\n$ 1 $\n\n\nB\n$ 10 $\n$ 8 $\n\n\nC\n$ 12 $\n$ 12 $\n\n\n\n\n在 $ A $ 处买入物品，在 $ B $ 出卖出价值 $ w=8-7=1 $ ，并将 $ A $ 处物品价格改为 $ 8 $\n发现在 $ C $ 出卖出是更优方案，相当于重新将物品买入，并在 $ C $ 处卖出，价值 $ w=12-8+1=12-7=5 $\n可买入物品的最小值可用小根堆/最小值线段树等数据结构维护\n\n 一定注意初始化\n 程序\nprogram buy;\nvar\n   tree:array[0..400005]of int64;\n   a:array[0..100005,1..2]of int64;\n   n,tar,sum:longint;\n\nfunction min(a,b:int64):int64;\nbegin\n  if a&lt;b then exit(a) else exit(b);\nend;\n\nprocedure re;\nvar i:longint;\nbegin\n  for i:=1 to n do read(a[i,1]);\n  for i:=1 to n do read(a[i,2]);\nend;\n\nfunction search(l,r,t,k:longint):boolean;\nvar mid:longint;\nbegin\n  search:=false;\n  if l=r then begin   \n    tree[t]:=k;\n    exit(true);\n  end;\n  mid:=(l+r) shr 1;\n  if tree[t shl 1 + 1]=tar then search:=search(mid+1,r,t shl 1 + 1,k);\n  if search=false then search:=search(l,mid,t shl 1,k);\n  tree[t]:=min(tree[t shl 1],tree[t shl 1 + 1]);\n  exit(search);\nend;\n\nprocedure change(l,r,t,x,k:longint);\nvar mid:longint;\nbegin\n  if (l=r) and (l=x) then begin\n    tree[t]:=k;\n    exit;\n  end;\n  mid:=(l+r) shr 1;\n  if x&lt;=mid then change(l,mid,t shl 1,x,k);\n  if x>=mid+1 then change(mid+1,r,t shl 1 + 1,x,k);\n  tree[t]:=min(tree[t shl 1],tree[t shl 1 + 1]);\nend;\n\nprocedure main;\nvar x,ans:int64;\n    i:longint;\nbegin\n  ans:=0;\n  for i:=1 to n do begin\n    change(1,n,1,i,a[i,1]);\n    if tree[1]&lt;a[i,2] then begin\n      tar:=tree[1];   \n      inc(ans,a[i,2]-tree[1]);\n      search(1,n,1,a[i,2]);\n    end;\n  end;\n  writeln(ans);\nend;\n\nbegin\n  fillchar(tree,sizeof(tree),$5f);\n  read(n);\n  re;\n  main;\nend.\n\n T3 投资\n这题看起来是个 $ DP $ ，其实是前缀和+小根堆。\n两题都是小根堆，可以复制代码了！！！\n设$ [l,r] $ 是连续天数的范围\n$ ans=max(sum[i]-min(sum[j])) \\ \\ \\ \\ j \\in [i-r,i-l]$\n 程序\nprogram invest;\nvar\n   a:array[0..100005]of int64;\n   heap:array[0..100005,1..2]of int64;\n   n,l,r,tot:longint;\n\nfunction max(a,b:int64):int64;\nbegin\n  if a>b then exit(a) else exit(b);\nend;\n\nfunction min(a,b:int64):int64;\nbegin\n  if a&lt;b then exit(a) else exit(b);\nend;\n\nprocedure re;\nvar i:longint;\nbegin\n  for i:=1 to n do read(a[i]);\nend;\n\nprocedure insert(q,p:int64);\nvar i,j,t:int64;\nbegin\n  inc(tot);   \n  heap[tot,1]:=q;\n  heap[tot,2]:=p;\n  i:=tot;\n  while i shr 1&lt;>0 do begin\n    j:=i shr 1;\n    if heap[j,1]>heap[i,1] then begin\n      t:=heap[j,1];\n      heap[j,1]:=heap[i,1];\n      heap[i,1]:=t;\n      t:=heap[j,2];\n      heap[j,2]:=heap[i,2];\n      heap[i,2]:=t;\n    end\n      else break;\n    i:=j;\n  end;\nend;\n\nprocedure del;\nvar i,j,t:longint;\nbegin\n  heap[1]:=heap[tot];\n  dec(tot);\n  i:=1;\n  while i shl 1&lt;=tot do begin\n    j:=i shl 1;\n    if (j+1&lt;=tot) and (heap[j,1]>heap[j+1,1]) then inc(j);\n    if heap[j,1]&lt;heap[i,1] then begin\n      t:=heap[j,1];\n      heap[j,1]:=heap[i,1];\n      heap[i,1]:=t;\n      t:=heap[j,2];\n      heap[j,2]:=heap[i,2];\n      heap[i,2]:=t;\n    end\n      else break;\n    i:=j;\n  end;\nend;\n\nprocedure main;\nvar sum:array[0..100005]of int64;\n    ans:int64;\n    i:longint;\nbegin\n  fillchar(sum,sizeof(sum),0);\n  ans:=-10000000000;\n  sum[1]:=a[1];\n  if l&lt;=1 then ans:=sum[1];\n  for i:=2 to n do begin\n    sum[i]:=sum[i-1]+a[i];   \n    if i-l>0 then insert(sum[i-l],i-l);   \n    while i-heap[1,2]>r do del;\n    if i>=l then ans:=max(ans,sum[i]-heap[1,1]);\n  end;\n  writeln(ans);  \nend;\n\nbegin\n  fillchar(heap,sizeof(heap),$5f);\n  read(n,l,r);\n  re;\n  main;\nend.\n\n T4 游戏\n先用 $ manacher $ 求出以每个位置为中心的最长回文串的半径，之后进行统计，半径为 $ t $ 的回文串个数 $ sum[t] $ 为半径大于等于 $ t $ 的回文串个数之和。统计个数后用快速幂计算答案，注意取模。\n 程序\nprogram rehearse;\n\nconst p=19930726;\n\nvar\n   f:array[0..2000005]of longint;\n   sum:array[0..2000005]of int64;\n   s:array[0..2000005]of char;\n   len,n,k:int64;\n\nfunction min(a,b:longint):longint;\nbegin\n  if a&lt;b then exit(a) else exit(b);\nend;\n\nprocedure re;\nvar i:longint;\n    p:ansistring;\nbegin\n  readln(p);\n  len:=1;\n  s[0]:='#';\n  s[len]:='#';\n  for i:=1 to n do begin\n    inc(len);\n    s[len]:=p[i];\n    inc(len);\n    s[len]:='#';\n  end;\nend;\n\nprocedure manacher;\nvar i,mid,mx:longint;\nbegin\n  mid:=1;\n  mx:=1;\n  for i:=1 to len do begin\n    if i&lt;mx then f[i]:=min(mx-i,f[mid*2-i])\n      else f[i]:=1;\n    while s[i-f[i]]=s[i+f[i]] do inc(f[i]);\n    if f[i]+i>mx then begin\n      mx:=f[i]+i;\n      mid:=i;\n    end;\n  end;\n  for i:=1 to len do\n    if s[i]&lt;>'#' then inc(sum[f[i]]);\nend;\n\nfunction mul(q,k:int64):int64;\nvar t:int64;\nbegin\n  t:=q;\n  mul:=1;\n  while k&lt;>0 do begin\n    if k and 1&lt;>0 then mul:=(mul mod p)*(t mod p) mod p;\n    t:=(t mod p)*(t mod p) mod p;\n    k:=k shr 1;\n  end;\nend;\n\nprocedure main;\nvar i:longint;\n    ans,t:int64;\nbegin\n  ans:=1;\n  t:=0;\n  sum[(len div 2) + 3]:=0;\n  for i:=(len div 2) + 2 downto 1 do begin\n    sum[i]:=sum[i]+sum[i+1];      \n    if (i-1) mod 2=1 then begin\n      inc(t,sum[i]);\n      if t&lt;=k then ans:=(ans mod p)*(mul(i-1,sum[i]) mod p) mod p\n        else begin\n          ans:=(ans mod p)*(mul(i-1,k-t+sum[i]) mod p) mod p;\n          break;\n        end;\n    end;\n  end;\n  if t&lt;k then writeln('-1')\n    else writeln(ans);\nend;\n\nbegin\n  readln(n,k);\n  re;\n  manacher;\n  main;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day4","url":"/posts/14915.html","content":" 2019.2.14\n 长沙集训 $ Day 4 $\n今天的题目异常困难，至少这是我最接近爆零的一次\n\n T1 高斯消元\n虽然题目名字是高斯消元，实际上和高斯消元法没半点关系！\n这题的核心解法是栈，在读入时将数字压入栈中，如果栈顶有连续k个相同数字就将他们全部弹出。之后再从数列的首尾模拟将数字删去。\n 程序\nvar\n  f:array[0..100005,1..2]of int64;\n  n,m,k:int64;\n\nprocedure re;\nvar i:longint;\n    x,t:int64;\nbegin\n  t:=0;\n  f[t,1]:=-1;\n  for i:=1 to n do begin\n    read(x);\n    if x=f[t,1] then inc(f[t,2])\n      else begin\n        inc(t);\n        f[t,1]:=x;\n        f[t,2]:=1;\n      end;\n    if f[t,2]=k then begin\n      f[t,2]:=0;\n      dec(t);\n    end;\n  end;\n  n:=t;\nend;\n\nprocedure main;\nvar i,l,r:longint;\n    sum,del:int64;\nbegin\n  r:=n;\n  sum:=0;\n  del:=0;\n  for i:=1 to n do inc(sum,f[i,2]);\n  for i:=1 to n do begin\n    if (i>=r) or (f[i,1]&lt;>f[r,1]) then begin\n      l:=i;\n      break;\n    end;\n    if f[i,2]+f[r,2]=k then begin\n      if l+1=r then begin\n        f[i,2]:=0;\n        f[r,2]:=0;\n        l:=i;\n        break;\n      end else dec(r);\n    end\n      else if f[i,2]+f[r,2]>k then begin\n        dec(f[r,2],k-f[i,2]);\n        f[i,2]:=0;\n      end else begin\n        l:=i;\n        break;\n      end;\n  end;\n  if (l=r) and (l=1) then begin\n    writeln(f[l,2]*m mod k);\n    exit;\n  end;\n  if l=r then begin\n    writeln(sum-1+f[l,2]*m mod k);\n    exit;\n  end;\n  for i:=l to r do inc(del,f[i,2]);\n  writeln(sum*m-(sum-del)*(m-1));\nend;\n\nbegin\n  read(n,m,k);\n  re;\n  main;\nend.","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day3","url":"/posts/63490.html","content":" 2019.2.13\n 长沙集训 $ Day 3 $\n今天的题突然变得简单了，感觉比 $ Day 1 $ 还简单，但一看标题…\n$ NOIP $ 模拟赛！！！\n\n T1 A\n没错，今天的题目名称就是这么敷衍，甚至于题目描述也十分模糊…\n第一题是一道模拟水题，只要按照横坐标从左到右枚举一遍，取最大答案即可。\n 评测结果我只有 $ 40 $ 分，但是用数据自测答案却是正确的，在本地用 $ lemon $ 测就 $ AC $ 了！？此问题有待解决…\n 程序\nprogram a;\nvar\n   m,b,n:int64;\n   ans:int64;\n\nprocedure main;\nvar i:longint;\n    t,sum,max:int64;\nbegin\n  if (m&lt;0) and (b>0) then begin\n    writeln((1+b)*b div 2);\n    exit;\n  end;\n  if (m&lt;0) and (b&lt;0) then begin\n    writeln((1+n)*n div 2);\n    exit;\n  end;\n  if (m>0) and (b&lt;0) then begin\n    writeln('0');\n    exit;\n  end;                           //特判，防止m&lt;0或b&lt;0 \n  t:=b+1;\n  ans:=(1+b)*b div 2;\n  sum:=ans;\n  max:=ans;\n  for i:=1 to n do begin  \n    while t-1>-(i/m)+b do begin\n      dec(t);   \n      dec(sum,t+i-1);   \n      dec(max,i*t+(i*(i-1) div 2));\n    end;\n    inc(sum,t);\n    inc(max,sum);\n    if max>ans then ans:=max; \n  end;\n  writeln(ans);\nend;\n\nbegin\n  ans:=0;\n  read(m,b);\n  n:=abs(m*b);\n  main;\nend.\n T2 B\n此题虽是 $ T2 $ ，但难度却远超 $ T3 $ ，思路并不复杂，但代码就…\n一看到将区间覆盖成 $ 1 $ 或 $ 0 $ ，立刻就想到线段树，但如何维护？好在我做染色和软件包管理器时的处理方式给了我启发！\n对于 $ tree[t] $ :\n$ tree[t].l $ 维护 $ t $ 区间最左边连续 $ 0 $ 的个数\n$ tree[t].r $ 维护 $ t $ 区间最有边连续 $ 0 $ 的个数\n$ tree[t].p $ 维护 $ t $ 区间最多连续 $ 0 $ 的个数\n有了储存方式，接下来就是修改了：\n\n像如上这些区间的修改是一大难点\n修改 $ tree[t].p $ :\n$ tree[t].p = max(tree[t \\ \\ shl \\ \\ 1].r+tree[t \\ \\ shl \\ \\ 1 + 1].l,tree[t \\ \\ shl \\ \\ 1].p,tree[t \\ \\ shl \\ \\ 1 + 1].p) $\n修改 $ tree[t].l $ 和 $ tree[t].r $ :\n$ tree[t].l=tree[t \\ \\ shl \\ \\ 1].p+tree[t \\ \\ shl \\ \\ 1 + 1].l \\ \\ \\ \\ \\ \\ \\ \\ tree[t \\ \\ shl \\ \\ 1] $ 的区间全是 $ 0 $\n$ tree[t].l=tree[t \\ \\ shl \\ \\ 1].l $\n$ tree[t].r=tree[t \\ \\ shl \\ \\ 1].r+tree[t \\ \\ shl \\ \\ 1 + 1].p \\ \\ \\ \\ \\ \\ \\ \\  tree[t \\ \\ shl \\ \\ 1 + 1] $ 的区间全是 $ 0 $\n$ tree[t].r=tree[t \\ \\ shl \\ \\ 1 + 1].r $\n查找答案：\n\n$ tree[t].l&gt;=len $ 处理答案\n$ tree[t \\ \\ shl \\ \\ 1].p&gt;=len $ 扩展到$ t \\ \\ shl \\ \\ 1 $ 节点\n$ tree[t \\ \\ shl \\ \\ 1].r+tree[t \\ \\ shl \\ \\ 1 + 1].l&gt;=len $ 处理答案\n$ tree[t \\ \\ shl \\ \\ 1 + 1].p&gt;=len $ 扩展到 $ t \\ \\ shl \\ \\ 1 + 1 $ 节点\n$ tree[t].r&gt;=len $ 处理答案\n\n按照从 $ 1 $ 到 $ 5 $ 的步骤处理，随时下放懒标记\n 程序\nprogram b;\ntype tp=record\n  l,r,p:longint;\nend;\n\nvar\n   tree,tree_simple:array[0..200005]of tp;\n   p:array[0..200005]of integer;\n   n,m:longint;\n\nfunction max(a,b:longint):longint;\nbegin\n  if a>b then exit(a) else exit(b);\nend;\n\nprocedure up(t:longint);\nbegin\n  tree[t].p:=max(tree[t shl 1].r+tree[t shl 1 + 1].l,max(tree[t shl 1].p,tree[t shl 1 + 1].p));\n  if tree[t shl 1].p=tree_simple[t shl 1].p then tree[t].l:=tree[t shl 1].p+tree[t shl 1 + 1].l\n    else tree[t].l:=tree[t shl 1].l;\n  if tree[t shl 1 + 1].p=tree_simple[t shl 1 + 1].p then tree[t].r:=tree[t shl 1].r+tree[t shl 1 + 1].p\n    else tree[t].r:=tree[t shl 1 + 1].r;\nend;\n\nprocedure build_simple(l,r,t:longint);\nvar mid:longint;\nbegin\n  if l=r then begin\n    tree_simple[t].p:=1;\n    tree_simple[t].l:=1;\n    tree_simple[t].r:=1;\n    exit;\n  end;\n  mid:=(l+r) shr 1;\n  build_simple(l,mid,t shl 1);\n  build_simple(mid+1,r,t shl 1 + 1);\n  tree_simple[t].p:=tree_simple[t shl 1].p+tree_simple[t shl 1 + 1].p;\n  tree_simple[t].l:=tree_simple[t shl 1].l+tree_simple[t shl 1 + 1].l;\n  tree_simple[t].r:=tree_simple[t shl 1].r+tree_simple[t shl 1 + 1].r;\nend;\n\nprocedure down(t:longint);       //下放懒标记\nbegin\n  if p[t]=0 then exit;\n  if p[t]=1 then begin\n    p[t shl 1]:=p[t];\n    p[t shl 1 + 1]:=p[t];\n    tree[t shl 1].p:=0;\n    tree[t shl 1].l:=0;\n    tree[t shl 1].r:=0;\n    tree[t shl 1 + 1].p:=0;\n    tree[t shl 1 + 1].l:=0;\n    tree[t shl 1 + 1].r:=0;\n    p[t]:=0;\n  end;\n  if p[t]=2 then begin\n    p[t shl 1]:=p[t];\n    p[t shl 1 + 1]:=p[t];\n    tree[t shl 1]:=tree_simple[t shl 1];\n    tree[t shl 1 + 1]:=tree_simple[t shl 1 + 1];\n    p[t]:=0;\n  end;\nend;\n\nprocedure change(l,r,t,x,y,k:longint);\nvar mid:longint;\nbegin         \n  if (x&lt;=l) and (y>=r) then begin\n    if k=1 then begin\n      tree[t].p:=0;\n      tree[t].l:=0;\n      tree[t].r:=0;\n    end\n      else tree[t]:=tree_simple[t];\n    p[t]:=k;\n    exit;\n  end;\n  mid:=(l+r) shr 1;\n  down(t);\n  if x&lt;=mid then change(l,mid,t shl 1,x,y,k);\n  if y>=mid+1 then change(mid+1,r,t shl 1 + 1,x,y,k);\n  up(t);\nend;\n\nfunction dfs(l,r,t,k,len:longint):boolean;\nvar mid:longint;\nbegin\n  dfs:=false;\n  mid:=(l+r) shr 1;\n  down(t);\n  if tree[t].l>=len then begin\n    writeln(l);\n    change(1,n,1,l,l+len-1,k);\n    exit(true);\n  end;\n  if tree[t shl 1].p>=len then dfs:=dfs(l,mid,t shl 1,k,len);\n  if dfs=true then exit(true);\n  if tree[t shl 1].r+tree[t shl 1 + 1].l>=len then begin\n    writeln(mid-tree[t shl 1].r+1);\n    change(1,n,1,mid-tree[t shl 1].r+1,mid-tree[t shl 1].r+len,k);\n    exit(true);\n  end;\n  if tree[t shl 1 + 1].p>=len then dfs:=dfs(mid+1,r,t shl 1 + 1,k,len);\n  if dfs=true then exit(true);\n  if tree[t].r>=len then begin\n    writeln(r-tree[t].r+1);\n    change(1,n,1,r-tree[t].r+1,r-tree[t].r+len,k);\n    exit(true);\n  end;\n  exit(false);\nend;\n\nprocedure main;\nvar i,x,y,z:longint;\nbegin\n  for i:=1 to m do begin\n    read(x);\n    if x=1 then begin\n      read(y);\n      if dfs(1,n,1,1,y)=false then  writeln('0');\n    end\n      else begin\n        read(y,z);\n        change(1,n,1,y,y+z-1,2);\n      end;\n  end;\nend;\n\nbegin\n  read(n,m);\n  build_simple(1,n,1);\n  tree:=tree_simple;\n  main;\nend.\n T3 C\n此题其实并不复杂，一看到字符串的循环，立刻就想到 $ KMP $ ，但是…\n我却敲不出 $ KMP $ 的代码，我好弱啊…\n判断循环节方法：\n到第 $ i $ 位时，若 $ i \\ \\ mod \\ \\ (i-next[i])=0 $ 且 $ i \\ \\ div \\ \\ (i-next[i])&gt;1 $ ,则构成循环节。\n 程序\nprogram c;\nvar\n   s:array[0..1000005]of char;\n   next:array[0..1000005]of longint;\n   n:longint;\n\nprocedure re;\nvar i:longint;\n    p:ansistring;\nbegin\n  readln(p);\n  for i:=1 to n do s[i]:=p[i];\nend;\n\nprocedure first;\nvar i,k:longint;\nbegin\n  i:=0;\n  k:=-1;\n  next[0]:=-1;\n  while i&lt;n do\n    if (k=-1) or (s[i+1]=s[k+1]) then begin\n      inc(k);\n      inc(i);\n      next[i]:=k;\n      if (i mod (i-next[i])=0) and (i div (i-next[i])&lt;>1) then writeln(i,' ',i div (i-next[i]));\n    end else k:=next[k];\nend;\n\nbegin\n  readln(n);\n  re;\n  first;\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day2","url":"/posts/14531.html","content":" 2019.2.12\n 长沙集训 $ Day 2 $\n今天的题目真正有了省选难度，要不是第一题是个暴力我就要爆零了…\n这才是大佬们的世界吧…\n\n T1 十字形\n在今天的模拟赛中，这题算非常简单了，最起码是随机数据。\n\n如此将线段分开存储，将 $ a $ 按照 $ len $ 从大到小排序。将 $ b $ 按照 $ p $ 从小到大， $ len $ 从大到小排序。之后枚举 $ a $ ，用二分查找与 $ b $ 的交点，计算答案，在 $ len &lt; 2 \\cdot ans+1 $ 时退出。便可解决此题。\n其实还有更优的解法，可以对 $ ans $ 二分答案，将各线段两端减去 $ ans $ 的长度后，按 $ x $ 坐标枚举竖直线段，用扫描线+线段树进行维护，判断是否有交点。\n T2 集合\n此题与线性基和高斯消元有关，本数学蒟蒻还未能解决，这里先放题解。\n 官方题解\n(1)如果二进制中第 $ i $ 位一共有奇数个 $ 1 $ ,那么这一位一定会给答案增加 $ 2^{i} $ 的贡献，因为奇数个 $ 1 $ 分成两堆，一定有一堆为奇数个，一堆为偶数个。如果二进制中第 $ i $ 位有偶数个 $ 1 $ ,那么我肯定尽量使得两堆都分得奇数个  $ 1 $ ,那么这一位就会对答案贡献 $ 2 \\times 2^{i} $ ,而且肯定是尽量满足高位。这样的话就可以得到 $ 60 $ 个异或方程。\n例如： $ a_{1,1} \\cdot x_1 \\oplus a_{2,1} \\cdot x_2 \\oplus … \\oplus a_{n,1} \\cdot x_n = f_1 $\n$ a_{i,j} $ 表示第 $ i $ 个数的第 $ j $ 位是否为 $ 1 $ , $ \\oplus $ 表示异或，若这一位一共有奇数个 $ 1 $ ,那么\n$ f $ 值为 $ 0 $ ，否则为 $ 1 $\n(2)先考虑和最大，从高位到低位，如果这一位异或和为 $ 1 $ ，和一定是 $ 1 $ ，不用管。否则的话异或和可能是 $ 2 $ 或者 $ 0 $ ，如果可以是 $ 2 $ 的话一定要求是 $ 2 $ 。再考虑 $ x_1 $ 最小。跟上面类似，如果异或和是 $ 1 $ 的话，尽量让 $ x_1 $ 取 $ 0 $ 。关键是如何维护这些限制条件。可以用 $ x_i $ 表示第 $ i $ 个数是否选择，那么每个条件都是形如 $ XOR^{n-1}{i=0} a{i,j} \\cdot x_i =y_j $ 。这样用高斯消元维护一下就可以了，对于每个新方程，如果产生新的主元就加进来。\n 线性基\n线性基是一种贪心的算法。\n用 $ p[i] $ 记录 $ 1 $ 最高位为第i位的数：\n\n$ p[i]=0 $ ，直接记录\n$ p[i]&lt;&gt;0 $ ,将$ x \\ \\ xor \\ \\ p[i] $ ，再继续处理\n\n\nfor t:&#x3D;62 downto 0 do\n  if x shr t&lt;&gt;0 then begin\n    if p[t]&#x3D;0 then begin p[t]:&#x3D;x;break; end\n      else x:&#x3D;x xor p[t];\n  end;\n计算答案：\n\n尽量使高位上的 $ 1 $ 更多，这样答案更大\n从高位开始，如果 $ ans \\ \\ xor \\ \\ p[i] $ 更大，则更新 $ ans $\n\nfor i:&#x3D;62 downto 0 do\n  if ans xor p[i]&gt;ans then ans:&#x3D;ans xor p[i];","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"长沙集训Day1","url":"/posts/14723.html","content":" 2019.2.11\n 长沙集训 $ Day1 $\n今天是长沙集训的第一天，今天的题目还是比较简单的。\n其实是老师特别出了简单题，照顾我这个蒟蒻！！！\n\n T1完美子串\n这题是普通的模拟，从字符串首开始，将尾指针向后移动。每移动一位就将该位上的字符放入桶中计数。\n如果 $ 26 $ 个字母均已出现，则开始移动头指针，并将头指针处的字符从桶中去除。在所有子串中选择长度最小的作为答案。\n 程序\nprogram str;\nvar\n   s:array[0..2000005]of char;\n   sum:array['A'..'Z']of longint;\n   len,ans:longint;\n\nprocedure re;\nvar st:ansistring;\n    i:longint;\nbegin\n  readln(st);\n  len:=length(st);\n  for i:=1 to len do s[i]:=st[i];\nend;\n\nfunction sc:boolean;\nvar i:char;\nbegin\n  for i:='A' to 'Z' do\n    if sum[i]=0 then exit(false);\n  exit(true);\nend;\n\nprocedure main;\nvar head,tail:longint;\nbegin\n  ans:=100000000;\n  head:=0;\n  tail:=1;\n  while tail&lt;=len do begin\n    inc(sum[s[tail]]);\n    while sc=true do begin\n      if tail-head&lt;ans then ans:=tail-head;\n      inc(head);\n      dec(sum[s[head]]);\n    end;\n    inc(tail);\n  end;\n  if ans=100000000 then writeln('QwQ')\n    else writeln(ans);\nend;\n\nbegin\n  re;\n  main;\nend.\n\n T2游戏\n此题是一道数学题，若不是有 $ CRN $ 巨佬的思路我估计就爆零了…\n假设局游戏的分数是 $ k_{1} \\ \\ k_{2} \\ \\ k_{3} …$\n因为每人的得分只能是 $ k^{2} $ 或 $ k $ ，所以设两人的得分相乘为 $ P $ ， $ P=(k_{1} \\cdot k_{2} \\cdot k_{3} \\cdot … \\cdot k_{n})^{3}$ ,所以 $ \\sqrt[3]{P} $ 一定是一个整数。\n设 $ Q= \\sqrt[3]{P} $ ，两人的得分也一定能被 $ Q $ 整除。\n所以：\n\n$ Q $ 不为整数，输出 $ No $\n两人得分不能被 $ Q $ 整除，输出 $ No $\n$ Q $ 为整数，且两人得分都能被 $ Q $ 整除，输出 $ Yes $\n\n$ Q $ 可以用二分快速求出，记得用 $ int64 $ !!!\n 程序\nprogram game;\nvar\n   t:longint;\n\nfunction sc(q:int64):int64;\nvar l,r,mid,ans:int64;\nbegin\n  ans:=-1;\n  l:=0;\n  r:=1000001;\n  while l&lt;=r do begin\n    mid:=(l+r) shr 1;\n    if mid*mid*mid=q then begin ans:=mid;break; end;\n    if mid*mid*mid&lt;q then l:=mid+1\n      else r:=mid-1;\n  end;\n  exit(ans);\nend;\n\nprocedure main;\nvar x,y,z:int64;\n    i:longint;\nbegin\n  for i:=1 to t do begin\n    read(x,y);\n    z:=sc(x*y);   \n    if z=-1 then writeln('No')\n      else if (x mod z=0) and (y mod z=0) then writeln('Yes')\n        else writeln('No');\n  end;\nend;\n\nbegin\n  read(t);\n  main;\nend.\n\n T3泥泞的牧场\n这题是二分图匹配的模板题。\n 二分图\n\n如此，像这种可以分成两份，每一份中的点互不相交的图就是二分图。\n 二分图匹配\n\n如此，连接像这样无公共顶点的两条边，就是一个二分图匹配。\n 最大匹配\n\n最大匹配就是选择尽量多的边，使得选中的边中任意两条边均没有公共点。如果所有的点都是匹配点那就是一个完美匹配。\n上图的最大匹配便是 $ 3 $ 。\n求解二分图匹配的基本算法是匈牙利算法。\n 匈牙利算法\n 增广路\n从一个未匹配的点开始，依次走过未匹配边，匹配边，未匹配边，匹配边… 如果最后的终点是一个未匹配点（即最后一条边是一条未匹配边），那么这条路就是一条增广路。而将增广路上的未匹配边和匹配边进行互换，就会使得匹配边多一条。\n匈牙利算法便是利用增广路进行处理。\n 处理方法\n1.对于一个节点，遍历与其相连的节点，如果可以直接连接，就立即进行连接。\n\n2.继续下一个节点，发现直连节点已被占用。\n\n3.搜索到增广路。\n\n4.依靠增广路进行扩展。\n\n5.非增广路，不进行扩展。\n\n6.无增广路，左侧无空节点，处理结束。\n\n 本题转化\n本题题面虽与二分图无关，但可以通过奇妙的变化，转为二分图匹配问题。\n我们将连续行的 $ * $ 设为左侧图，连续列的 $ * $ 设为右侧图，行列的交点设为在两节点之间连了一条边。\n\n\n之后我们要求出此图的最小顶点覆盖，因为我们在一行&amp;一列放上木板，相当于选取了图中的一个点，覆盖的泥地相当于图中与此顶点相连的边。所以用最少的木板覆盖全部泥地相当于选最少的顶点覆盖全部的边。\n根据二分图特点，最小顶点覆盖=最大匹配，求出该图的最大匹配就是答案。\n 程序\nprogram cover;\nvar\n   f:array[0..55,0..55]of char;\n   x,y:array[0..55,0..55]of longint;\n   p:array[0..505,0..505]of longint;\n   next,next_f:array[0..505]of longint;\n   tf:array[0..505,0..505]of boolean;\n   t:array[0..505]of boolean;\n   n,m,ans,totx,toty:longint;\n\nprocedure re;\nvar i,j:longint;\n    s:string;\nbegin\n  for i:=0 to 55 do\n    for j:=0 to 55 do f[i,j]:='.';\n  for i:=1 to n do begin\n    readln(s);\n    for j:=1 to m do f[i,j]:=s[j];\n  end;\nend;\n\nprocedure cover1(p,q:longint);\nvar i:longint;\nbegin\n  for i:=q to m do\n    if f[p,i]='*' then x[p,i]:=totx\n      else if f[p,i]='.' then break;\nend;\n\nprocedure cover2(p,q:longint);\nvar i:longint;\nbegin\n  for i:=q to n do\n    if f[i,p]='*' then y[i,p]:=toty\n      else if f[i,p]='.' then break;\nend;\n\nprocedure dfs_first;\nvar i,j:longint;\nbegin\n  for i:=1 to n do\n    for j:=1 to m do\n      if f[i,j]='*' then begin\n        if f[i,j-1]='.' then begin\n          inc(totx);\n          cover1(i,j);\n        end;\n        if f[i-1,j]='.' then begin\n          inc(toty);\n          cover2(j,i);\n        end;\n      end;\nend;\n\nprocedure dfs_up;\nvar i,j:longint;\nbegin\n  for i:=1 to n do\n    for j:=1 to m do\n      if tf[x[i,j],y[i,j]]=false then begin\n        tf[x[i,j],y[i,j]]:=true;\n        inc(p[x[i,j],0]);\n        p[x[i,j],p[x[i,j],0]]:=y[i,j];\n      end;\nend;\n\nfunction dfs(q:longint):boolean;\nvar i:longint;\nbegin\n  dfs:=false;\n  for i:=1 to p[q,0] do\n    if next_f[q]&lt;>p[q,i] then\n      if next[p[q,i]]=0 then begin\n        next[p[q,i]]:=q;\n        next_f[q]:=p[q,i];\n        exit(true);\n      end;\n  for i:=1 to p[q,0] do\n    if (next_f[q]&lt;>p[q,i]) and (t[p[q,i]]=false) then begin\n      t[p[q,i]]:=true;\n      if dfs(next[p[q,i]])=true then begin\n        next[p[q,i]]:=q;\n        next_f[q]:=p[q,i];\n        exit(true);\n      end;\n    end;\nend;\n\nprocedure main;\nvar i:longint;\nbegin\n  ans:=0;\n  for i:=1 to totx do begin\n    if dfs(i)=true then inc(ans);\n    fillchar(t,sizeof(t),false);\n  end;\nend;\n\nbegin\n  readln(n,m);\n  re;\n  dfs_first;\n  dfs_up;\n  main;\n  writeln(ans);\nend.\n","categories":["记录","训练","长沙集训"],"tags":["Pascal"]},{"title":"NOIP2018赛后总结","url":"/posts/39015.html","content":" 1.题目难度（个人理解）\n\n 2.考察算法\n暴力枚举\n完全背包\n树上二分\n搜索DFS\n基环树？\n数学（找规律？）\n树上DP\nLCA倍增思想\n动态DP？\n 3.题目分析\n Day1T1.铺设道路（road）\n 考察算法：\n暴力枚举，刷原题\n 解析：\n其实这道题还是很有价值的，如果不是原题的话…\n这题和NOIP2013Day2T1积木大赛一模一样，只是改了题面而已。\n不过对于没做过原题的我，在考场上也是思考了一个多小时…\n其实做法很简单，对于读入的第 iii 块道路，只需比较它和第 i−1i-1i−1 块道路的深度，设 a[i]a[i]a[i] 表示第 iii 块道路的深度， a[i−1]a[i-1]a[i−1] 表示第 i−1i-1i−1 块道路的深度， ansansans 为答案：\n若 a[i−1]≥a[i]a[i-1] \\ge a[i]a[i−1]≥a[i] ,则再填第 i−1i-1i−1 块道路时，第 iii 块道路已经被填过了，所以不用进行任何操作。\n若 a[i−1]&lt;a[i]a[i-1] &lt; a[i]a[i−1]&lt;a[i] ,则在填第 i−1i-1i−1 块道路时，第 iii 块道路还有部分未被填完，此时需要将答案加上两块道路深度的差值，即 ans=ans+a[i]−a[i−1]ans=ans+a[i]-a[i-1]ans=ans+a[i]−a[i−1]\n像这样从头到尾枚举一遍，问题就解决了，最后输出 ansansans ,时间复杂度接近 O(n)O(n)O(n)\n 程序：\nprogram road;\nvar\n   n,i,t,d:longint;\n   sum:int64;\n\nbegin\n  read(n);\n  t:=0;\n  for i:=1 to n do begin\n    read(d);\n    if d>t then inc(sum,d-t);\n    t:=d;\n  end;\n  writeln(sum);\nend.\n Day1T2.货币系统（money）\n 考察算法：\n装满型完全背包\n 解析：\n这题据说也是原题，不过我是不知道原题是啥。\n具体解析和程序点这里\n Day1T3.赛道修建（track）\n 考察算法：\n树上二分，树形DP\n 解析：\n有大佬说这题还是原题！Day1原题大战？\n这题算是很标准的树上二分题目，其实题目说道**“求最短路径的最大长度”**就已经可以明确是二分了，然而我在考场上打 checkcheckcheck 函数打了将近两个小时，结果还炸了，看来以后也得加强编程能力啊！！！\n具体解析和程序点这里\n Day2T1.旅行（travel）\n 考察算法：\n暴力枚举，搜索DFS，基环树？\n 解析：\n 首先对于前 151515 组数据：\n这些数据的处理非常简单，只要从 111 号节点开始，在扩展时优先选择编号小的节点，对树进行一次DFS即可。时间复杂度接近 O(n)O(n)O(n) 。\n 对于所有数据：\n这些数据中，图是一棵基环树，简单的进行一次搜索无法得到正确答案。其实处理方法也很简单，我们先把通过搜索，把图中的环给找到，然后暴力断开环上的每一条边，并在每次断边后的图上进行一次DFS，最后取所有结果中的最优值即可。时间复杂度接近 O(n2)O(n^{2})O(n2) 。\n 程序：\n 期望60分：\nprogram travel;\nvar\n   l,v:array[0..10005]of longint;\n   r,path:array[0..5005]of longint;\n   tf:array[0..5005]of boolean;\n   n,m,i,x,y,t,k:longint;\n\nprocedure sc(f,fa:longint);\nvar i,next:longint;\nbegin\n  while true do begin\n    next:=100000;\n    i:=r[f];\n    while i&lt;>0 do begin\n      if (tf[v[i]]=false) and (v[i]&lt;next) and (v[i]&lt;>fa) then next:=v[i];\n      i:=l[i];\n    end;\n    if next=100000 then exit;\n    tf[next]:=true;\n    inc(k);\n    path[k]:=next;\n    sc(next,f);\n  end;\nend;\n\nbegin\n  read(n,m);\n  fillchar(r,sizeof(r),0);\n  fillchar(tf,sizeof(tf),0);\n  fillchar(l,sizeof(l),0);\n  fillchar(v,sizeof(v),0);\n  fillchar(path,sizeof(path),0);\n  for i:=1 to m do begin\n    read(x,y);\n    t:=2*i;\n    l[t]:=r[x];\n    r[x]:=t;\n    v[t]:=y;\n    l[t-1]:=r[y];\n    r[y]:=t-1;\n    v[t-1]:=x;\n  end;\n  k:=1;\n  path[k]:=1;\n  tf[0]:=true;\n  sc(1,0);\n  for i:=1 to k do write(path[i],' ');\nend.\n 期望100分：\nprogram project1;\nvar\n   r,path,father,son,ans:array[0..5005]of longint;\n   tf:array[0..5005]of boolean;\n   l,v:array[0..10005]of longint;\n   n,m,i,x,y,t,k,p,fat:longint;\n\nprocedure sc(f,fa:longint);\nvar i,next:longint;\nbegin\n  while true do begin\n    next:=100000;\n    i:=r[f];\n    while i&lt;>0 do begin\n      if (v[i]&lt;next) and (v[i]&lt;>fa) and (tf[v[i]]=false) and (v[i]&lt;>0) then next:=v[i];\n      i:=l[i];\n    end;\n    if next=100000 then exit;\n    tf[next]:=true;\n    inc(k);\n    path[k]:=next;\n    sc(next,f);\n  end;\nend;\n\nfunction min:boolean;\nvar i:longint;\nbegin\n  for i:=1 to n do\n    if ans[i]>path[i] then exit(true)\n      else if ans[i]&lt;path[i] then exit(false);\n  exit(false);\nend;\n\nfunction del(f,fa:longint):boolean;\nvar i:longint;\nbegin\n  del:=false;\n  i:=r[f];\n  while i&lt;>0 do begin\n    if v[i]&lt;>fa then begin\n      if father[v[i]]=0 then father[v[i]]:=f\n        else begin\n          p:=v[i];\n          fat:=father[v[i]];\n          father[v[i]]:=f;\n          son[f]:=v[i];\n          exit(true);\n        end;\n      if del(v[i],f)=true then begin\n        son[f]:=v[i];\n        exit(true)\n      end;\n    end;\n    i:=l[i];\n  end;\nend;\n\nprocedure cut(x,y:longint);\nvar i,j:longint;\nbegin\n  i:=r[x];\n  while i&lt;>0 do begin\n    if v[i]=y then begin\n      v[i]:=0;\n      if i mod 2=0 then j:=i-1 else j:=i+1;\n      v[j]:=0;\n      fillchar(tf,sizeof(tf),0);\n      fillchar(path,sizeof(path),0);\n      k:=1;\n      path[k]:=1;\n      sc(1,0);\n      if min=true then ans:=path;\n      v[i]:=y;\n      v[j]:=x;\n      exit;\n    end;\n    i:=l[i];\n  end;\nend;\n\nprocedure point(p:longint);\nvar i:longint;\nbegin\n  i:=p;\n  cut(i,son[i]);\n  i:=son[i];\n  while i&lt;>p do begin\n    cut(i,son[i]);\n    i:=son[i];\n  end;\nend;\n\nbegin\n  read(n,m);\n  fillchar(tf,sizeof(tf),0);\n  fillchar(path,sizeof(path),0);\n  fillchar(ans,sizeof(ans),$5f);\n  k:=0;\n  for i:=1 to m do begin\n    read(x,y);\n    t:=i*2;\n    l[t]:=r[x];\n    r[x]:=t;\n    v[t]:=y;\n    l[t-1]:=r[y];\n    r[y]:=t-1;\n    v[t-1]:=x;\n  end;\n  inc(k);\n  path[k]:=1;\n  father[1]:=1;\n  if m=n then begin\n    del(1,0);\n    point(p);\n  end\n  else begin sc(1,0);ans:=path; end;\n  for i:=1 to n do write(ans[i],' ');\nend.\n 此题还有更优的 O(nlog⁡n)O(n \\log n)O(nlogn) 算法：具体解析和程序点这里\n Day2T2.填数游戏（game）\n 考察算法：\n数学推导，找规律？\n 解析：\n说实话，我在考场上真没想到这题能找规律，我一直以为这是一个状压DP。后来经过大佬指点，才发现其实是能通过找规律AC的。但这题究竟标算是什么，我到现在也不了解，毕竟NOIP不会出一道打表找规律的题吧?而且这题不管是手摸，还是打表，想发现规律都异常困难，如果真考找规律，这题也是十分毒瘤了！\n具体解析和程序点这里\n Day2T3.保卫王国（defense）\n 考察算法：\n树上DP，LCA倍增思想，动态DP？\n 解析：\n在考场上，我只想出了44分的暴力算法\n考后听说是动态DP模板，可动态DP是NOI的考察内容啊！如果这题考动态DP，那超纲也太严重了吧。一定还有别的做法，在考后我经过反复思考，结合大佬的提示，终于发现了用LCA倍增思想解决问题的方法。\n具体解析和程序点这里\n","categories":["记录","竞赛"],"tags":["Pascal"]}]